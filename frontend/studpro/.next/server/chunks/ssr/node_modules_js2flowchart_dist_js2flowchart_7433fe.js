module.exports = {

"[project]/node_modules/js2flowchart/dist/js2flowchart.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/*! For license information please see js2flowchart.js.LICENSE.txt */ !function(e1, t) {
    ("TURBOPACK compile-time truthy", 1) ? module.exports = t() : ("TURBOPACK unreachable", undefined);
}("undefined" != typeof window ? window : this, ()=>(()=>{
        var e1 = {
            2509: function(e1, t, n) {
                !function(e1, t, n, r) {
                    "use strict";
                    let i;
                    e1.addSegment = void 0, e1.addMapping = void 0, e1.maybeAddSegment = void 0, e1.maybeAddMapping = void 0, e1.setSourceContent = void 0, e1.toDecodedMap = void 0, e1.toEncodedMap = void 0, e1.fromMap = void 0, e1.allMappings = void 0;
                    class s {
                        constructor({ file: e1, sourceRoot: n } = {}){
                            this._names = new t.SetArray, this._sources = new t.SetArray, this._sourcesContent = [], this._mappings = [], this.file = e1, this.sourceRoot = n;
                        }
                    }
                    function a(e1, t, n) {
                        for(let n = e1.length; n > t; n--)e1[n] = e1[n - 1];
                        e1[t] = n;
                    }
                    function o(e1, n) {
                        for(let r = 0; r < n.length; r++)t.put(e1, n[r]);
                    }
                    function l(e1, t, n) {
                        const { generated: r, source: s, original: a, name: o, content: l } = n;
                        if (!s) return i(e1, t, r.line - 1, r.column, null, null, null, null, null);
                        const c = s;
                        return i(e1, t, r.line - 1, r.column, c, a.line - 1, a.column, o, l);
                    }
                    e1.addSegment = (e1, t, n, r, s, a, o, l)=>i(!1, e1, t, n, r, s, a, o, l), e1.maybeAddSegment = (e1, t, n, r, s, a, o, l)=>i(!0, e1, t, n, r, s, a, o, l), e1.addMapping = (e1, t)=>l(!1, e1, t), e1.maybeAddMapping = (e1, t)=>l(!0, e1, t), e1.setSourceContent = (e1, n, r)=>{
                        const { _sources: i, _sourcesContent: s } = e1;
                        s[t.put(i, n)] = r;
                    }, e1.toDecodedMap = (e1)=>{
                        const { file: t, sourceRoot: n, _mappings: r, _sources: i, _sourcesContent: s, _names: a } = e1;
                        return function(e1) {
                            const { length: t } = e1;
                            let n = t;
                            for(let t = n - 1; t >= 0 && !(e1[t].length > 0); n = t, t--);
                            n < t && (e1.length = n);
                        }(r), {
                            version: 3,
                            file: t || void 0,
                            names: a.array,
                            sourceRoot: n || void 0,
                            sources: i.array,
                            sourcesContent: s,
                            mappings: r
                        };
                    }, e1.toEncodedMap = (t)=>{
                        const r = e1.toDecodedMap(t);
                        return Object.assign(Object.assign({}, r), {
                            mappings: n.encode(r.mappings)
                        });
                    }, e1.allMappings = (e1)=>{
                        const t = [], { _mappings: n, _sources: r, _names: i } = e1;
                        for(let e1 = 0; e1 < n.length; e1++){
                            const s = n[e1];
                            for(let n = 0; n < s.length; n++){
                                const a = s[n], o = {
                                    line: e1 + 1,
                                    column: a[0]
                                };
                                let l, c, u;
                                1 !== a.length && (l = r.array[a[1]], c = {
                                    line: a[2] + 1,
                                    column: a[3]
                                }, 5 === a.length && (u = i.array[a[4]])), t.push({
                                    generated: o,
                                    source: l,
                                    original: c,
                                    name: u
                                });
                            }
                        }
                        return t;
                    }, e1.fromMap = (e1)=>{
                        const t = new r.TraceMap(e1), n = new s({
                            file: t.file,
                            sourceRoot: t.sourceRoot
                        });
                        return o(n._names, t.names), o(n._sources, t.sources), n._sourcesContent = t.sourcesContent || t.sources.map(()=>null), n._mappings = r.decodedMappings(t), n;
                    }, i = (e1, n, r, i, s, o, l, c, u)=>{
                        const { _mappings: p, _sources: h, _sourcesContent: d, _names: f } = n, y = function(e1, t) {
                            for(let n = e1.length; n <= t; n++)e1[n] = [];
                            return e1[t];
                        }(p, r), m = function(e1, t) {
                            let n = e1.length;
                            for(let r = n - 1; r >= 0 && !(t >= e1[r][0]); n = r--);
                            return n;
                        }(y, i);
                        if (!s) {
                            if (e1 && function(e1, t) {
                                return 0 === t || 1 === e1[t - 1].length;
                            }(y, m)) return;
                            return a(y, m, [
                                i
                            ]);
                        }
                        const T = t.put(h, s), g = c ? t.put(f, c) : -1;
                        if (T === d.length && (d[T] = null != u ? u : null), !e1 || !function(e1, t, n, r, i, s) {
                            if (0 === t) return !1;
                            const a = e1[t - 1];
                            return 1 !== a.length && n === a[1] && r === a[2] && i === a[3] && s === (5 === a.length ? a[4] : -1);
                        }(y, m, T, o, l, g)) return a(y, m, c ? [
                            i,
                            T,
                            o,
                            l,
                            g
                        ] : [
                            i,
                            T,
                            o,
                            l
                        ]);
                    }, e1.GenMapping = s, Object.defineProperty(e1, "__esModule", {
                        value: !0
                    });
                }(t, n(2208), n(2297), n(3446));
            },
            8435: function(e1) {
                e1.exports = function() {
                    "use strict";
                    const e1 = /^[\w+.-]+:\/\//, t = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, n = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
                    var r;
                    function i(e1) {
                        return e1.startsWith("/");
                    }
                    function s(e1) {
                        return /^[.?#]/.test(e1);
                    }
                    function a(e1) {
                        const n = t.exec(e1);
                        return o(n[1], n[2] || "", n[3], n[4] || "", n[5] || "/", n[6] || "", n[7] || "");
                    }
                    function o(e1, t, n, i, s, a, o) {
                        return {
                            scheme: e1,
                            user: t,
                            host: n,
                            port: i,
                            path: s,
                            query: a,
                            hash: o,
                            type: r.Absolute
                        };
                    }
                    function l(t) {
                        if (function(e1) {
                            return e1.startsWith("//");
                        }(t)) {
                            const e1 = a("http:" + t);
                            return e1.scheme = "", e1.type = r.SchemeRelative, e1;
                        }
                        if (i(t)) {
                            const e1 = a("http://foo.com" + t);
                            return e1.scheme = "", e1.host = "", e1.type = r.AbsolutePath, e1;
                        }
                        if (function(e1) {
                            return e1.startsWith("file:");
                        }(t)) return function(e1) {
                            const t = n.exec(e1), r = t[2];
                            return o("file:", "", t[1] || "", "", i(r) ? r : "/" + r, t[3] || "", t[4] || "");
                        }(t);
                        if (function(t) {
                            return e1.test(t);
                        }(t)) return a(t);
                        const s = a("http://foo.com/" + t);
                        return s.scheme = "", s.host = "", s.type = t ? t.startsWith("?") ? r.Query : t.startsWith("#") ? r.Hash : r.RelativePath : r.Empty, s;
                    }
                    function c(e1, t) {
                        const n = t <= r.RelativePath, i = e1.path.split("/");
                        let s = 1, a = 0, o = !1;
                        for(let e1 = 1; e1 < i.length; e1++){
                            const t = i[e1];
                            t ? (o = !1, "." !== t && (".." !== t ? (i[s++] = t, a++) : a ? (o = !0, a--, s--) : n && (i[s++] = t))) : o = !0;
                        }
                        let l = "";
                        for(let e1 = 1; e1 < s; e1++)l += "/" + i[e1];
                        (!l || o && !l.endsWith("/..")) && (l += "/"), e1.path = l;
                    }
                    return function(e1) {
                        e1[e1.Empty = 1] = "Empty", e1[e1.Hash = 2] = "Hash", e1[e1.Query = 3] = "Query", e1[e1.RelativePath = 4] = "RelativePath", e1[e1.AbsolutePath = 5] = "AbsolutePath", e1[e1.SchemeRelative = 6] = "SchemeRelative", e1[e1.Absolute = 7] = "Absolute";
                    }(r || (r = {})), function(e1, t) {
                        if (!e1 && !t) return "";
                        const n = l(e1);
                        let i = n.type;
                        if (t && i !== r.Absolute) {
                            const e1 = l(t), s = e1.type;
                            switch(i){
                                case r.Empty:
                                    n.hash = e1.hash;
                                case r.Hash:
                                    n.query = e1.query;
                                case r.Query:
                                case r.RelativePath:
                                    !function(e1, t) {
                                        c(t, t.type), "/" === e1.path ? e1.path = t.path : e1.path = function(e1) {
                                            if (e1.endsWith("/..")) return e1;
                                            const t = e1.lastIndexOf("/");
                                            return e1.slice(0, t + 1);
                                        }(t.path) + e1.path;
                                    }(n, e1);
                                case r.AbsolutePath:
                                    n.user = e1.user, n.host = e1.host, n.port = e1.port;
                                case r.SchemeRelative:
                                    n.scheme = e1.scheme;
                            }
                            s > i && (i = s);
                        }
                        c(n, i);
                        const a = n.query + n.hash;
                        switch(i){
                            case r.Hash:
                            case r.Query:
                                return a;
                            case r.RelativePath:
                                {
                                    const r = n.path.slice(1);
                                    return r ? s(t || e1) && !s(r) ? "./" + r + a : r + a : a || ".";
                                }
                            case r.AbsolutePath:
                                return n.path + a;
                            default:
                                return n.scheme + "//" + n.user + n.host + n.port + n.path + a;
                        }
                    };
                }();
            },
            2208: function(e1, t) {
                !function(e1) {
                    "use strict";
                    e1.get = void 0, e1.put = void 0, e1.pop = void 0;
                    e1.get = (e1, t)=>e1._indexes[t], e1.put = (t, n)=>{
                        const r = e1.get(t, n);
                        if (void 0 !== r) return r;
                        const { array: i, _indexes: s } = t;
                        return s[n] = i.push(n) - 1;
                    }, e1.pop = (e1)=>{
                        const { array: t, _indexes: n } = e1;
                        0 !== t.length && (n[t.pop()] = void 0);
                    }, e1.SetArray = class {
                        constructor(){
                            this._indexes = {
                                __proto__: null
                            }, this.array = [];
                        }
                    }, Object.defineProperty(e1, "__esModule", {
                        value: !0
                    });
                }(t);
            },
            2297: function(e1, t, n) {
                var r = n(8764).lW;
                !function(e1) {
                    "use strict";
                    const t = ",".charCodeAt(0), n = ";".charCodeAt(0), i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = new Uint8Array(64), a = new Uint8Array(128);
                    for(let e1 = 0; e1 < 64; e1++){
                        const t = i.charCodeAt(e1);
                        s[e1] = t, a[t] = e1;
                    }
                    const o = "undefined" != typeof TextDecoder ? new TextDecoder : void 0 !== r ? {
                        decode: (e1)=>r.from(e1.buffer, e1.byteOffset, e1.byteLength).toString()
                    } : {
                        decode (e1) {
                            let t = "";
                            for(let n = 0; n < e1.length; n++)t += String.fromCharCode(e1[n]);
                            return t;
                        }
                    };
                    function l(e1, t) {
                        const n = e1.indexOf(";", t);
                        return -1 === n ? e1.length : n;
                    }
                    function c(e1, t, n, r) {
                        let i = 0, s = 0, o = 0;
                        do {
                            const n = e1.charCodeAt(t++);
                            o = a[n], i |= (31 & o) << s, s += 5;
                        }while (32 & o)
                        const l = 1 & i;
                        return i >>>= 1, l && (i = -2147483648 | -i), n[r] += i, t;
                    }
                    function u(e1, n, r) {
                        return !(n >= r) && e1.charCodeAt(n) !== t;
                    }
                    function p(e1) {
                        e1.sort(h);
                    }
                    function h(e1, t) {
                        return e1[0] - t[0];
                    }
                    function d(e1, t, n, r, i) {
                        const a = r[i];
                        let o = a - n[i];
                        n[i] = a, o = o < 0 ? -o << 1 | 1 : o << 1;
                        do {
                            let n = 31 & o;
                            o >>>= 5, o > 0 && (n |= 32), e1[t++] = s[n];
                        }while (o > 0)
                        return t;
                    }
                    e1.decode = function(e1) {
                        const t = new Int32Array(5), n = [];
                        let r = 0;
                        do {
                            const i = l(e1, r), s = [];
                            let a = !0, o = 0;
                            t[0] = 0;
                            for(let n = r; n < i; n++){
                                let r;
                                n = c(e1, n, t, 0);
                                const l = t[0];
                                l < o && (a = !1), o = l, u(e1, n, i) ? (n = c(e1, n, t, 1), n = c(e1, n, t, 2), n = c(e1, n, t, 3), u(e1, n, i) ? (n = c(e1, n, t, 4), r = [
                                    l,
                                    t[1],
                                    t[2],
                                    t[3],
                                    t[4]
                                ]) : r = [
                                    l,
                                    t[1],
                                    t[2],
                                    t[3]
                                ]) : r = [
                                    l
                                ], s.push(r);
                            }
                            a || p(s), n.push(s), r = i + 1;
                        }while (r <= e1.length)
                        return n;
                    }, e1.encode = function(e1) {
                        const r = new Int32Array(5), i = 16384, s = 16348, a = new Uint8Array(i), l = a.subarray(0, s);
                        let c = 0, u = "";
                        for(let p = 0; p < e1.length; p++){
                            const h = e1[p];
                            if (p > 0 && (c === i && (u += o.decode(a), c = 0), a[c++] = n), 0 !== h.length) {
                                r[0] = 0;
                                for(let e1 = 0; e1 < h.length; e1++){
                                    const n = h[e1];
                                    c > s && (u += o.decode(l), a.copyWithin(0, s, c), c -= s), e1 > 0 && (a[c++] = t), c = d(a, c, r, n, 0), 1 !== n.length && (c = d(a, c, r, n, 1), c = d(a, c, r, n, 2), c = d(a, c, r, n, 3), 4 !== n.length && (c = d(a, c, r, n, 4)));
                                }
                            }
                        }
                        return u + o.decode(a.subarray(0, c));
                    }, Object.defineProperty(e1, "__esModule", {
                        value: !0
                    });
                }(t);
            },
            3446: function(e1, t, n) {
                !function(e1, t, n) {
                    "use strict";
                    function r(e1) {
                        return e1 && "object" == typeof e1 && "default" in e1 ? e1 : {
                            default: e1
                        };
                    }
                    var i = r(n);
                    function s(e1, t) {
                        return t && !t.endsWith("/") && (t += "/"), i.default(e1, t);
                    }
                    const a = 0, o = 1, l = 2, c = 3, u = 4;
                    function p(e1, t) {
                        for(let n = t; n < e1.length; n++)if (!h(e1[n])) return n;
                        return e1.length;
                    }
                    function h(e1) {
                        for(let t = 1; t < e1.length; t++)if (e1[t][a] < e1[t - 1][a]) return !1;
                        return !0;
                    }
                    function d(e1, t) {
                        return t || (e1 = e1.slice()), e1.sort(f);
                    }
                    function f(e1, t) {
                        return e1[a] - t[a];
                    }
                    let y = !1;
                    function m(e1, t, n) {
                        for(let r = n + 1; r < e1.length && e1[r][a] === t; n = r++);
                        return n;
                    }
                    function T(e1, t, n) {
                        for(let r = n - 1; r >= 0 && e1[r][a] === t; n = r--);
                        return n;
                    }
                    function g() {
                        return {
                            lastKey: -1,
                            lastNeedle: -1,
                            lastIndex: -1
                        };
                    }
                    function b(e1, t, n, r) {
                        const { lastKey: i, lastNeedle: s, lastIndex: o } = n;
                        let l = 0, c = e1.length - 1;
                        if (r === i) {
                            if (t === s) return y = -1 !== o && e1[o][a] === t, o;
                            t >= s ? l = -1 === o ? 0 : o : c = o;
                        }
                        return n.lastKey = r, n.lastNeedle = t, n.lastIndex = function(e1, t, n, r) {
                            for(; n <= r;){
                                const i = n + (r - n >> 1), s = e1[i][a] - t;
                                if (0 === s) return y = !0, i;
                                s < 0 ? n = i + 1 : r = i - 1;
                            }
                            return y = !1, n - 1;
                        }(e1, t, l, c);
                    }
                    function E(e1, t, n) {
                        for(let n = e1.length; n > t; n--)e1[n] = e1[n - 1];
                        e1[t] = n;
                    }
                    function S() {
                        return {
                            __proto__: null
                        };
                    }
                    function P(e1, t, n, r, i, s, a, o, l, c) {
                        const { sections: u } = e1;
                        for(let e1 = 0; e1 < u.length; e1++){
                            const { map: p, offset: h } = u[e1];
                            let d = l, f = c;
                            if (e1 + 1 < u.length) {
                                const t = u[e1 + 1].offset;
                                d = Math.min(l, a + t.line), d === l ? f = Math.min(c, o + t.column) : d < l && (f = o + t.column);
                            }
                            x(p, t, n, r, i, s, a + h.line, o + h.column, d, f);
                        }
                    }
                    function x(t, n, r, i, s, p, h, d, f, y) {
                        if ("sections" in t) return P(...arguments);
                        const m = new O(t, n), T = i.length, g = p.length, b = e1.decodedMappings(m), { resolvedSources: E, sourcesContent: S } = m;
                        if (D(i, E), D(p, m.names), S) D(s, S);
                        else for(let e1 = 0; e1 < E.length; e1++)s.push(null);
                        for(let e1 = 0; e1 < b.length; e1++){
                            const t = h + e1;
                            if (t > f) return;
                            const n = A(r, t), i = 0 === e1 ? d : 0, s = b[e1];
                            for(let e1 = 0; e1 < s.length; e1++){
                                const r = s[e1], p = i + r[a];
                                if (t === f && p >= y) return;
                                if (1 === r.length) {
                                    n.push([
                                        p
                                    ]);
                                    continue;
                                }
                                const h = T + r[o], d = r[l], m = r[c];
                                n.push(4 === r.length ? [
                                    p,
                                    h,
                                    d,
                                    m
                                ] : [
                                    p,
                                    h,
                                    d,
                                    m,
                                    g + r[u]
                                ]);
                            }
                        }
                    }
                    function D(e1, t) {
                        for(let n = 0; n < t.length; n++)e1.push(t[n]);
                    }
                    function A(e1, t) {
                        for(let n = e1.length; n <= t; n++)e1[n] = [];
                        return e1[t];
                    }
                    const v = "`line` must be greater than 0 (lines start at line 1)", C = "`column` must be greater than or equal to 0 (columns start at column 0)", w = -1;
                    e1.encodedMappings = void 0, e1.decodedMappings = void 0, e1.traceSegment = void 0, e1.originalPositionFor = void 0, e1.generatedPositionFor = void 0, e1.allGeneratedPositionsFor = void 0, e1.eachMapping = void 0, e1.sourceContentFor = void 0, e1.presortedDecodedMap = void 0, e1.decodedMap = void 0, e1.encodedMap = void 0;
                    class O {
                        constructor(e1, t){
                            const n = "string" == typeof e1;
                            if (!n && e1._decodedMemo) return e1;
                            const r = n ? JSON.parse(e1) : e1, { version: i, file: a, names: o, sourceRoot: l, sources: c, sourcesContent: u } = r;
                            this.version = i, this.file = a, this.names = o, this.sourceRoot = l, this.sources = c, this.sourcesContent = u;
                            const h = s(l || "", function(e1) {
                                if (!e1) return "";
                                const t = e1.lastIndexOf("/");
                                return e1.slice(0, t + 1);
                            }(t));
                            this.resolvedSources = c.map((e1)=>s(e1 || "", h));
                            const { mappings: f } = r;
                            "string" == typeof f ? (this._encoded = f, this._decoded = void 0) : (this._encoded = void 0, this._decoded = function(e1, t) {
                                const n = p(e1, 0);
                                if (n === e1.length) return e1;
                                t || (e1 = e1.slice());
                                for(let r = n; r < e1.length; r = p(e1, r + 1))e1[r] = d(e1[r], t);
                                return e1;
                            }(f, n)), this._decodedMemo = {
                                lastKey: -1,
                                lastNeedle: -1,
                                lastIndex: -1
                            }, this._bySources = void 0, this._bySourceMemos = void 0;
                        }
                    }
                    function I(e1, t) {
                        return {
                            version: e1.version,
                            file: e1.file,
                            names: e1.names,
                            sourceRoot: e1.sourceRoot,
                            sources: e1.sources,
                            sourcesContent: e1.sourcesContent,
                            mappings: t
                        };
                    }
                    function N(e1, t, n, r) {
                        return {
                            source: e1,
                            line: t,
                            column: n,
                            name: r
                        };
                    }
                    function F(e1, t) {
                        return {
                            line: e1,
                            column: t
                        };
                    }
                    function k(e1, t, n, r, i) {
                        let s = b(e1, r, t, n);
                        return y ? s = (i === w ? m : T)(e1, r, s) : i === w && s++, -1 === s || s === e1.length ? -1 : s;
                    }
                    (()=>{
                        function n(t, n, r, i, s, u) {
                            if (--r < 0) throw new Error(v);
                            if (i < 0) throw new Error(C);
                            const { sources: p, resolvedSources: h } = t;
                            let d = p.indexOf(n);
                            if (-1 === d && (d = h.indexOf(n)), -1 === d) return u ? [] : F(null, null);
                            const f = (t._bySources || (t._bySources = function(e1, t) {
                                const n = t.map(S);
                                for(let r = 0; r < e1.length; r++){
                                    const i = e1[r];
                                    for(let e1 = 0; e1 < i.length; e1++){
                                        const s = i[e1];
                                        if (1 === s.length) continue;
                                        const u = s[o], p = s[l], h = s[c], d = n[u], f = d[p] || (d[p] = []), y = t[u], T = m(f, h, b(f, h, y, p));
                                        E(f, y.lastIndex = T + 1, [
                                            h,
                                            r,
                                            s[a]
                                        ]);
                                    }
                                }
                                return n;
                            }(e1.decodedMappings(t), t._bySourceMemos = p.map(g))))[d][r];
                            if (null == f) return u ? [] : F(null, null);
                            const P = t._bySourceMemos[d];
                            if (u) return function(e1, t, n, r, i) {
                                let s = k(e1, t, n, r, 1);
                                if (y || i !== w || s++, -1 === s || s === e1.length) return [];
                                const o = y ? r : e1[s][a];
                                y || (s = T(e1, o, s));
                                const l = m(e1, o, s), c = [];
                                for(; s <= l; s++){
                                    const t = e1[s];
                                    c.push(F(t[1] + 1, t[2]));
                                }
                                return c;
                            }(f, P, r, i, s);
                            const x = k(f, P, r, i, s);
                            if (-1 === x) return F(null, null);
                            const D = f[x];
                            return F(D[1] + 1, D[2]);
                        }
                        e1.encodedMappings = (e1)=>{
                            var n;
                            return null !== (n = e1._encoded) && void 0 !== n ? n : e1._encoded = t.encode(e1._decoded);
                        }, e1.decodedMappings = (e1)=>e1._decoded || (e1._decoded = t.decode(e1._encoded)), e1.traceSegment = (t, n, r)=>{
                            const i = e1.decodedMappings(t);
                            if (n >= i.length) return null;
                            const s = i[n], a = k(s, t._decodedMemo, n, r, 1);
                            return -1 === a ? null : s[a];
                        }, e1.originalPositionFor = (t, { line: n, column: r, bias: i })=>{
                            if (--n < 0) throw new Error(v);
                            if (r < 0) throw new Error(C);
                            const s = e1.decodedMappings(t);
                            if (n >= s.length) return N(null, null, null, null);
                            const a = s[n], p = k(a, t._decodedMemo, n, r, i || 1);
                            if (-1 === p) return N(null, null, null, null);
                            const h = a[p];
                            if (1 === h.length) return N(null, null, null, null);
                            const { names: d, resolvedSources: f } = t;
                            return N(f[h[o]], h[l] + 1, h[c], 5 === h.length ? d[h[u]] : null);
                        }, e1.allGeneratedPositionsFor = (e1, { source: t, line: r, column: i, bias: s })=>n(e1, t, r, i, s || w, !0), e1.generatedPositionFor = (e1, { source: t, line: r, column: i, bias: s })=>n(e1, t, r, i, s || 1, !1), e1.eachMapping = (t, n)=>{
                            const r = e1.decodedMappings(t), { names: i, resolvedSources: s } = t;
                            for(let e1 = 0; e1 < r.length; e1++){
                                const t = r[e1];
                                for(let r = 0; r < t.length; r++){
                                    const a = t[r], o = e1 + 1, l = a[0];
                                    let c = null, u = null, p = null, h = null;
                                    1 !== a.length && (c = s[a[1]], u = a[2] + 1, p = a[3]), 5 === a.length && (h = i[a[4]]), n({
                                        generatedLine: o,
                                        generatedColumn: l,
                                        source: c,
                                        originalLine: u,
                                        originalColumn: p,
                                        name: h
                                    });
                                }
                            }
                        }, e1.sourceContentFor = (e1, t)=>{
                            const { sources: n, resolvedSources: r, sourcesContent: i } = e1;
                            if (null == i) return null;
                            let s = n.indexOf(t);
                            return -1 === s && (s = r.indexOf(t)), -1 === s ? null : i[s];
                        }, e1.presortedDecodedMap = (e1, t)=>{
                            const n = new O(I(e1, []), t);
                            return n._decoded = e1.mappings, n;
                        }, e1.decodedMap = (t)=>I(t, e1.decodedMappings(t)), e1.encodedMap = (t)=>I(t, e1.encodedMappings(t));
                    })(), e1.AnyMap = function(t, n) {
                        const r = "string" == typeof t ? JSON.parse(t) : t;
                        if (!("sections" in r)) return new O(r, n);
                        const i = [], s = [], a = [], o = [];
                        P(r, n, i, s, a, o, 0, 0, 1 / 0, 1 / 0);
                        const l = {
                            version: 3,
                            file: r.file,
                            names: o,
                            sources: s,
                            sourcesContent: a,
                            mappings: i
                        };
                        return e1.presortedDecodedMap(l);
                    }, e1.GREATEST_LOWER_BOUND = 1, e1.LEAST_UPPER_BOUND = w, e1.TraceMap = O, Object.defineProperty(e1, "__esModule", {
                        value: !0
                    });
                }(t, n(2297), n(8435));
            },
            6434: (e1, t, n)=>{
                "use strict";
                e1 = n.nmd(e1);
                const r = n(2085), i = (e1, t)=>function() {
                        return `[${e1.apply(r, arguments) + t}m`;
                    }, s = (e1, t)=>function() {
                        const n = e1.apply(r, arguments);
                        return `[${38 + t};5;${n}m`;
                    }, a = (e1, t)=>function() {
                        const n = e1.apply(r, arguments);
                        return `[${38 + t};2;${n[0]};${n[1]};${n[2]}m`;
                    };
                Object.defineProperty(e1, "exports", {
                    enumerable: !0,
                    get: function() {
                        const e1 = new Map, t = {
                            modifier: {
                                reset: [
                                    0,
                                    0
                                ],
                                bold: [
                                    1,
                                    22
                                ],
                                dim: [
                                    2,
                                    22
                                ],
                                italic: [
                                    3,
                                    23
                                ],
                                underline: [
                                    4,
                                    24
                                ],
                                inverse: [
                                    7,
                                    27
                                ],
                                hidden: [
                                    8,
                                    28
                                ],
                                strikethrough: [
                                    9,
                                    29
                                ]
                            },
                            color: {
                                black: [
                                    30,
                                    39
                                ],
                                red: [
                                    31,
                                    39
                                ],
                                green: [
                                    32,
                                    39
                                ],
                                yellow: [
                                    33,
                                    39
                                ],
                                blue: [
                                    34,
                                    39
                                ],
                                magenta: [
                                    35,
                                    39
                                ],
                                cyan: [
                                    36,
                                    39
                                ],
                                white: [
                                    37,
                                    39
                                ],
                                gray: [
                                    90,
                                    39
                                ],
                                redBright: [
                                    91,
                                    39
                                ],
                                greenBright: [
                                    92,
                                    39
                                ],
                                yellowBright: [
                                    93,
                                    39
                                ],
                                blueBright: [
                                    94,
                                    39
                                ],
                                magentaBright: [
                                    95,
                                    39
                                ],
                                cyanBright: [
                                    96,
                                    39
                                ],
                                whiteBright: [
                                    97,
                                    39
                                ]
                            },
                            bgColor: {
                                bgBlack: [
                                    40,
                                    49
                                ],
                                bgRed: [
                                    41,
                                    49
                                ],
                                bgGreen: [
                                    42,
                                    49
                                ],
                                bgYellow: [
                                    43,
                                    49
                                ],
                                bgBlue: [
                                    44,
                                    49
                                ],
                                bgMagenta: [
                                    45,
                                    49
                                ],
                                bgCyan: [
                                    46,
                                    49
                                ],
                                bgWhite: [
                                    47,
                                    49
                                ],
                                bgBlackBright: [
                                    100,
                                    49
                                ],
                                bgRedBright: [
                                    101,
                                    49
                                ],
                                bgGreenBright: [
                                    102,
                                    49
                                ],
                                bgYellowBright: [
                                    103,
                                    49
                                ],
                                bgBlueBright: [
                                    104,
                                    49
                                ],
                                bgMagentaBright: [
                                    105,
                                    49
                                ],
                                bgCyanBright: [
                                    106,
                                    49
                                ],
                                bgWhiteBright: [
                                    107,
                                    49
                                ]
                            }
                        };
                        t.color.grey = t.color.gray;
                        for (const n of Object.keys(t)){
                            const r = t[n];
                            for (const n of Object.keys(r)){
                                const i = r[n];
                                t[n] = {
                                    open: `[${i[0]}m`,
                                    close: `[${i[1]}m`
                                }, r[n] = t[n], e1.set(i[0], i[1]);
                            }
                            Object.defineProperty(t, n, {
                                value: r,
                                enumerable: !1
                            }), Object.defineProperty(t, "codes", {
                                value: e1,
                                enumerable: !1
                            });
                        }
                        const n = (e1)=>e1, o = (e1, t, n)=>[
                                e1,
                                t,
                                n
                            ];
                        t.color.close = "[39m", t.bgColor.close = "[49m", t.color.ansi = {
                            ansi: i(n, 0)
                        }, t.color.ansi256 = {
                            ansi256: s(n, 0)
                        }, t.color.ansi16m = {
                            rgb: a(o, 0)
                        }, t.bgColor.ansi = {
                            ansi: i(n, 10)
                        }, t.bgColor.ansi256 = {
                            ansi256: s(n, 10)
                        }, t.bgColor.ansi16m = {
                            rgb: a(o, 10)
                        };
                        for (let e1 of Object.keys(r)){
                            if ("object" != typeof r[e1]) continue;
                            const n = r[e1];
                            "ansi16" === e1 && (e1 = "ansi"), "ansi16" in n && (t.color.ansi[e1] = i(n.ansi16, 0), t.bgColor.ansi[e1] = i(n.ansi16, 10)), "ansi256" in n && (t.color.ansi256[e1] = s(n.ansi256, 0), t.bgColor.ansi256[e1] = s(n.ansi256, 10)), "rgb" in n && (t.color.ansi16m[e1] = a(n.rgb, 0), t.bgColor.ansi16m[e1] = a(n.rgb, 10));
                        }
                        return t;
                    }
                });
            },
            9742: (e1, t)=>{
                "use strict";
                t.byteLength = function(e1) {
                    var t = o(e1), n = t[0], r = t[1];
                    return 3 * (n + r) / 4 - r;
                }, t.toByteArray = function(e1) {
                    var t, n, s = o(e1), a = s[0], l = s[1], c = new i(function(e1, t, n) {
                        return 3 * (t + n) / 4 - n;
                    }(0, a, l)), u = 0, p = l > 0 ? a - 4 : a;
                    for(n = 0; n < p; n += 4)t = r[e1.charCodeAt(n)] << 18 | r[e1.charCodeAt(n + 1)] << 12 | r[e1.charCodeAt(n + 2)] << 6 | r[e1.charCodeAt(n + 3)], c[u++] = t >> 16 & 255, c[u++] = t >> 8 & 255, c[u++] = 255 & t;
                    return 2 === l && (t = r[e1.charCodeAt(n)] << 2 | r[e1.charCodeAt(n + 1)] >> 4, c[u++] = 255 & t), 1 === l && (t = r[e1.charCodeAt(n)] << 10 | r[e1.charCodeAt(n + 1)] << 4 | r[e1.charCodeAt(n + 2)] >> 2, c[u++] = t >> 8 & 255, c[u++] = 255 & t), c;
                }, t.fromByteArray = function(e1) {
                    for(var t, r = e1.length, i = r % 3, s = [], a = 16383, o = 0, c = r - i; o < c; o += a)s.push(l(e1, o, o + a > c ? c : o + a));
                    return 1 === i ? (t = e1[r - 1], s.push(n[t >> 2] + n[t << 4 & 63] + "==")) : 2 === i && (t = (e1[r - 2] << 8) + e1[r - 1], s.push(n[t >> 10] + n[t >> 4 & 63] + n[t << 2 & 63] + "=")), s.join("");
                };
                for(var n = [], r = [], i = "undefined" != typeof Uint8Array ? Uint8Array : Array, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0; a < 64; ++a)n[a] = s[a], r[s.charCodeAt(a)] = a;
                function o(e1) {
                    var t = e1.length;
                    if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
                    var n = e1.indexOf("=");
                    return -1 === n && (n = t), [
                        n,
                        n === t ? 0 : 4 - n % 4
                    ];
                }
                function l(e1, t, r) {
                    for(var i, s, a = [], o = t; o < r; o += 3)i = (e1[o] << 16 & 16711680) + (e1[o + 1] << 8 & 65280) + (255 & e1[o + 2]), a.push(n[(s = i) >> 18 & 63] + n[s >> 12 & 63] + n[s >> 6 & 63] + n[63 & s]);
                    return a.join("");
                }
                r["-".charCodeAt(0)] = 62, r["_".charCodeAt(0)] = 63;
            },
            8764: (e1, t, n)=>{
                "use strict";
                const r = n(9742), i = n(645), s = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
                t.lW = l, t.h2 = 50;
                const a = 2147483647;
                function o(e1) {
                    if (e1 > a) throw new RangeError('The value "' + e1 + '" is invalid for option "size"');
                    const t = new Uint8Array(e1);
                    return Object.setPrototypeOf(t, l.prototype), t;
                }
                function l(e1, t, n) {
                    if ("number" == typeof e1) {
                        if ("string" == typeof t) throw new TypeError('The "string" argument must be of type string. Received type number');
                        return p(e1);
                    }
                    return c(e1, t, n);
                }
                function c(e1, t, n) {
                    if ("string" == typeof e1) return function(e1, t) {
                        if ("string" == typeof t && "" !== t || (t = "utf8"), !l.isEncoding(t)) throw new TypeError("Unknown encoding: " + t);
                        const n = 0 | y(e1, t);
                        let r = o(n);
                        const i = r.write(e1, t);
                        return i !== n && (r = r.slice(0, i)), r;
                    }(e1, t);
                    if (ArrayBuffer.isView(e1)) return function(e1) {
                        if ($(e1, Uint8Array)) {
                            const t = new Uint8Array(e1);
                            return d(t.buffer, t.byteOffset, t.byteLength);
                        }
                        return h(e1);
                    }(e1);
                    if (null == e1) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e1);
                    if ($(e1, ArrayBuffer) || e1 && $(e1.buffer, ArrayBuffer)) return d(e1, t, n);
                    if ("undefined" != typeof SharedArrayBuffer && ($(e1, SharedArrayBuffer) || e1 && $(e1.buffer, SharedArrayBuffer))) return d(e1, t, n);
                    if ("number" == typeof e1) throw new TypeError('The "value" argument must not be of type number. Received type number');
                    const r = e1.valueOf && e1.valueOf();
                    if (null != r && r !== e1) return l.from(r, t, n);
                    const i = function(e1) {
                        if (l.isBuffer(e1)) {
                            const t = 0 | f(e1.length), n = o(t);
                            return 0 === n.length || e1.copy(n, 0, 0, t), n;
                        }
                        return void 0 !== e1.length ? "number" != typeof e1.length || G(e1.length) ? o(0) : h(e1) : "Buffer" === e1.type && Array.isArray(e1.data) ? h(e1.data) : void 0;
                    }(e1);
                    if (i) return i;
                    if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e1[Symbol.toPrimitive]) return l.from(e1[Symbol.toPrimitive]("string"), t, n);
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e1);
                }
                function u(e1) {
                    if ("number" != typeof e1) throw new TypeError('"size" argument must be of type number');
                    if (e1 < 0) throw new RangeError('The value "' + e1 + '" is invalid for option "size"');
                }
                function p(e1) {
                    return u(e1), o(e1 < 0 ? 0 : 0 | f(e1));
                }
                function h(e1) {
                    const t = e1.length < 0 ? 0 : 0 | f(e1.length), n = o(t);
                    for(let r = 0; r < t; r += 1)n[r] = 255 & e1[r];
                    return n;
                }
                function d(e1, t, n) {
                    if (t < 0 || e1.byteLength < t) throw new RangeError('"offset" is outside of buffer bounds');
                    if (e1.byteLength < t + (n || 0)) throw new RangeError('"length" is outside of buffer bounds');
                    let r;
                    return r = void 0 === t && void 0 === n ? new Uint8Array(e1) : void 0 === n ? new Uint8Array(e1, t) : new Uint8Array(e1, t, n), Object.setPrototypeOf(r, l.prototype), r;
                }
                function f(e1) {
                    if (e1 >= a) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + a.toString(16) + " bytes");
                    return 0 | e1;
                }
                function y(e1, t) {
                    if (l.isBuffer(e1)) return e1.length;
                    if (ArrayBuffer.isView(e1) || $(e1, ArrayBuffer)) return e1.byteLength;
                    if ("string" != typeof e1) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e1);
                    const n = e1.length, r = arguments.length > 2 && !0 === arguments[2];
                    if (!r && 0 === n) return 0;
                    let i = !1;
                    for(;;)switch(t){
                        case "ascii":
                        case "latin1":
                        case "binary":
                            return n;
                        case "utf8":
                        case "utf-8":
                            return q(e1).length;
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return 2 * n;
                        case "hex":
                            return n >>> 1;
                        case "base64":
                            return H(e1).length;
                        default:
                            if (i) return r ? -1 : q(e1).length;
                            t = ("" + t).toLowerCase(), i = !0;
                    }
                }
                function m(e1, t, n) {
                    let r = !1;
                    if ((void 0 === t || t < 0) && (t = 0), t > this.length) return "";
                    if ((void 0 === n || n > this.length) && (n = this.length), n <= 0) return "";
                    if ((n >>>= 0) <= (t >>>= 0)) return "";
                    for(e1 || (e1 = "utf8");;)switch(e1){
                        case "hex":
                            return I(this, t, n);
                        case "utf8":
                        case "utf-8":
                            return v(this, t, n);
                        case "ascii":
                            return w(this, t, n);
                        case "latin1":
                        case "binary":
                            return O(this, t, n);
                        case "base64":
                            return A(this, t, n);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return N(this, t, n);
                        default:
                            if (r) throw new TypeError("Unknown encoding: " + e1);
                            e1 = (e1 + "").toLowerCase(), r = !0;
                    }
                }
                function T(e1, t, n) {
                    const r = e1[t];
                    e1[t] = e1[n], e1[n] = r;
                }
                function g(e1, t, n, r, i) {
                    if (0 === e1.length) return -1;
                    if ("string" == typeof n ? (r = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), G(n = +n) && (n = i ? 0 : e1.length - 1), n < 0 && (n = e1.length + n), n >= e1.length) {
                        if (i) return -1;
                        n = e1.length - 1;
                    } else if (n < 0) {
                        if (!i) return -1;
                        n = 0;
                    }
                    if ("string" == typeof t && (t = l.from(t, r)), l.isBuffer(t)) return 0 === t.length ? -1 : b(e1, t, n, r, i);
                    if ("number" == typeof t) return t &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(e1, t, n) : Uint8Array.prototype.lastIndexOf.call(e1, t, n) : b(e1, [
                        t
                    ], n, r, i);
                    throw new TypeError("val must be string, number or Buffer");
                }
                function b(e1, t, n, r, i) {
                    let s, a = 1, o = e1.length, l = t.length;
                    if (void 0 !== r && ("ucs2" === (r = String(r).toLowerCase()) || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) {
                        if (e1.length < 2 || t.length < 2) return -1;
                        a = 2, o /= 2, l /= 2, n /= 2;
                    }
                    function c(e1, t) {
                        return 1 === a ? e1[t] : e1.readUInt16BE(t * a);
                    }
                    if (i) {
                        let r = -1;
                        for(s = n; s < o; s++)if (c(e1, s) === c(t, -1 === r ? 0 : s - r)) {
                            if (-1 === r && (r = s), s - r + 1 === l) return r * a;
                        } else -1 !== r && (s -= s - r), r = -1;
                    } else for(n + l > o && (n = o - l), s = n; s >= 0; s--){
                        let n = !0;
                        for(let r = 0; r < l; r++)if (c(e1, s + r) !== c(t, r)) {
                            n = !1;
                            break;
                        }
                        if (n) return s;
                    }
                    return -1;
                }
                function E(e1, t, n, r) {
                    n = Number(n) || 0;
                    const i = e1.length - n;
                    r ? (r = Number(r)) > i && (r = i) : r = i;
                    const s = t.length;
                    let a;
                    for(r > s / 2 && (r = s / 2), a = 0; a < r; ++a){
                        const r = parseInt(t.substr(2 * a, 2), 16);
                        if (G(r)) return a;
                        e1[n + a] = r;
                    }
                    return a;
                }
                function S(e1, t, n, r) {
                    return J(q(t, e1.length - n), e1, n, r);
                }
                function P(e1, t, n, r) {
                    return J(function(e1) {
                        const t = [];
                        for(let n = 0; n < e1.length; ++n)t.push(255 & e1.charCodeAt(n));
                        return t;
                    }(t), e1, n, r);
                }
                function x(e1, t, n, r) {
                    return J(H(t), e1, n, r);
                }
                function D(e1, t, n, r) {
                    return J(function(e1, t) {
                        let n, r, i;
                        const s = [];
                        for(let a = 0; a < e1.length && !((t -= 2) < 0); ++a)n = e1.charCodeAt(a), r = n >> 8, i = n % 256, s.push(i), s.push(r);
                        return s;
                    }(t, e1.length - n), e1, n, r);
                }
                function A(e1, t, n) {
                    return 0 === t && n === e1.length ? r.fromByteArray(e1) : r.fromByteArray(e1.slice(t, n));
                }
                function v(e1, t, n) {
                    n = Math.min(e1.length, n);
                    const r = [];
                    let i = t;
                    for(; i < n;){
                        const t = e1[i];
                        let s = null, a = t > 239 ? 4 : t > 223 ? 3 : t > 191 ? 2 : 1;
                        if (i + a <= n) {
                            let n, r, o, l;
                            switch(a){
                                case 1:
                                    t < 128 && (s = t);
                                    break;
                                case 2:
                                    n = e1[i + 1], 128 == (192 & n) && (l = (31 & t) << 6 | 63 & n, l > 127 && (s = l));
                                    break;
                                case 3:
                                    n = e1[i + 1], r = e1[i + 2], 128 == (192 & n) && 128 == (192 & r) && (l = (15 & t) << 12 | (63 & n) << 6 | 63 & r, l > 2047 && (l < 55296 || l > 57343) && (s = l));
                                    break;
                                case 4:
                                    n = e1[i + 1], r = e1[i + 2], o = e1[i + 3], 128 == (192 & n) && 128 == (192 & r) && 128 == (192 & o) && (l = (15 & t) << 18 | (63 & n) << 12 | (63 & r) << 6 | 63 & o, l > 65535 && l < 1114112 && (s = l));
                            }
                        }
                        null === s ? (s = 65533, a = 1) : s > 65535 && (s -= 65536, r.push(s >>> 10 & 1023 | 55296), s = 56320 | 1023 & s), r.push(s), i += a;
                    }
                    return function(e1) {
                        const t = e1.length;
                        if (t <= C) return String.fromCharCode.apply(String, e1);
                        let n = "", r = 0;
                        for(; r < t;)n += String.fromCharCode.apply(String, e1.slice(r, r += C));
                        return n;
                    }(r);
                }
                l.TYPED_ARRAY_SUPPORT = function() {
                    try {
                        const e1 = new Uint8Array(1), t = {
                            foo: function() {
                                return 42;
                            }
                        };
                        return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e1, t), 42 === e1.foo();
                    } catch (e1) {
                        return !1;
                    }
                }(), l.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(l.prototype, "parent", {
                    enumerable: !0,
                    get: function() {
                        if (l.isBuffer(this)) return this.buffer;
                    }
                }), Object.defineProperty(l.prototype, "offset", {
                    enumerable: !0,
                    get: function() {
                        if (l.isBuffer(this)) return this.byteOffset;
                    }
                }), l.poolSize = 8192, l.from = function(e1, t, n) {
                    return c(e1, t, n);
                }, Object.setPrototypeOf(l.prototype, Uint8Array.prototype), Object.setPrototypeOf(l, Uint8Array), l.alloc = function(e1, t, n) {
                    return function(e1, t, n) {
                        return u(e1), e1 <= 0 ? o(e1) : void 0 !== t ? "string" == typeof n ? o(e1).fill(t, n) : o(e1).fill(t) : o(e1);
                    }(e1, t, n);
                }, l.allocUnsafe = function(e1) {
                    return p(e1);
                }, l.allocUnsafeSlow = function(e1) {
                    return p(e1);
                }, l.isBuffer = function(e1) {
                    return null != e1 && !0 === e1._isBuffer && e1 !== l.prototype;
                }, l.compare = function(e1, t) {
                    if ($(e1, Uint8Array) && (e1 = l.from(e1, e1.offset, e1.byteLength)), $(t, Uint8Array) && (t = l.from(t, t.offset, t.byteLength)), !l.isBuffer(e1) || !l.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                    if (e1 === t) return 0;
                    let n = e1.length, r = t.length;
                    for(let i = 0, s = Math.min(n, r); i < s; ++i)if (e1[i] !== t[i]) {
                        n = e1[i], r = t[i];
                        break;
                    }
                    return n < r ? -1 : r < n ? 1 : 0;
                }, l.isEncoding = function(e1) {
                    switch(String(e1).toLowerCase()){
                        case "hex":
                        case "utf8":
                        case "utf-8":
                        case "ascii":
                        case "latin1":
                        case "binary":
                        case "base64":
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return !0;
                        default:
                            return !1;
                    }
                }, l.concat = function(e1, t) {
                    if (!Array.isArray(e1)) throw new TypeError('"list" argument must be an Array of Buffers');
                    if (0 === e1.length) return l.alloc(0);
                    let n;
                    if (void 0 === t) for(t = 0, n = 0; n < e1.length; ++n)t += e1[n].length;
                    const r = l.allocUnsafe(t);
                    let i = 0;
                    for(n = 0; n < e1.length; ++n){
                        let t = e1[n];
                        if ($(t, Uint8Array)) i + t.length > r.length ? (l.isBuffer(t) || (t = l.from(t)), t.copy(r, i)) : Uint8Array.prototype.set.call(r, t, i);
                        else {
                            if (!l.isBuffer(t)) throw new TypeError('"list" argument must be an Array of Buffers');
                            t.copy(r, i);
                        }
                        i += t.length;
                    }
                    return r;
                }, l.byteLength = y, l.prototype._isBuffer = !0, l.prototype.swap16 = function() {
                    const e1 = this.length;
                    if (e1 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
                    for(let t = 0; t < e1; t += 2)T(this, t, t + 1);
                    return this;
                }, l.prototype.swap32 = function() {
                    const e1 = this.length;
                    if (e1 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
                    for(let t = 0; t < e1; t += 4)T(this, t, t + 3), T(this, t + 1, t + 2);
                    return this;
                }, l.prototype.swap64 = function() {
                    const e1 = this.length;
                    if (e1 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
                    for(let t = 0; t < e1; t += 8)T(this, t, t + 7), T(this, t + 1, t + 6), T(this, t + 2, t + 5), T(this, t + 3, t + 4);
                    return this;
                }, l.prototype.toString = function() {
                    const e1 = this.length;
                    return 0 === e1 ? "" : 0 === arguments.length ? v(this, 0, e1) : m.apply(this, arguments);
                }, l.prototype.toLocaleString = l.prototype.toString, l.prototype.equals = function(e1) {
                    if (!l.isBuffer(e1)) throw new TypeError("Argument must be a Buffer");
                    return this === e1 || 0 === l.compare(this, e1);
                }, l.prototype.inspect = function() {
                    let e1 = "";
                    const n = t.h2;
                    return e1 = this.toString("hex", 0, n).replace(/(.{2})/g, "$1 ").trim(), this.length > n && (e1 += " ... "), "<Buffer " + e1 + ">";
                }, s && (l.prototype[s] = l.prototype.inspect), l.prototype.compare = function(e1, t, n, r, i) {
                    if ($(e1, Uint8Array) && (e1 = l.from(e1, e1.offset, e1.byteLength)), !l.isBuffer(e1)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e1);
                    if (void 0 === t && (t = 0), void 0 === n && (n = e1 ? e1.length : 0), void 0 === r && (r = 0), void 0 === i && (i = this.length), t < 0 || n > e1.length || r < 0 || i > this.length) throw new RangeError("out of range index");
                    if (r >= i && t >= n) return 0;
                    if (r >= i) return -1;
                    if (t >= n) return 1;
                    if (this === e1) return 0;
                    let s = (i >>>= 0) - (r >>>= 0), a = (n >>>= 0) - (t >>>= 0);
                    const o = Math.min(s, a), c = this.slice(r, i), u = e1.slice(t, n);
                    for(let e1 = 0; e1 < o; ++e1)if (c[e1] !== u[e1]) {
                        s = c[e1], a = u[e1];
                        break;
                    }
                    return s < a ? -1 : a < s ? 1 : 0;
                }, l.prototype.includes = function(e1, t, n) {
                    return -1 !== this.indexOf(e1, t, n);
                }, l.prototype.indexOf = function(e1, t, n) {
                    return g(this, e1, t, n, !0);
                }, l.prototype.lastIndexOf = function(e1, t, n) {
                    return g(this, e1, t, n, !1);
                }, l.prototype.write = function(e1, t, n, r) {
                    if (void 0 === t) r = "utf8", n = this.length, t = 0;
                    else if (void 0 === n && "string" == typeof t) r = t, n = this.length, t = 0;
                    else {
                        if (!isFinite(t)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                        t >>>= 0, isFinite(n) ? (n >>>= 0, void 0 === r && (r = "utf8")) : (r = n, n = void 0);
                    }
                    const i = this.length - t;
                    if ((void 0 === n || n > i) && (n = i), e1.length > 0 && (n < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
                    r || (r = "utf8");
                    let s = !1;
                    for(;;)switch(r){
                        case "hex":
                            return E(this, e1, t, n);
                        case "utf8":
                        case "utf-8":
                            return S(this, e1, t, n);
                        case "ascii":
                        case "latin1":
                        case "binary":
                            return P(this, e1, t, n);
                        case "base64":
                            return x(this, e1, t, n);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return D(this, e1, t, n);
                        default:
                            if (s) throw new TypeError("Unknown encoding: " + r);
                            r = ("" + r).toLowerCase(), s = !0;
                    }
                }, l.prototype.toJSON = function() {
                    return {
                        type: "Buffer",
                        data: Array.prototype.slice.call(this._arr || this, 0)
                    };
                };
                const C = 4096;
                function w(e1, t, n) {
                    let r = "";
                    n = Math.min(e1.length, n);
                    for(let i = t; i < n; ++i)r += String.fromCharCode(127 & e1[i]);
                    return r;
                }
                function O(e1, t, n) {
                    let r = "";
                    n = Math.min(e1.length, n);
                    for(let i = t; i < n; ++i)r += String.fromCharCode(e1[i]);
                    return r;
                }
                function I(e1, t, n) {
                    const r = e1.length;
                    (!t || t < 0) && (t = 0), (!n || n < 0 || n > r) && (n = r);
                    let i = "";
                    for(let r = t; r < n; ++r)i += z[e1[r]];
                    return i;
                }
                function N(e1, t, n) {
                    const r = e1.slice(t, n);
                    let i = "";
                    for(let e1 = 0; e1 < r.length - 1; e1 += 2)i += String.fromCharCode(r[e1] + 256 * r[e1 + 1]);
                    return i;
                }
                function F(e1, t, n) {
                    if (e1 % 1 != 0 || e1 < 0) throw new RangeError("offset is not uint");
                    if (e1 + t > n) throw new RangeError("Trying to access beyond buffer length");
                }
                function k(e1, t, n, r, i, s) {
                    if (!l.isBuffer(e1)) throw new TypeError('"buffer" argument must be a Buffer instance');
                    if (t > i || t < s) throw new RangeError('"value" argument is out of bounds');
                    if (n + r > e1.length) throw new RangeError("Index out of range");
                }
                function L(e1, t, n, r, i) {
                    K(t, r, i, e1, n, 7);
                    let s = Number(t & BigInt(4294967295));
                    e1[n++] = s, s >>= 8, e1[n++] = s, s >>= 8, e1[n++] = s, s >>= 8, e1[n++] = s;
                    let a = Number(t >> BigInt(32) & BigInt(4294967295));
                    return e1[n++] = a, a >>= 8, e1[n++] = a, a >>= 8, e1[n++] = a, a >>= 8, e1[n++] = a, n;
                }
                function _(e1, t, n, r, i) {
                    K(t, r, i, e1, n, 7);
                    let s = Number(t & BigInt(4294967295));
                    e1[n + 7] = s, s >>= 8, e1[n + 6] = s, s >>= 8, e1[n + 5] = s, s >>= 8, e1[n + 4] = s;
                    let a = Number(t >> BigInt(32) & BigInt(4294967295));
                    return e1[n + 3] = a, a >>= 8, e1[n + 2] = a, a >>= 8, e1[n + 1] = a, a >>= 8, e1[n] = a, n + 8;
                }
                function M(e1, t, n, r, i, s) {
                    if (n + r > e1.length) throw new RangeError("Index out of range");
                    if (n < 0) throw new RangeError("Index out of range");
                }
                function B(e1, t, n, r, s) {
                    return t = +t, n >>>= 0, s || M(e1, 0, n, 4), i.write(e1, t, n, r, 23, 4), n + 4;
                }
                function j(e1, t, n, r, s) {
                    return t = +t, n >>>= 0, s || M(e1, 0, n, 8), i.write(e1, t, n, r, 52, 8), n + 8;
                }
                l.prototype.slice = function(e1, t) {
                    const n = this.length;
                    (e1 = ~~e1) < 0 ? (e1 += n) < 0 && (e1 = 0) : e1 > n && (e1 = n), (t = void 0 === t ? n : ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), t < e1 && (t = e1);
                    const r = this.subarray(e1, t);
                    return Object.setPrototypeOf(r, l.prototype), r;
                }, l.prototype.readUintLE = l.prototype.readUIntLE = function(e1, t, n) {
                    e1 >>>= 0, t >>>= 0, n || F(e1, t, this.length);
                    let r = this[e1], i = 1, s = 0;
                    for(; ++s < t && (i *= 256);)r += this[e1 + s] * i;
                    return r;
                }, l.prototype.readUintBE = l.prototype.readUIntBE = function(e1, t, n) {
                    e1 >>>= 0, t >>>= 0, n || F(e1, t, this.length);
                    let r = this[e1 + --t], i = 1;
                    for(; t > 0 && (i *= 256);)r += this[e1 + --t] * i;
                    return r;
                }, l.prototype.readUint8 = l.prototype.readUInt8 = function(e1, t) {
                    return e1 >>>= 0, t || F(e1, 1, this.length), this[e1];
                }, l.prototype.readUint16LE = l.prototype.readUInt16LE = function(e1, t) {
                    return e1 >>>= 0, t || F(e1, 2, this.length), this[e1] | this[e1 + 1] << 8;
                }, l.prototype.readUint16BE = l.prototype.readUInt16BE = function(e1, t) {
                    return e1 >>>= 0, t || F(e1, 2, this.length), this[e1] << 8 | this[e1 + 1];
                }, l.prototype.readUint32LE = l.prototype.readUInt32LE = function(e1, t) {
                    return e1 >>>= 0, t || F(e1, 4, this.length), (this[e1] | this[e1 + 1] << 8 | this[e1 + 2] << 16) + 16777216 * this[e1 + 3];
                }, l.prototype.readUint32BE = l.prototype.readUInt32BE = function(e1, t) {
                    return e1 >>>= 0, t || F(e1, 4, this.length), 16777216 * this[e1] + (this[e1 + 1] << 16 | this[e1 + 2] << 8 | this[e1 + 3]);
                }, l.prototype.readBigUInt64LE = Q(function(e1) {
                    W(e1 >>>= 0, "offset");
                    const t = this[e1], n = this[e1 + 7];
                    void 0 !== t && void 0 !== n || X(e1, this.length - 8);
                    const r = t + 256 * this[++e1] + 65536 * this[++e1] + this[++e1] * 2 ** 24, i = this[++e1] + 256 * this[++e1] + 65536 * this[++e1] + n * 2 ** 24;
                    return BigInt(r) + (BigInt(i) << BigInt(32));
                }), l.prototype.readBigUInt64BE = Q(function(e1) {
                    W(e1 >>>= 0, "offset");
                    const t = this[e1], n = this[e1 + 7];
                    void 0 !== t && void 0 !== n || X(e1, this.length - 8);
                    const r = t * 2 ** 24 + 65536 * this[++e1] + 256 * this[++e1] + this[++e1], i = this[++e1] * 2 ** 24 + 65536 * this[++e1] + 256 * this[++e1] + n;
                    return (BigInt(r) << BigInt(32)) + BigInt(i);
                }), l.prototype.readIntLE = function(e1, t, n) {
                    e1 >>>= 0, t >>>= 0, n || F(e1, t, this.length);
                    let r = this[e1], i = 1, s = 0;
                    for(; ++s < t && (i *= 256);)r += this[e1 + s] * i;
                    return i *= 128, r >= i && (r -= Math.pow(2, 8 * t)), r;
                }, l.prototype.readIntBE = function(e1, t, n) {
                    e1 >>>= 0, t >>>= 0, n || F(e1, t, this.length);
                    let r = t, i = 1, s = this[e1 + --r];
                    for(; r > 0 && (i *= 256);)s += this[e1 + --r] * i;
                    return i *= 128, s >= i && (s -= Math.pow(2, 8 * t)), s;
                }, l.prototype.readInt8 = function(e1, t) {
                    return e1 >>>= 0, t || F(e1, 1, this.length), 128 & this[e1] ? -1 * (255 - this[e1] + 1) : this[e1];
                }, l.prototype.readInt16LE = function(e1, t) {
                    e1 >>>= 0, t || F(e1, 2, this.length);
                    const n = this[e1] | this[e1 + 1] << 8;
                    return 32768 & n ? 4294901760 | n : n;
                }, l.prototype.readInt16BE = function(e1, t) {
                    e1 >>>= 0, t || F(e1, 2, this.length);
                    const n = this[e1 + 1] | this[e1] << 8;
                    return 32768 & n ? 4294901760 | n : n;
                }, l.prototype.readInt32LE = function(e1, t) {
                    return e1 >>>= 0, t || F(e1, 4, this.length), this[e1] | this[e1 + 1] << 8 | this[e1 + 2] << 16 | this[e1 + 3] << 24;
                }, l.prototype.readInt32BE = function(e1, t) {
                    return e1 >>>= 0, t || F(e1, 4, this.length), this[e1] << 24 | this[e1 + 1] << 16 | this[e1 + 2] << 8 | this[e1 + 3];
                }, l.prototype.readBigInt64LE = Q(function(e1) {
                    W(e1 >>>= 0, "offset");
                    const t = this[e1], n = this[e1 + 7];
                    void 0 !== t && void 0 !== n || X(e1, this.length - 8);
                    const r = this[e1 + 4] + 256 * this[e1 + 5] + 65536 * this[e1 + 6] + (n << 24);
                    return (BigInt(r) << BigInt(32)) + BigInt(t + 256 * this[++e1] + 65536 * this[++e1] + this[++e1] * 2 ** 24);
                }), l.prototype.readBigInt64BE = Q(function(e1) {
                    W(e1 >>>= 0, "offset");
                    const t = this[e1], n = this[e1 + 7];
                    void 0 !== t && void 0 !== n || X(e1, this.length - 8);
                    const r = (t << 24) + 65536 * this[++e1] + 256 * this[++e1] + this[++e1];
                    return (BigInt(r) << BigInt(32)) + BigInt(this[++e1] * 2 ** 24 + 65536 * this[++e1] + 256 * this[++e1] + n);
                }), l.prototype.readFloatLE = function(e1, t) {
                    return e1 >>>= 0, t || F(e1, 4, this.length), i.read(this, e1, !0, 23, 4);
                }, l.prototype.readFloatBE = function(e1, t) {
                    return e1 >>>= 0, t || F(e1, 4, this.length), i.read(this, e1, !1, 23, 4);
                }, l.prototype.readDoubleLE = function(e1, t) {
                    return e1 >>>= 0, t || F(e1, 8, this.length), i.read(this, e1, !0, 52, 8);
                }, l.prototype.readDoubleBE = function(e1, t) {
                    return e1 >>>= 0, t || F(e1, 8, this.length), i.read(this, e1, !1, 52, 8);
                }, l.prototype.writeUintLE = l.prototype.writeUIntLE = function(e1, t, n, r) {
                    e1 = +e1, t >>>= 0, n >>>= 0, r || k(this, e1, t, n, Math.pow(2, 8 * n) - 1, 0);
                    let i = 1, s = 0;
                    for(this[t] = 255 & e1; ++s < n && (i *= 256);)this[t + s] = e1 / i & 255;
                    return t + n;
                }, l.prototype.writeUintBE = l.prototype.writeUIntBE = function(e1, t, n, r) {
                    e1 = +e1, t >>>= 0, n >>>= 0, r || k(this, e1, t, n, Math.pow(2, 8 * n) - 1, 0);
                    let i = n - 1, s = 1;
                    for(this[t + i] = 255 & e1; --i >= 0 && (s *= 256);)this[t + i] = e1 / s & 255;
                    return t + n;
                }, l.prototype.writeUint8 = l.prototype.writeUInt8 = function(e1, t, n) {
                    return e1 = +e1, t >>>= 0, n || k(this, e1, t, 1, 255, 0), this[t] = 255 & e1, t + 1;
                }, l.prototype.writeUint16LE = l.prototype.writeUInt16LE = function(e1, t, n) {
                    return e1 = +e1, t >>>= 0, n || k(this, e1, t, 2, 65535, 0), this[t] = 255 & e1, this[t + 1] = e1 >>> 8, t + 2;
                }, l.prototype.writeUint16BE = l.prototype.writeUInt16BE = function(e1, t, n) {
                    return e1 = +e1, t >>>= 0, n || k(this, e1, t, 2, 65535, 0), this[t] = e1 >>> 8, this[t + 1] = 255 & e1, t + 2;
                }, l.prototype.writeUint32LE = l.prototype.writeUInt32LE = function(e1, t, n) {
                    return e1 = +e1, t >>>= 0, n || k(this, e1, t, 4, 4294967295, 0), this[t + 3] = e1 >>> 24, this[t + 2] = e1 >>> 16, this[t + 1] = e1 >>> 8, this[t] = 255 & e1, t + 4;
                }, l.prototype.writeUint32BE = l.prototype.writeUInt32BE = function(e1, t, n) {
                    return e1 = +e1, t >>>= 0, n || k(this, e1, t, 4, 4294967295, 0), this[t] = e1 >>> 24, this[t + 1] = e1 >>> 16, this[t + 2] = e1 >>> 8, this[t + 3] = 255 & e1, t + 4;
                }, l.prototype.writeBigUInt64LE = Q(function(e1, t = 0) {
                    return L(this, e1, t, BigInt(0), BigInt("0xffffffffffffffff"));
                }), l.prototype.writeBigUInt64BE = Q(function(e1, t = 0) {
                    return _(this, e1, t, BigInt(0), BigInt("0xffffffffffffffff"));
                }), l.prototype.writeIntLE = function(e1, t, n, r) {
                    if (e1 = +e1, t >>>= 0, !r) {
                        const r = Math.pow(2, 8 * n - 1);
                        k(this, e1, t, n, r - 1, -r);
                    }
                    let i = 0, s = 1, a = 0;
                    for(this[t] = 255 & e1; ++i < n && (s *= 256);)e1 < 0 && 0 === a && 0 !== this[t + i - 1] && (a = 1), this[t + i] = (e1 / s >> 0) - a & 255;
                    return t + n;
                }, l.prototype.writeIntBE = function(e1, t, n, r) {
                    if (e1 = +e1, t >>>= 0, !r) {
                        const r = Math.pow(2, 8 * n - 1);
                        k(this, e1, t, n, r - 1, -r);
                    }
                    let i = n - 1, s = 1, a = 0;
                    for(this[t + i] = 255 & e1; --i >= 0 && (s *= 256);)e1 < 0 && 0 === a && 0 !== this[t + i + 1] && (a = 1), this[t + i] = (e1 / s >> 0) - a & 255;
                    return t + n;
                }, l.prototype.writeInt8 = function(e1, t, n) {
                    return e1 = +e1, t >>>= 0, n || k(this, e1, t, 1, 127, -128), e1 < 0 && (e1 = 255 + e1 + 1), this[t] = 255 & e1, t + 1;
                }, l.prototype.writeInt16LE = function(e1, t, n) {
                    return e1 = +e1, t >>>= 0, n || k(this, e1, t, 2, 32767, -32768), this[t] = 255 & e1, this[t + 1] = e1 >>> 8, t + 2;
                }, l.prototype.writeInt16BE = function(e1, t, n) {
                    return e1 = +e1, t >>>= 0, n || k(this, e1, t, 2, 32767, -32768), this[t] = e1 >>> 8, this[t + 1] = 255 & e1, t + 2;
                }, l.prototype.writeInt32LE = function(e1, t, n) {
                    return e1 = +e1, t >>>= 0, n || k(this, e1, t, 4, 2147483647, -2147483648), this[t] = 255 & e1, this[t + 1] = e1 >>> 8, this[t + 2] = e1 >>> 16, this[t + 3] = e1 >>> 24, t + 4;
                }, l.prototype.writeInt32BE = function(e1, t, n) {
                    return e1 = +e1, t >>>= 0, n || k(this, e1, t, 4, 2147483647, -2147483648), e1 < 0 && (e1 = 4294967295 + e1 + 1), this[t] = e1 >>> 24, this[t + 1] = e1 >>> 16, this[t + 2] = e1 >>> 8, this[t + 3] = 255 & e1, t + 4;
                }, l.prototype.writeBigInt64LE = Q(function(e1, t = 0) {
                    return L(this, e1, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
                }), l.prototype.writeBigInt64BE = Q(function(e1, t = 0) {
                    return _(this, e1, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
                }), l.prototype.writeFloatLE = function(e1, t, n) {
                    return B(this, e1, t, !0, n);
                }, l.prototype.writeFloatBE = function(e1, t, n) {
                    return B(this, e1, t, !1, n);
                }, l.prototype.writeDoubleLE = function(e1, t, n) {
                    return j(this, e1, t, !0, n);
                }, l.prototype.writeDoubleBE = function(e1, t, n) {
                    return j(this, e1, t, !1, n);
                }, l.prototype.copy = function(e1, t, n, r) {
                    if (!l.isBuffer(e1)) throw new TypeError("argument should be a Buffer");
                    if (n || (n = 0), r || 0 === r || (r = this.length), t >= e1.length && (t = e1.length), t || (t = 0), r > 0 && r < n && (r = n), r === n) return 0;
                    if (0 === e1.length || 0 === this.length) return 0;
                    if (t < 0) throw new RangeError("targetStart out of bounds");
                    if (n < 0 || n >= this.length) throw new RangeError("Index out of range");
                    if (r < 0) throw new RangeError("sourceEnd out of bounds");
                    r > this.length && (r = this.length), e1.length - t < r - n && (r = e1.length - t + n);
                    const i = r - n;
                    return this === e1 && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(t, n, r) : Uint8Array.prototype.set.call(e1, this.subarray(n, r), t), i;
                }, l.prototype.fill = function(e1, t, n, r) {
                    if ("string" == typeof e1) {
                        if ("string" == typeof t ? (r = t, t = 0, n = this.length) : "string" == typeof n && (r = n, n = this.length), void 0 !== r && "string" != typeof r) throw new TypeError("encoding must be a string");
                        if ("string" == typeof r && !l.isEncoding(r)) throw new TypeError("Unknown encoding: " + r);
                        if (1 === e1.length) {
                            const t = e1.charCodeAt(0);
                            ("utf8" === r && t < 128 || "latin1" === r) && (e1 = t);
                        }
                    } else "number" == typeof e1 ? e1 &= 255 : "boolean" == typeof e1 && (e1 = Number(e1));
                    if (t < 0 || this.length < t || this.length < n) throw new RangeError("Out of range index");
                    if (n <= t) return this;
                    let i;
                    if (t >>>= 0, n = void 0 === n ? this.length : n >>> 0, e1 || (e1 = 0), "number" == typeof e1) for(i = t; i < n; ++i)this[i] = e1;
                    else {
                        const s = l.isBuffer(e1) ? e1 : l.from(e1, r), a = s.length;
                        if (0 === a) throw new TypeError('The value "' + e1 + '" is invalid for argument "value"');
                        for(i = 0; i < n - t; ++i)this[i + t] = s[i % a];
                    }
                    return this;
                };
                const R = {};
                function U(e1, t, n) {
                    R[e1] = class extends n {
                        constructor(){
                            super(), Object.defineProperty(this, "message", {
                                value: t.apply(this, arguments),
                                writable: !0,
                                configurable: !0
                            }), this.name = `${this.name} [${e1}]`, this.stack, delete this.name;
                        }
                        get code() {
                            return e1;
                        }
                        set code(e1) {
                            Object.defineProperty(this, "code", {
                                configurable: !0,
                                enumerable: !0,
                                value: e1,
                                writable: !0
                            });
                        }
                        toString() {
                            return `${this.name} [${e1}]: ${this.message}`;
                        }
                    };
                }
                function V(e1) {
                    let t = "", n = e1.length;
                    const r = "-" === e1[0] ? 1 : 0;
                    for(; n >= r + 4; n -= 3)t = `_${e1.slice(n - 3, n)}${t}`;
                    return `${e1.slice(0, n)}${t}`;
                }
                function K(e1, t, n, r, i, s) {
                    if (e1 > n || e1 < t) {
                        const r = "bigint" == typeof t ? "n" : "";
                        let i;
                        throw i = s > 3 ? 0 === t || t === BigInt(0) ? `>= 0${r} and < 2${r} ** ${8 * (s + 1)}${r}` : `>= -(2${r} ** ${8 * (s + 1) - 1}${r}) and < 2 ** ${8 * (s + 1) - 1}${r}` : `>= ${t}${r} and <= ${n}${r}`, new R.ERR_OUT_OF_RANGE("value", i, e1);
                    }
                    !function(e1, t, n) {
                        W(t, "offset"), void 0 !== e1[t] && void 0 !== e1[t + n] || X(t, e1.length - (n + 1));
                    }(r, i, s);
                }
                function W(e1, t) {
                    if ("number" != typeof e1) throw new R.ERR_INVALID_ARG_TYPE(t, "number", e1);
                }
                function X(e1, t, n) {
                    if (Math.floor(e1) !== e1) throw W(e1, n), new R.ERR_OUT_OF_RANGE(n || "offset", "an integer", e1);
                    if (t < 0) throw new R.ERR_BUFFER_OUT_OF_BOUNDS;
                    throw new R.ERR_OUT_OF_RANGE(n || "offset", `>= ${n ? 1 : 0} and <= ${t}`, e1);
                }
                U("ERR_BUFFER_OUT_OF_BOUNDS", function(e1) {
                    return e1 ? `${e1} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
                }, RangeError), U("ERR_INVALID_ARG_TYPE", function(e1, t) {
                    return `The "${e1}" argument must be of type number. Received type ${typeof t}`;
                }, TypeError), U("ERR_OUT_OF_RANGE", function(e1, t, n) {
                    let r = `The value of "${e1}" is out of range.`, i = n;
                    return Number.isInteger(n) && Math.abs(n) > 2 ** 32 ? i = V(String(n)) : "bigint" == typeof n && (i = String(n), (n > BigInt(2) ** BigInt(32) || n < -(BigInt(2) ** BigInt(32))) && (i = V(i)), i += "n"), r += ` It must be ${t}. Received ${i}`, r;
                }, RangeError);
                const Y = /[^+/0-9A-Za-z-_]/g;
                function q(e1, t) {
                    let n;
                    t = t || 1 / 0;
                    const r = e1.length;
                    let i = null;
                    const s = [];
                    for(let a = 0; a < r; ++a){
                        if (n = e1.charCodeAt(a), n > 55295 && n < 57344) {
                            if (!i) {
                                if (n > 56319) {
                                    (t -= 3) > -1 && s.push(239, 191, 189);
                                    continue;
                                }
                                if (a + 1 === r) {
                                    (t -= 3) > -1 && s.push(239, 191, 189);
                                    continue;
                                }
                                i = n;
                                continue;
                            }
                            if (n < 56320) {
                                (t -= 3) > -1 && s.push(239, 191, 189), i = n;
                                continue;
                            }
                            n = 65536 + (i - 55296 << 10 | n - 56320);
                        } else i && (t -= 3) > -1 && s.push(239, 191, 189);
                        if (i = null, n < 128) {
                            if ((t -= 1) < 0) break;
                            s.push(n);
                        } else if (n < 2048) {
                            if ((t -= 2) < 0) break;
                            s.push(n >> 6 | 192, 63 & n | 128);
                        } else if (n < 65536) {
                            if ((t -= 3) < 0) break;
                            s.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128);
                        } else {
                            if (!(n < 1114112)) throw new Error("Invalid code point");
                            if ((t -= 4) < 0) break;
                            s.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128);
                        }
                    }
                    return s;
                }
                function H(e1) {
                    return r.toByteArray(function(e1) {
                        if ((e1 = (e1 = e1.split("=")[0]).trim().replace(Y, "")).length < 2) return "";
                        for(; e1.length % 4 != 0;)e1 += "=";
                        return e1;
                    }(e1));
                }
                function J(e1, t, n, r) {
                    let i;
                    for(i = 0; i < r && !(i + n >= t.length || i >= e1.length); ++i)t[i + n] = e1[i];
                    return i;
                }
                function $(e1, t) {
                    return e1 instanceof t || null != e1 && null != e1.constructor && null != e1.constructor.name && e1.constructor.name === t.name;
                }
                function G(e1) {
                    return e1 != e1;
                }
                const z = function() {
                    const e1 = "0123456789abcdef", t = new Array(256);
                    for(let n = 0; n < 16; ++n){
                        const r = 16 * n;
                        for(let i = 0; i < 16; ++i)t[r + i] = e1[n] + e1[i];
                    }
                    return t;
                }();
                function Q(e1) {
                    return "undefined" == typeof BigInt ? Z : e1;
                }
                function Z() {
                    throw new Error("BigInt not supported");
                }
            },
            2589: (e1, t, n)=>{
                "use strict";
                var r = n(4155);
                const i = n(3150), s = n(6434), a = n(8555).stdout, o = n(6864), l = "win32" === r.platform && !(r.env.TERM || "").toLowerCase().startsWith("xterm"), c = [
                    "ansi",
                    "ansi",
                    "ansi256",
                    "ansi16m"
                ], u = new Set([
                    "gray"
                ]), p = Object.create(null);
                function h(e1, t) {
                    t = t || {};
                    const n = a ? a.level : 0;
                    e1.level = void 0 === t.level ? n : t.level, e1.enabled = "enabled" in t ? t.enabled : e1.level > 0;
                }
                function d(e1) {
                    if (!this || !(this instanceof d) || this.template) {
                        const t = {};
                        return h(t, e1), t.template = function() {
                            const e1 = [].slice.call(arguments);
                            return T.apply(null, [
                                t.template
                            ].concat(e1));
                        }, Object.setPrototypeOf(t, d.prototype), Object.setPrototypeOf(t.template, t), t.template.constructor = d, t.template;
                    }
                    h(this, e1);
                }
                l && (s.blue.open = "[94m");
                for (const e1 of Object.keys(s))s[e1].closeRe = new RegExp(i(s[e1].close), "g"), p[e1] = {
                    get () {
                        const t = s[e1];
                        return y.call(this, this._styles ? this._styles.concat(t) : [
                            t
                        ], this._empty, e1);
                    }
                };
                p.visible = {
                    get () {
                        return y.call(this, this._styles || [], !0, "visible");
                    }
                }, s.color.closeRe = new RegExp(i(s.color.close), "g");
                for (const e1 of Object.keys(s.color.ansi))u.has(e1) || (p[e1] = {
                    get () {
                        const t = this.level;
                        return function() {
                            const n = {
                                open: s.color[c[t]][e1].apply(null, arguments),
                                close: s.color.close,
                                closeRe: s.color.closeRe
                            };
                            return y.call(this, this._styles ? this._styles.concat(n) : [
                                n
                            ], this._empty, e1);
                        };
                    }
                });
                s.bgColor.closeRe = new RegExp(i(s.bgColor.close), "g");
                for (const e1 of Object.keys(s.bgColor.ansi))u.has(e1) || (p["bg" + e1[0].toUpperCase() + e1.slice(1)] = {
                    get () {
                        const t = this.level;
                        return function() {
                            const n = {
                                open: s.bgColor[c[t]][e1].apply(null, arguments),
                                close: s.bgColor.close,
                                closeRe: s.bgColor.closeRe
                            };
                            return y.call(this, this._styles ? this._styles.concat(n) : [
                                n
                            ], this._empty, e1);
                        };
                    }
                });
                const f = Object.defineProperties(()=>{}, p);
                function y(e1, t, n) {
                    const r = function() {
                        return m.apply(r, arguments);
                    };
                    r._styles = e1, r._empty = t;
                    const i = this;
                    return Object.defineProperty(r, "level", {
                        enumerable: !0,
                        get: ()=>i.level,
                        set (e1) {
                            i.level = e1;
                        }
                    }), Object.defineProperty(r, "enabled", {
                        enumerable: !0,
                        get: ()=>i.enabled,
                        set (e1) {
                            i.enabled = e1;
                        }
                    }), r.hasGrey = this.hasGrey || "gray" === n || "grey" === n, r.__proto__ = f, r;
                }
                function m() {
                    const e1 = arguments, t = e1.length;
                    let n = String(arguments[0]);
                    if (0 === t) return "";
                    if (t > 1) for(let r = 1; r < t; r++)n += " " + e1[r];
                    if (!this.enabled || this.level <= 0 || !n) return this._empty ? "" : n;
                    const r = s.dim.open;
                    l && this.hasGrey && (s.dim.open = "");
                    for (const e1 of this._styles.slice().reverse())n = e1.open + n.replace(e1.closeRe, e1.open) + e1.close, n = n.replace(/\r?\n/g, `${e1.close}$&${e1.open}`);
                    return s.dim.open = r, n;
                }
                function T(e1, t) {
                    if (!Array.isArray(t)) return [].slice.call(arguments, 1).join(" ");
                    const n = [].slice.call(arguments, 2), r = [
                        t.raw[0]
                    ];
                    for(let e1 = 1; e1 < t.length; e1++)r.push(String(n[e1 - 1]).replace(/[{}\\]/g, "\\$&")), r.push(String(t.raw[e1]));
                    return o(e1, r.join(""));
                }
                Object.defineProperties(d.prototype, p), e1.exports = d(), e1.exports.supportsColor = a, e1.exports.default = e1.exports;
            },
            6864: (e1)=>{
                "use strict";
                const t = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, n = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, r = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, i = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, s = new Map([
                    [
                        "n",
                        "\n"
                    ],
                    [
                        "r",
                        "\r"
                    ],
                    [
                        "t",
                        "\t"
                    ],
                    [
                        "b",
                        "\b"
                    ],
                    [
                        "f",
                        "\f"
                    ],
                    [
                        "v",
                        "\v"
                    ],
                    [
                        "0",
                        "\0"
                    ],
                    [
                        "\\",
                        "\\"
                    ],
                    [
                        "e",
                        ""
                    ],
                    [
                        "a",
                        ""
                    ]
                ]);
                function a(e1) {
                    return "u" === e1[0] && 5 === e1.length || "x" === e1[0] && 3 === e1.length ? String.fromCharCode(parseInt(e1.slice(1), 16)) : s.get(e1) || e1;
                }
                function o(e1, t) {
                    const n = [], s = t.trim().split(/\s*,\s*/g);
                    let o;
                    for (const t of s)if (isNaN(t)) {
                        if (!(o = t.match(r))) throw new Error(`Invalid Chalk template style argument: ${t} (in style '${e1}')`);
                        n.push(o[2].replace(i, (e1, t, n)=>t ? a(t) : n));
                    } else n.push(Number(t));
                    return n;
                }
                function l(e1) {
                    n.lastIndex = 0;
                    const t = [];
                    let r;
                    for(; null !== (r = n.exec(e1));){
                        const e1 = r[1];
                        if (r[2]) {
                            const n = o(e1, r[2]);
                            t.push([
                                e1
                            ].concat(n));
                        } else t.push([
                            e1
                        ]);
                    }
                    return t;
                }
                function c(e1, t) {
                    const n = {};
                    for (const e1 of t)for (const t of e1.styles)n[t[0]] = e1.inverse ? null : t.slice(1);
                    let r = e1;
                    for (const e1 of Object.keys(n))if (Array.isArray(n[e1])) {
                        if (!(e1 in r)) throw new Error(`Unknown Chalk style: ${e1}`);
                        r = n[e1].length > 0 ? r[e1].apply(r, n[e1]) : r[e1];
                    }
                    return r;
                }
                e1.exports = (e1, n)=>{
                    const r = [], i = [];
                    let s = [];
                    if (n.replace(t, (t, n, o, u, p, h)=>{
                        if (n) s.push(a(n));
                        else if (u) {
                            const t = s.join("");
                            s = [], i.push(0 === r.length ? t : c(e1, r)(t)), r.push({
                                inverse: o,
                                styles: l(u)
                            });
                        } else if (p) {
                            if (0 === r.length) throw new Error("Found extraneous } in Chalk template literal");
                            i.push(c(e1, r)(s.join(""))), s = [], r.pop();
                        } else s.push(h);
                    }), i.push(s.join("")), r.length > 0) {
                        const e1 = `Chalk template literal is missing ${r.length} closing bracket${1 === r.length ? "" : "s"} (\`}\`)`;
                        throw new Error(e1);
                    }
                    return i.join("");
                };
            },
            8168: (e1, t, n)=>{
                var r = n(3515), i = {};
                for(var s in r)r.hasOwnProperty(s) && (i[r[s]] = s);
                var a = e1.exports = {
                    rgb: {
                        channels: 3,
                        labels: "rgb"
                    },
                    hsl: {
                        channels: 3,
                        labels: "hsl"
                    },
                    hsv: {
                        channels: 3,
                        labels: "hsv"
                    },
                    hwb: {
                        channels: 3,
                        labels: "hwb"
                    },
                    cmyk: {
                        channels: 4,
                        labels: "cmyk"
                    },
                    xyz: {
                        channels: 3,
                        labels: "xyz"
                    },
                    lab: {
                        channels: 3,
                        labels: "lab"
                    },
                    lch: {
                        channels: 3,
                        labels: "lch"
                    },
                    hex: {
                        channels: 1,
                        labels: [
                            "hex"
                        ]
                    },
                    keyword: {
                        channels: 1,
                        labels: [
                            "keyword"
                        ]
                    },
                    ansi16: {
                        channels: 1,
                        labels: [
                            "ansi16"
                        ]
                    },
                    ansi256: {
                        channels: 1,
                        labels: [
                            "ansi256"
                        ]
                    },
                    hcg: {
                        channels: 3,
                        labels: [
                            "h",
                            "c",
                            "g"
                        ]
                    },
                    apple: {
                        channels: 3,
                        labels: [
                            "r16",
                            "g16",
                            "b16"
                        ]
                    },
                    gray: {
                        channels: 1,
                        labels: [
                            "gray"
                        ]
                    }
                };
                for(var o in a)if (a.hasOwnProperty(o)) {
                    if (!("channels" in a[o])) throw new Error("missing channels property: " + o);
                    if (!("labels" in a[o])) throw new Error("missing channel labels property: " + o);
                    if (a[o].labels.length !== a[o].channels) throw new Error("channel and label counts mismatch: " + o);
                    var l = a[o].channels, c = a[o].labels;
                    delete a[o].channels, delete a[o].labels, Object.defineProperty(a[o], "channels", {
                        value: l
                    }), Object.defineProperty(a[o], "labels", {
                        value: c
                    });
                }
                a.rgb.hsl = function(e1) {
                    var t, n, r = e1[0] / 255, i = e1[1] / 255, s = e1[2] / 255, a = Math.min(r, i, s), o = Math.max(r, i, s), l = o - a;
                    return o === a ? t = 0 : r === o ? t = (i - s) / l : i === o ? t = 2 + (s - r) / l : s === o && (t = 4 + (r - i) / l), (t = Math.min(60 * t, 360)) < 0 && (t += 360), n = (a + o) / 2, [
                        t,
                        100 * (o === a ? 0 : n <= .5 ? l / (o + a) : l / (2 - o - a)),
                        100 * n
                    ];
                }, a.rgb.hsv = function(e1) {
                    var t, n, r = e1[0], i = e1[1], s = e1[2], a = Math.min(r, i, s), o = Math.max(r, i, s), l = o - a;
                    return n = 0 === o ? 0 : l / o * 1e3 / 10, o === a ? t = 0 : r === o ? t = (i - s) / l : i === o ? t = 2 + (s - r) / l : s === o && (t = 4 + (r - i) / l), (t = Math.min(60 * t, 360)) < 0 && (t += 360), [
                        t,
                        n,
                        o / 255 * 1e3 / 10
                    ];
                }, a.rgb.hwb = function(e1) {
                    var t = e1[0], n = e1[1], r = e1[2];
                    return [
                        a.rgb.hsl(e1)[0],
                        1 / 255 * Math.min(t, Math.min(n, r)) * 100,
                        100 * (r = 1 - 1 / 255 * Math.max(t, Math.max(n, r)))
                    ];
                }, a.rgb.cmyk = function(e1) {
                    var t, n = e1[0] / 255, r = e1[1] / 255, i = e1[2] / 255;
                    return [
                        100 * ((1 - n - (t = Math.min(1 - n, 1 - r, 1 - i))) / (1 - t) || 0),
                        100 * ((1 - r - t) / (1 - t) || 0),
                        100 * ((1 - i - t) / (1 - t) || 0),
                        100 * t
                    ];
                }, a.rgb.keyword = function(e1) {
                    var t = i[e1];
                    if (t) return t;
                    var n, s, a, o = 1 / 0;
                    for(var l in r)if (r.hasOwnProperty(l)) {
                        var c = (s = e1, a = r[l], Math.pow(s[0] - a[0], 2) + Math.pow(s[1] - a[1], 2) + Math.pow(s[2] - a[2], 2));
                        c < o && (o = c, n = l);
                    }
                    return n;
                }, a.keyword.rgb = function(e1) {
                    return r[e1];
                }, a.rgb.xyz = function(e1) {
                    var t = e1[0] / 255, n = e1[1] / 255, r = e1[2] / 255;
                    return [
                        100 * (.4124 * (t = t > .04045 ? Math.pow((t + .055) / 1.055, 2.4) : t / 12.92) + .3576 * (n = n > .04045 ? Math.pow((n + .055) / 1.055, 2.4) : n / 12.92) + .1805 * (r = r > .04045 ? Math.pow((r + .055) / 1.055, 2.4) : r / 12.92)),
                        100 * (.2126 * t + .7152 * n + .0722 * r),
                        100 * (.0193 * t + .1192 * n + .9505 * r)
                    ];
                }, a.rgb.lab = function(e1) {
                    var t = a.rgb.xyz(e1), n = t[0], r = t[1], i = t[2];
                    return r /= 100, i /= 108.883, n = (n /= 95.047) > .008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116, [
                        116 * (r = r > .008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116) - 16,
                        500 * (n - r),
                        200 * (r - (i = i > .008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116))
                    ];
                }, a.hsl.rgb = function(e1) {
                    var t, n, r, i, s, a = e1[0] / 360, o = e1[1] / 100, l = e1[2] / 100;
                    if (0 === o) return [
                        s = 255 * l,
                        s,
                        s
                    ];
                    t = 2 * l - (n = l < .5 ? l * (1 + o) : l + o - l * o), i = [
                        0,
                        0,
                        0
                    ];
                    for(var c = 0; c < 3; c++)(r = a + 1 / 3 * -(c - 1)) < 0 && r++, r > 1 && r--, s = 6 * r < 1 ? t + 6 * (n - t) * r : 2 * r < 1 ? n : 3 * r < 2 ? t + (n - t) * (2 / 3 - r) * 6 : t, i[c] = 255 * s;
                    return i;
                }, a.hsl.hsv = function(e1) {
                    var t = e1[0], n = e1[1] / 100, r = e1[2] / 100, i = n, s = Math.max(r, .01);
                    return n *= (r *= 2) <= 1 ? r : 2 - r, i *= s <= 1 ? s : 2 - s, [
                        t,
                        100 * (0 === r ? 2 * i / (s + i) : 2 * n / (r + n)),
                        (r + n) / 2 * 100
                    ];
                }, a.hsv.rgb = function(e1) {
                    var t = e1[0] / 60, n = e1[1] / 100, r = e1[2] / 100, i = Math.floor(t) % 6, s = t - Math.floor(t), a = 255 * r * (1 - n), o = 255 * r * (1 - n * s), l = 255 * r * (1 - n * (1 - s));
                    switch(r *= 255, i){
                        case 0:
                            return [
                                r,
                                l,
                                a
                            ];
                        case 1:
                            return [
                                o,
                                r,
                                a
                            ];
                        case 2:
                            return [
                                a,
                                r,
                                l
                            ];
                        case 3:
                            return [
                                a,
                                o,
                                r
                            ];
                        case 4:
                            return [
                                l,
                                a,
                                r
                            ];
                        case 5:
                            return [
                                r,
                                a,
                                o
                            ];
                    }
                }, a.hsv.hsl = function(e1) {
                    var t, n, r, i = e1[0], s = e1[1] / 100, a = e1[2] / 100, o = Math.max(a, .01);
                    return r = (2 - s) * a, n = s * o, [
                        i,
                        100 * (n = (n /= (t = (2 - s) * o) <= 1 ? t : 2 - t) || 0),
                        100 * (r /= 2)
                    ];
                }, a.hwb.rgb = function(e1) {
                    var t, n, r, i, s, a, o, l = e1[0] / 360, c = e1[1] / 100, u = e1[2] / 100, p = c + u;
                    switch(p > 1 && (c /= p, u /= p), r = 6 * l - (t = Math.floor(6 * l)), 0 != (1 & t) && (r = 1 - r), i = c + r * ((n = 1 - u) - c), t){
                        default:
                        case 6:
                        case 0:
                            s = n, a = i, o = c;
                            break;
                        case 1:
                            s = i, a = n, o = c;
                            break;
                        case 2:
                            s = c, a = n, o = i;
                            break;
                        case 3:
                            s = c, a = i, o = n;
                            break;
                        case 4:
                            s = i, a = c, o = n;
                            break;
                        case 5:
                            s = n, a = c, o = i;
                    }
                    return [
                        255 * s,
                        255 * a,
                        255 * o
                    ];
                }, a.cmyk.rgb = function(e1) {
                    var t = e1[0] / 100, n = e1[1] / 100, r = e1[2] / 100, i = e1[3] / 100;
                    return [
                        255 * (1 - Math.min(1, t * (1 - i) + i)),
                        255 * (1 - Math.min(1, n * (1 - i) + i)),
                        255 * (1 - Math.min(1, r * (1 - i) + i))
                    ];
                }, a.xyz.rgb = function(e1) {
                    var t, n, r, i = e1[0] / 100, s = e1[1] / 100, a = e1[2] / 100;
                    return n = -.9689 * i + 1.8758 * s + .0415 * a, r = .0557 * i + -.204 * s + 1.057 * a, t = (t = 3.2406 * i + -1.5372 * s + -.4986 * a) > .0031308 ? 1.055 * Math.pow(t, 1 / 2.4) - .055 : 12.92 * t, n = n > .0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - .055 : 12.92 * n, r = r > .0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - .055 : 12.92 * r, [
                        255 * (t = Math.min(Math.max(0, t), 1)),
                        255 * (n = Math.min(Math.max(0, n), 1)),
                        255 * (r = Math.min(Math.max(0, r), 1))
                    ];
                }, a.xyz.lab = function(e1) {
                    var t = e1[0], n = e1[1], r = e1[2];
                    return n /= 100, r /= 108.883, t = (t /= 95.047) > .008856 ? Math.pow(t, 1 / 3) : 7.787 * t + 16 / 116, [
                        116 * (n = n > .008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116) - 16,
                        500 * (t - n),
                        200 * (n - (r = r > .008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116))
                    ];
                }, a.lab.xyz = function(e1) {
                    var t, n, r, i = e1[0];
                    t = e1[1] / 500 + (n = (i + 16) / 116), r = n - e1[2] / 200;
                    var s = Math.pow(n, 3), a = Math.pow(t, 3), o = Math.pow(r, 3);
                    return n = s > .008856 ? s : (n - 16 / 116) / 7.787, t = a > .008856 ? a : (t - 16 / 116) / 7.787, r = o > .008856 ? o : (r - 16 / 116) / 7.787, [
                        t *= 95.047,
                        n *= 100,
                        r *= 108.883
                    ];
                }, a.lab.lch = function(e1) {
                    var t, n = e1[0], r = e1[1], i = e1[2];
                    return (t = 360 * Math.atan2(i, r) / 2 / Math.PI) < 0 && (t += 360), [
                        n,
                        Math.sqrt(r * r + i * i),
                        t
                    ];
                }, a.lch.lab = function(e1) {
                    var t, n = e1[0], r = e1[1];
                    return t = e1[2] / 360 * 2 * Math.PI, [
                        n,
                        r * Math.cos(t),
                        r * Math.sin(t)
                    ];
                }, a.rgb.ansi16 = function(e1) {
                    var t = e1[0], n = e1[1], r = e1[2], i = 1 in arguments ? arguments[1] : a.rgb.hsv(e1)[2];
                    if (0 === (i = Math.round(i / 50))) return 30;
                    var s = 30 + (Math.round(r / 255) << 2 | Math.round(n / 255) << 1 | Math.round(t / 255));
                    return 2 === i && (s += 60), s;
                }, a.hsv.ansi16 = function(e1) {
                    return a.rgb.ansi16(a.hsv.rgb(e1), e1[2]);
                }, a.rgb.ansi256 = function(e1) {
                    var t = e1[0], n = e1[1], r = e1[2];
                    return t === n && n === r ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(n / 255 * 5) + Math.round(r / 255 * 5);
                }, a.ansi16.rgb = function(e1) {
                    var t = e1 % 10;
                    if (0 === t || 7 === t) return e1 > 50 && (t += 3.5), [
                        t = t / 10.5 * 255,
                        t,
                        t
                    ];
                    var n = .5 * (1 + ~~(e1 > 50));
                    return [
                        (1 & t) * n * 255,
                        (t >> 1 & 1) * n * 255,
                        (t >> 2 & 1) * n * 255
                    ];
                }, a.ansi256.rgb = function(e1) {
                    if (e1 >= 232) {
                        var t = 10 * (e1 - 232) + 8;
                        return [
                            t,
                            t,
                            t
                        ];
                    }
                    var n;
                    return e1 -= 16, [
                        Math.floor(e1 / 36) / 5 * 255,
                        Math.floor((n = e1 % 36) / 6) / 5 * 255,
                        n % 6 / 5 * 255
                    ];
                }, a.rgb.hex = function(e1) {
                    var t = (((255 & Math.round(e1[0])) << 16) + ((255 & Math.round(e1[1])) << 8) + (255 & Math.round(e1[2]))).toString(16).toUpperCase();
                    return "000000".substring(t.length) + t;
                }, a.hex.rgb = function(e1) {
                    var t = e1.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
                    if (!t) return [
                        0,
                        0,
                        0
                    ];
                    var n = t[0];
                    3 === t[0].length && (n = n.split("").map(function(e1) {
                        return e1 + e1;
                    }).join(""));
                    var r = parseInt(n, 16);
                    return [
                        r >> 16 & 255,
                        r >> 8 & 255,
                        255 & r
                    ];
                }, a.rgb.hcg = function(e1) {
                    var t, n = e1[0] / 255, r = e1[1] / 255, i = e1[2] / 255, s = Math.max(Math.max(n, r), i), a = Math.min(Math.min(n, r), i), o = s - a;
                    return t = o <= 0 ? 0 : s === n ? (r - i) / o % 6 : s === r ? 2 + (i - n) / o : 4 + (n - r) / o + 4, t /= 6, [
                        360 * (t %= 1),
                        100 * o,
                        100 * (o < 1 ? a / (1 - o) : 0)
                    ];
                }, a.hsl.hcg = function(e1) {
                    var t, n = e1[1] / 100, r = e1[2] / 100, i = 0;
                    return (t = r < .5 ? 2 * n * r : 2 * n * (1 - r)) < 1 && (i = (r - .5 * t) / (1 - t)), [
                        e1[0],
                        100 * t,
                        100 * i
                    ];
                }, a.hsv.hcg = function(e1) {
                    var t = e1[1] / 100, n = e1[2] / 100, r = t * n, i = 0;
                    return r < 1 && (i = (n - r) / (1 - r)), [
                        e1[0],
                        100 * r,
                        100 * i
                    ];
                }, a.hcg.rgb = function(e1) {
                    var t = e1[0] / 360, n = e1[1] / 100, r = e1[2] / 100;
                    if (0 === n) return [
                        255 * r,
                        255 * r,
                        255 * r
                    ];
                    var i, s = [
                        0,
                        0,
                        0
                    ], a = t % 1 * 6, o = a % 1, l = 1 - o;
                    switch(Math.floor(a)){
                        case 0:
                            s[0] = 1, s[1] = o, s[2] = 0;
                            break;
                        case 1:
                            s[0] = l, s[1] = 1, s[2] = 0;
                            break;
                        case 2:
                            s[0] = 0, s[1] = 1, s[2] = o;
                            break;
                        case 3:
                            s[0] = 0, s[1] = l, s[2] = 1;
                            break;
                        case 4:
                            s[0] = o, s[1] = 0, s[2] = 1;
                            break;
                        default:
                            s[0] = 1, s[1] = 0, s[2] = l;
                    }
                    return i = (1 - n) * r, [
                        255 * (n * s[0] + i),
                        255 * (n * s[1] + i),
                        255 * (n * s[2] + i)
                    ];
                }, a.hcg.hsv = function(e1) {
                    var t = e1[1] / 100, n = t + e1[2] / 100 * (1 - t), r = 0;
                    return n > 0 && (r = t / n), [
                        e1[0],
                        100 * r,
                        100 * n
                    ];
                }, a.hcg.hsl = function(e1) {
                    var t = e1[1] / 100, n = e1[2] / 100 * (1 - t) + .5 * t, r = 0;
                    return n > 0 && n < .5 ? r = t / (2 * n) : n >= .5 && n < 1 && (r = t / (2 * (1 - n))), [
                        e1[0],
                        100 * r,
                        100 * n
                    ];
                }, a.hcg.hwb = function(e1) {
                    var t = e1[1] / 100, n = t + e1[2] / 100 * (1 - t);
                    return [
                        e1[0],
                        100 * (n - t),
                        100 * (1 - n)
                    ];
                }, a.hwb.hcg = function(e1) {
                    var t = e1[1] / 100, n = 1 - e1[2] / 100, r = n - t, i = 0;
                    return r < 1 && (i = (n - r) / (1 - r)), [
                        e1[0],
                        100 * r,
                        100 * i
                    ];
                }, a.apple.rgb = function(e1) {
                    return [
                        e1[0] / 65535 * 255,
                        e1[1] / 65535 * 255,
                        e1[2] / 65535 * 255
                    ];
                }, a.rgb.apple = function(e1) {
                    return [
                        e1[0] / 255 * 65535,
                        e1[1] / 255 * 65535,
                        e1[2] / 255 * 65535
                    ];
                }, a.gray.rgb = function(e1) {
                    return [
                        e1[0] / 100 * 255,
                        e1[0] / 100 * 255,
                        e1[0] / 100 * 255
                    ];
                }, a.gray.hsl = a.gray.hsv = function(e1) {
                    return [
                        0,
                        0,
                        e1[0]
                    ];
                }, a.gray.hwb = function(e1) {
                    return [
                        0,
                        100,
                        e1[0]
                    ];
                }, a.gray.cmyk = function(e1) {
                    return [
                        0,
                        0,
                        0,
                        e1[0]
                    ];
                }, a.gray.lab = function(e1) {
                    return [
                        e1[0],
                        0,
                        0
                    ];
                }, a.gray.hex = function(e1) {
                    var t = 255 & Math.round(e1[0] / 100 * 255), n = ((t << 16) + (t << 8) + t).toString(16).toUpperCase();
                    return "000000".substring(n.length) + n;
                }, a.rgb.gray = function(e1) {
                    return [
                        (e1[0] + e1[1] + e1[2]) / 3 / 255 * 100
                    ];
                };
            },
            2085: (e1, t, n)=>{
                var r = n(8168), i = n(4111), s = {};
                Object.keys(r).forEach(function(e1) {
                    s[e1] = {}, Object.defineProperty(s[e1], "channels", {
                        value: r[e1].channels
                    }), Object.defineProperty(s[e1], "labels", {
                        value: r[e1].labels
                    });
                    var t = i(e1);
                    Object.keys(t).forEach(function(n) {
                        var r = t[n];
                        s[e1][n] = function(e1) {
                            var t = function(t) {
                                if (null == t) return t;
                                arguments.length > 1 && (t = Array.prototype.slice.call(arguments));
                                var n = e1(t);
                                if ("object" == typeof n) for(var r = n.length, i = 0; i < r; i++)n[i] = Math.round(n[i]);
                                return n;
                            };
                            return "conversion" in e1 && (t.conversion = e1.conversion), t;
                        }(r), s[e1][n].raw = function(e1) {
                            var t = function(t) {
                                return null == t ? t : (arguments.length > 1 && (t = Array.prototype.slice.call(arguments)), e1(t));
                            };
                            return "conversion" in e1 && (t.conversion = e1.conversion), t;
                        }(r);
                    });
                }), e1.exports = s;
            },
            4111: (e1, t, n)=>{
                var r = n(8168);
                function i(e1, t) {
                    return function(n) {
                        return t(e1(n));
                    };
                }
                function s(e1, t) {
                    for(var n = [
                        t[e1].parent,
                        e1
                    ], s = r[t[e1].parent][e1], a = t[e1].parent; t[a].parent;)n.unshift(t[a].parent), s = i(r[t[a].parent][a], s), a = t[a].parent;
                    return s.conversion = n, s;
                }
                e1.exports = function(e1) {
                    for(var t = function(e1) {
                        var t = function() {
                            for(var e1 = {}, t = Object.keys(r), n = t.length, i = 0; i < n; i++)e1[t[i]] = {
                                distance: -1,
                                parent: null
                            };
                            return e1;
                        }(), n = [
                            e1
                        ];
                        for(t[e1].distance = 0; n.length;)for(var i = n.pop(), s = Object.keys(r[i]), a = s.length, o = 0; o < a; o++){
                            var l = s[o], c = t[l];
                            -1 === c.distance && (c.distance = t[i].distance + 1, c.parent = i, n.unshift(l));
                        }
                        return t;
                    }(e1), n = {}, i = Object.keys(t), a = i.length, o = 0; o < a; o++){
                        var l = i[o];
                        null !== t[l].parent && (n[l] = s(l, t));
                    }
                    return n;
                };
            },
            3515: (e1)=>{
                "use strict";
                e1.exports = {
                    aliceblue: [
                        240,
                        248,
                        255
                    ],
                    antiquewhite: [
                        250,
                        235,
                        215
                    ],
                    aqua: [
                        0,
                        255,
                        255
                    ],
                    aquamarine: [
                        127,
                        255,
                        212
                    ],
                    azure: [
                        240,
                        255,
                        255
                    ],
                    beige: [
                        245,
                        245,
                        220
                    ],
                    bisque: [
                        255,
                        228,
                        196
                    ],
                    black: [
                        0,
                        0,
                        0
                    ],
                    blanchedalmond: [
                        255,
                        235,
                        205
                    ],
                    blue: [
                        0,
                        0,
                        255
                    ],
                    blueviolet: [
                        138,
                        43,
                        226
                    ],
                    brown: [
                        165,
                        42,
                        42
                    ],
                    burlywood: [
                        222,
                        184,
                        135
                    ],
                    cadetblue: [
                        95,
                        158,
                        160
                    ],
                    chartreuse: [
                        127,
                        255,
                        0
                    ],
                    chocolate: [
                        210,
                        105,
                        30
                    ],
                    coral: [
                        255,
                        127,
                        80
                    ],
                    cornflowerblue: [
                        100,
                        149,
                        237
                    ],
                    cornsilk: [
                        255,
                        248,
                        220
                    ],
                    crimson: [
                        220,
                        20,
                        60
                    ],
                    cyan: [
                        0,
                        255,
                        255
                    ],
                    darkblue: [
                        0,
                        0,
                        139
                    ],
                    darkcyan: [
                        0,
                        139,
                        139
                    ],
                    darkgoldenrod: [
                        184,
                        134,
                        11
                    ],
                    darkgray: [
                        169,
                        169,
                        169
                    ],
                    darkgreen: [
                        0,
                        100,
                        0
                    ],
                    darkgrey: [
                        169,
                        169,
                        169
                    ],
                    darkkhaki: [
                        189,
                        183,
                        107
                    ],
                    darkmagenta: [
                        139,
                        0,
                        139
                    ],
                    darkolivegreen: [
                        85,
                        107,
                        47
                    ],
                    darkorange: [
                        255,
                        140,
                        0
                    ],
                    darkorchid: [
                        153,
                        50,
                        204
                    ],
                    darkred: [
                        139,
                        0,
                        0
                    ],
                    darksalmon: [
                        233,
                        150,
                        122
                    ],
                    darkseagreen: [
                        143,
                        188,
                        143
                    ],
                    darkslateblue: [
                        72,
                        61,
                        139
                    ],
                    darkslategray: [
                        47,
                        79,
                        79
                    ],
                    darkslategrey: [
                        47,
                        79,
                        79
                    ],
                    darkturquoise: [
                        0,
                        206,
                        209
                    ],
                    darkviolet: [
                        148,
                        0,
                        211
                    ],
                    deeppink: [
                        255,
                        20,
                        147
                    ],
                    deepskyblue: [
                        0,
                        191,
                        255
                    ],
                    dimgray: [
                        105,
                        105,
                        105
                    ],
                    dimgrey: [
                        105,
                        105,
                        105
                    ],
                    dodgerblue: [
                        30,
                        144,
                        255
                    ],
                    firebrick: [
                        178,
                        34,
                        34
                    ],
                    floralwhite: [
                        255,
                        250,
                        240
                    ],
                    forestgreen: [
                        34,
                        139,
                        34
                    ],
                    fuchsia: [
                        255,
                        0,
                        255
                    ],
                    gainsboro: [
                        220,
                        220,
                        220
                    ],
                    ghostwhite: [
                        248,
                        248,
                        255
                    ],
                    gold: [
                        255,
                        215,
                        0
                    ],
                    goldenrod: [
                        218,
                        165,
                        32
                    ],
                    gray: [
                        128,
                        128,
                        128
                    ],
                    green: [
                        0,
                        128,
                        0
                    ],
                    greenyellow: [
                        173,
                        255,
                        47
                    ],
                    grey: [
                        128,
                        128,
                        128
                    ],
                    honeydew: [
                        240,
                        255,
                        240
                    ],
                    hotpink: [
                        255,
                        105,
                        180
                    ],
                    indianred: [
                        205,
                        92,
                        92
                    ],
                    indigo: [
                        75,
                        0,
                        130
                    ],
                    ivory: [
                        255,
                        255,
                        240
                    ],
                    khaki: [
                        240,
                        230,
                        140
                    ],
                    lavender: [
                        230,
                        230,
                        250
                    ],
                    lavenderblush: [
                        255,
                        240,
                        245
                    ],
                    lawngreen: [
                        124,
                        252,
                        0
                    ],
                    lemonchiffon: [
                        255,
                        250,
                        205
                    ],
                    lightblue: [
                        173,
                        216,
                        230
                    ],
                    lightcoral: [
                        240,
                        128,
                        128
                    ],
                    lightcyan: [
                        224,
                        255,
                        255
                    ],
                    lightgoldenrodyellow: [
                        250,
                        250,
                        210
                    ],
                    lightgray: [
                        211,
                        211,
                        211
                    ],
                    lightgreen: [
                        144,
                        238,
                        144
                    ],
                    lightgrey: [
                        211,
                        211,
                        211
                    ],
                    lightpink: [
                        255,
                        182,
                        193
                    ],
                    lightsalmon: [
                        255,
                        160,
                        122
                    ],
                    lightseagreen: [
                        32,
                        178,
                        170
                    ],
                    lightskyblue: [
                        135,
                        206,
                        250
                    ],
                    lightslategray: [
                        119,
                        136,
                        153
                    ],
                    lightslategrey: [
                        119,
                        136,
                        153
                    ],
                    lightsteelblue: [
                        176,
                        196,
                        222
                    ],
                    lightyellow: [
                        255,
                        255,
                        224
                    ],
                    lime: [
                        0,
                        255,
                        0
                    ],
                    limegreen: [
                        50,
                        205,
                        50
                    ],
                    linen: [
                        250,
                        240,
                        230
                    ],
                    magenta: [
                        255,
                        0,
                        255
                    ],
                    maroon: [
                        128,
                        0,
                        0
                    ],
                    mediumaquamarine: [
                        102,
                        205,
                        170
                    ],
                    mediumblue: [
                        0,
                        0,
                        205
                    ],
                    mediumorchid: [
                        186,
                        85,
                        211
                    ],
                    mediumpurple: [
                        147,
                        112,
                        219
                    ],
                    mediumseagreen: [
                        60,
                        179,
                        113
                    ],
                    mediumslateblue: [
                        123,
                        104,
                        238
                    ],
                    mediumspringgreen: [
                        0,
                        250,
                        154
                    ],
                    mediumturquoise: [
                        72,
                        209,
                        204
                    ],
                    mediumvioletred: [
                        199,
                        21,
                        133
                    ],
                    midnightblue: [
                        25,
                        25,
                        112
                    ],
                    mintcream: [
                        245,
                        255,
                        250
                    ],
                    mistyrose: [
                        255,
                        228,
                        225
                    ],
                    moccasin: [
                        255,
                        228,
                        181
                    ],
                    navajowhite: [
                        255,
                        222,
                        173
                    ],
                    navy: [
                        0,
                        0,
                        128
                    ],
                    oldlace: [
                        253,
                        245,
                        230
                    ],
                    olive: [
                        128,
                        128,
                        0
                    ],
                    olivedrab: [
                        107,
                        142,
                        35
                    ],
                    orange: [
                        255,
                        165,
                        0
                    ],
                    orangered: [
                        255,
                        69,
                        0
                    ],
                    orchid: [
                        218,
                        112,
                        214
                    ],
                    palegoldenrod: [
                        238,
                        232,
                        170
                    ],
                    palegreen: [
                        152,
                        251,
                        152
                    ],
                    paleturquoise: [
                        175,
                        238,
                        238
                    ],
                    palevioletred: [
                        219,
                        112,
                        147
                    ],
                    papayawhip: [
                        255,
                        239,
                        213
                    ],
                    peachpuff: [
                        255,
                        218,
                        185
                    ],
                    peru: [
                        205,
                        133,
                        63
                    ],
                    pink: [
                        255,
                        192,
                        203
                    ],
                    plum: [
                        221,
                        160,
                        221
                    ],
                    powderblue: [
                        176,
                        224,
                        230
                    ],
                    purple: [
                        128,
                        0,
                        128
                    ],
                    rebeccapurple: [
                        102,
                        51,
                        153
                    ],
                    red: [
                        255,
                        0,
                        0
                    ],
                    rosybrown: [
                        188,
                        143,
                        143
                    ],
                    royalblue: [
                        65,
                        105,
                        225
                    ],
                    saddlebrown: [
                        139,
                        69,
                        19
                    ],
                    salmon: [
                        250,
                        128,
                        114
                    ],
                    sandybrown: [
                        244,
                        164,
                        96
                    ],
                    seagreen: [
                        46,
                        139,
                        87
                    ],
                    seashell: [
                        255,
                        245,
                        238
                    ],
                    sienna: [
                        160,
                        82,
                        45
                    ],
                    silver: [
                        192,
                        192,
                        192
                    ],
                    skyblue: [
                        135,
                        206,
                        235
                    ],
                    slateblue: [
                        106,
                        90,
                        205
                    ],
                    slategray: [
                        112,
                        128,
                        144
                    ],
                    slategrey: [
                        112,
                        128,
                        144
                    ],
                    snow: [
                        255,
                        250,
                        250
                    ],
                    springgreen: [
                        0,
                        255,
                        127
                    ],
                    steelblue: [
                        70,
                        130,
                        180
                    ],
                    tan: [
                        210,
                        180,
                        140
                    ],
                    teal: [
                        0,
                        128,
                        128
                    ],
                    thistle: [
                        216,
                        191,
                        216
                    ],
                    tomato: [
                        255,
                        99,
                        71
                    ],
                    turquoise: [
                        64,
                        224,
                        208
                    ],
                    violet: [
                        238,
                        130,
                        238
                    ],
                    wheat: [
                        245,
                        222,
                        179
                    ],
                    white: [
                        255,
                        255,
                        255
                    ],
                    whitesmoke: [
                        245,
                        245,
                        245
                    ],
                    yellow: [
                        255,
                        255,
                        0
                    ],
                    yellowgreen: [
                        154,
                        205,
                        50
                    ]
                };
            },
            1227: (e1, t, n)=>{
                var r = n(4155);
                t.log = function(...e1) {
                    return "object" == typeof console && console.log && console.log(...e1);
                }, t.formatArgs = function(t) {
                    if (t[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + t[0] + (this.useColors ? "%c " : " ") + "+" + e1.exports.humanize(this.diff), !this.useColors) return;
                    const n = "color: " + this.color;
                    t.splice(1, 0, n, "color: inherit");
                    let r = 0, i = 0;
                    t[0].replace(/%[a-zA-Z%]/g, (e1)=>{
                        "%%" !== e1 && (r++, "%c" === e1 && (i = r));
                    }), t.splice(i, 0, n);
                }, t.save = function(e1) {
                    try {
                        e1 ? t.storage.setItem("debug", e1) : t.storage.removeItem("debug");
                    } catch (e1) {}
                }, t.load = function() {
                    let e1;
                    try {
                        e1 = t.storage.getItem("debug");
                    } catch (e1) {}
                    return !e1 && void 0 !== r && "env" in r && (e1 = r.env.DEBUG), e1;
                }, t.useColors = function() {
                    return !("undefined" == typeof window || !window.process || "renderer" !== window.process.type && !window.process.__nwjs) || ("undefined" == typeof navigator || !navigator.userAgent || !navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && ("undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
                }, t.storage = function() {
                    try {
                        return localStorage;
                    } catch (e1) {}
                }(), t.colors = [
                    "#0000CC",
                    "#0000FF",
                    "#0033CC",
                    "#0033FF",
                    "#0066CC",
                    "#0066FF",
                    "#0099CC",
                    "#0099FF",
                    "#00CC00",
                    "#00CC33",
                    "#00CC66",
                    "#00CC99",
                    "#00CCCC",
                    "#00CCFF",
                    "#3300CC",
                    "#3300FF",
                    "#3333CC",
                    "#3333FF",
                    "#3366CC",
                    "#3366FF",
                    "#3399CC",
                    "#3399FF",
                    "#33CC00",
                    "#33CC33",
                    "#33CC66",
                    "#33CC99",
                    "#33CCCC",
                    "#33CCFF",
                    "#6600CC",
                    "#6600FF",
                    "#6633CC",
                    "#6633FF",
                    "#66CC00",
                    "#66CC33",
                    "#9900CC",
                    "#9900FF",
                    "#9933CC",
                    "#9933FF",
                    "#99CC00",
                    "#99CC33",
                    "#CC0000",
                    "#CC0033",
                    "#CC0066",
                    "#CC0099",
                    "#CC00CC",
                    "#CC00FF",
                    "#CC3300",
                    "#CC3333",
                    "#CC3366",
                    "#CC3399",
                    "#CC33CC",
                    "#CC33FF",
                    "#CC6600",
                    "#CC6633",
                    "#CC9900",
                    "#CC9933",
                    "#CCCC00",
                    "#CCCC33",
                    "#FF0000",
                    "#FF0033",
                    "#FF0066",
                    "#FF0099",
                    "#FF00CC",
                    "#FF00FF",
                    "#FF3300",
                    "#FF3333",
                    "#FF3366",
                    "#FF3399",
                    "#FF33CC",
                    "#FF33FF",
                    "#FF6600",
                    "#FF6633",
                    "#FF9900",
                    "#FF9933",
                    "#FFCC00",
                    "#FFCC33"
                ], e1.exports = n(2447)(t);
                const { formatters: i } = e1.exports;
                i.j = function(e1) {
                    try {
                        return JSON.stringify(e1);
                    } catch (e1) {
                        return "[UnexpectedJSONParseError]: " + e1.message;
                    }
                };
            },
            2447: (e1, t, n)=>{
                e1.exports = function(e1) {
                    function t(e1) {
                        let t = 0;
                        for(let n = 0; n < e1.length; n++)t = (t << 5) - t + e1.charCodeAt(n), t |= 0;
                        return r.colors[Math.abs(t) % r.colors.length];
                    }
                    function r(e1) {
                        let n;
                        function a(...e1) {
                            if (!a.enabled) return;
                            const t = a, i = Number(new Date), s = i - (n || i);
                            t.diff = s, t.prev = n, t.curr = i, n = i, e1[0] = r.coerce(e1[0]), "string" != typeof e1[0] && e1.unshift("%O");
                            let o = 0;
                            e1[0] = e1[0].replace(/%([a-zA-Z%])/g, (n, i)=>{
                                if ("%%" === n) return n;
                                o++;
                                const s = r.formatters[i];
                                if ("function" == typeof s) {
                                    const r = e1[o];
                                    n = s.call(t, r), e1.splice(o, 1), o--;
                                }
                                return n;
                            }), r.formatArgs.call(t, e1), (t.log || r.log).apply(t, e1);
                        }
                        return a.namespace = e1, a.enabled = r.enabled(e1), a.useColors = r.useColors(), a.color = t(e1), a.destroy = i, a.extend = s, "function" == typeof r.init && r.init(a), r.instances.push(a), a;
                    }
                    function i() {
                        const e1 = r.instances.indexOf(this);
                        return -1 !== e1 && (r.instances.splice(e1, 1), !0);
                    }
                    function s(e1, t) {
                        const n = r(this.namespace + (void 0 === t ? ":" : t) + e1);
                        return n.log = this.log, n;
                    }
                    function a(e1) {
                        return e1.toString().substring(2, e1.toString().length - 2).replace(/\.\*\?$/, "*");
                    }
                    return r.debug = r, r.default = r, r.coerce = function(e1) {
                        return e1 instanceof Error ? e1.stack || e1.message : e1;
                    }, r.disable = function() {
                        const e1 = [
                            ...r.names.map(a),
                            ...r.skips.map(a).map((e1)=>"-" + e1)
                        ].join(",");
                        return r.enable(""), e1;
                    }, r.enable = function(e1) {
                        let t;
                        r.save(e1), r.names = [], r.skips = [];
                        const n = ("string" == typeof e1 ? e1 : "").split(/[\s,]+/), i = n.length;
                        for(t = 0; t < i; t++)n[t] && ("-" === (e1 = n[t].replace(/\*/g, ".*?"))[0] ? r.skips.push(new RegExp("^" + e1.substr(1) + "$")) : r.names.push(new RegExp("^" + e1 + "$")));
                        for(t = 0; t < r.instances.length; t++){
                            const e1 = r.instances[t];
                            e1.enabled = r.enabled(e1.namespace);
                        }
                    }, r.enabled = function(e1) {
                        if ("*" === e1[e1.length - 1]) return !0;
                        let t, n;
                        for(t = 0, n = r.skips.length; t < n; t++)if (r.skips[t].test(e1)) return !1;
                        for(t = 0, n = r.names.length; t < n; t++)if (r.names[t].test(e1)) return !0;
                        return !1;
                    }, r.humanize = n(7824), Object.keys(e1).forEach((t)=>{
                        r[t] = e1[t];
                    }), r.instances = [], r.names = [], r.skips = [], r.formatters = {}, r.selectColor = t, r.enable(r.load()), r;
                };
            },
            9996: (e1)=>{
                "use strict";
                var t = function(e1) {
                    return function(e1) {
                        return !!e1 && "object" == typeof e1;
                    }(e1) && !function(e1) {
                        var t = Object.prototype.toString.call(e1);
                        return "[object RegExp]" === t || "[object Date]" === t || function(e1) {
                            return e1.$$typeof === n;
                        }(e1);
                    }(e1);
                }, n = "function" == typeof Symbol && Symbol.for ? Symbol.for("react.element") : 60103;
                function r(e1, t) {
                    return !1 !== t.clone && t.isMergeableObject(e1) ? o((n = e1, Array.isArray(n) ? [] : {}), e1, t) : e1;
                    "TURBOPACK unreachable";
                    var n;
                }
                function i(e1, t, n) {
                    return e1.concat(t).map(function(e1) {
                        return r(e1, n);
                    });
                }
                function s(e1) {
                    return Object.keys(e1).concat(function(e1) {
                        return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e1).filter(function(t) {
                            return Object.propertyIsEnumerable.call(e1, t);
                        }) : [];
                    }(e1));
                }
                function a(e1, t) {
                    try {
                        return t in e1;
                    } catch (e1) {
                        return !1;
                    }
                }
                function o(e1, n, l) {
                    (l = l || {}).arrayMerge = l.arrayMerge || i, l.isMergeableObject = l.isMergeableObject || t, l.cloneUnlessOtherwiseSpecified = r;
                    var c = Array.isArray(n);
                    return c === Array.isArray(e1) ? c ? l.arrayMerge(e1, n, l) : function(e1, t, n) {
                        var i = {};
                        return n.isMergeableObject(e1) && s(e1).forEach(function(t) {
                            i[t] = r(e1[t], n);
                        }), s(t).forEach(function(s) {
                            (function(e1, t) {
                                return a(e1, t) && !(Object.hasOwnProperty.call(e1, t) && Object.propertyIsEnumerable.call(e1, t));
                            })(e1, s) || (a(e1, s) && n.isMergeableObject(t[s]) ? i[s] = (function(e1, t) {
                                if (!t.customMerge) return o;
                                var n = t.customMerge(e1);
                                return "function" == typeof n ? n : o;
                            })(s, n)(e1[s], t[s], n) : i[s] = r(t[s], n));
                        }), i;
                    }(e1, n, l) : r(n, l);
                }
                o.all = function(e1, t) {
                    if (!Array.isArray(e1)) throw new Error("first argument should be an array");
                    return e1.reduce(function(e1, n) {
                        return o(e1, n, t);
                    }, {});
                };
                var l = o;
                e1.exports = l;
            },
            4021: (e1)=>{
                var t = {};
                function n(e1) {
                    return e1.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g) || [];
                }
                e1.exports = t, t.eastAsianWidth = function(e1) {
                    var t = e1.charCodeAt(0), n = 2 == e1.length ? e1.charCodeAt(1) : 0, r = t;
                    return 55296 <= t && t <= 56319 && 56320 <= n && n <= 57343 && (r = (t &= 1023) << 10 | (n &= 1023), r += 65536), 12288 == r || 65281 <= r && r <= 65376 || 65504 <= r && r <= 65510 ? "F" : 8361 == r || 65377 <= r && r <= 65470 || 65474 <= r && r <= 65479 || 65482 <= r && r <= 65487 || 65490 <= r && r <= 65495 || 65498 <= r && r <= 65500 || 65512 <= r && r <= 65518 ? "H" : 4352 <= r && r <= 4447 || 4515 <= r && r <= 4519 || 4602 <= r && r <= 4607 || 9001 <= r && r <= 9002 || 11904 <= r && r <= 11929 || 11931 <= r && r <= 12019 || 12032 <= r && r <= 12245 || 12272 <= r && r <= 12283 || 12289 <= r && r <= 12350 || 12353 <= r && r <= 12438 || 12441 <= r && r <= 12543 || 12549 <= r && r <= 12589 || 12593 <= r && r <= 12686 || 12688 <= r && r <= 12730 || 12736 <= r && r <= 12771 || 12784 <= r && r <= 12830 || 12832 <= r && r <= 12871 || 12880 <= r && r <= 13054 || 13056 <= r && r <= 19903 || 19968 <= r && r <= 42124 || 42128 <= r && r <= 42182 || 43360 <= r && r <= 43388 || 44032 <= r && r <= 55203 || 55216 <= r && r <= 55238 || 55243 <= r && r <= 55291 || 63744 <= r && r <= 64255 || 65040 <= r && r <= 65049 || 65072 <= r && r <= 65106 || 65108 <= r && r <= 65126 || 65128 <= r && r <= 65131 || 110592 <= r && r <= 110593 || 127488 <= r && r <= 127490 || 127504 <= r && r <= 127546 || 127552 <= r && r <= 127560 || 127568 <= r && r <= 127569 || 131072 <= r && r <= 194367 || 177984 <= r && r <= 196605 || 196608 <= r && r <= 262141 ? "W" : 32 <= r && r <= 126 || 162 <= r && r <= 163 || 165 <= r && r <= 166 || 172 == r || 175 == r || 10214 <= r && r <= 10221 || 10629 <= r && r <= 10630 ? "Na" : 161 == r || 164 == r || 167 <= r && r <= 168 || 170 == r || 173 <= r && r <= 174 || 176 <= r && r <= 180 || 182 <= r && r <= 186 || 188 <= r && r <= 191 || 198 == r || 208 == r || 215 <= r && r <= 216 || 222 <= r && r <= 225 || 230 == r || 232 <= r && r <= 234 || 236 <= r && r <= 237 || 240 == r || 242 <= r && r <= 243 || 247 <= r && r <= 250 || 252 == r || 254 == r || 257 == r || 273 == r || 275 == r || 283 == r || 294 <= r && r <= 295 || 299 == r || 305 <= r && r <= 307 || 312 == r || 319 <= r && r <= 322 || 324 == r || 328 <= r && r <= 331 || 333 == r || 338 <= r && r <= 339 || 358 <= r && r <= 359 || 363 == r || 462 == r || 464 == r || 466 == r || 468 == r || 470 == r || 472 == r || 474 == r || 476 == r || 593 == r || 609 == r || 708 == r || 711 == r || 713 <= r && r <= 715 || 717 == r || 720 == r || 728 <= r && r <= 731 || 733 == r || 735 == r || 768 <= r && r <= 879 || 913 <= r && r <= 929 || 931 <= r && r <= 937 || 945 <= r && r <= 961 || 963 <= r && r <= 969 || 1025 == r || 1040 <= r && r <= 1103 || 1105 == r || 8208 == r || 8211 <= r && r <= 8214 || 8216 <= r && r <= 8217 || 8220 <= r && r <= 8221 || 8224 <= r && r <= 8226 || 8228 <= r && r <= 8231 || 8240 == r || 8242 <= r && r <= 8243 || 8245 == r || 8251 == r || 8254 == r || 8308 == r || 8319 == r || 8321 <= r && r <= 8324 || 8364 == r || 8451 == r || 8453 == r || 8457 == r || 8467 == r || 8470 == r || 8481 <= r && r <= 8482 || 8486 == r || 8491 == r || 8531 <= r && r <= 8532 || 8539 <= r && r <= 8542 || 8544 <= r && r <= 8555 || 8560 <= r && r <= 8569 || 8585 == r || 8592 <= r && r <= 8601 || 8632 <= r && r <= 8633 || 8658 == r || 8660 == r || 8679 == r || 8704 == r || 8706 <= r && r <= 8707 || 8711 <= r && r <= 8712 || 8715 == r || 8719 == r || 8721 == r || 8725 == r || 8730 == r || 8733 <= r && r <= 8736 || 8739 == r || 8741 == r || 8743 <= r && r <= 8748 || 8750 == r || 8756 <= r && r <= 8759 || 8764 <= r && r <= 8765 || 8776 == r || 8780 == r || 8786 == r || 8800 <= r && r <= 8801 || 8804 <= r && r <= 8807 || 8810 <= r && r <= 8811 || 8814 <= r && r <= 8815 || 8834 <= r && r <= 8835 || 8838 <= r && r <= 8839 || 8853 == r || 8857 == r || 8869 == r || 8895 == r || 8978 == r || 9312 <= r && r <= 9449 || 9451 <= r && r <= 9547 || 9552 <= r && r <= 9587 || 9600 <= r && r <= 9615 || 9618 <= r && r <= 9621 || 9632 <= r && r <= 9633 || 9635 <= r && r <= 9641 || 9650 <= r && r <= 9651 || 9654 <= r && r <= 9655 || 9660 <= r && r <= 9661 || 9664 <= r && r <= 9665 || 9670 <= r && r <= 9672 || 9675 == r || 9678 <= r && r <= 9681 || 9698 <= r && r <= 9701 || 9711 == r || 9733 <= r && r <= 9734 || 9737 == r || 9742 <= r && r <= 9743 || 9748 <= r && r <= 9749 || 9756 == r || 9758 == r || 9792 == r || 9794 == r || 9824 <= r && r <= 9825 || 9827 <= r && r <= 9829 || 9831 <= r && r <= 9834 || 9836 <= r && r <= 9837 || 9839 == r || 9886 <= r && r <= 9887 || 9918 <= r && r <= 9919 || 9924 <= r && r <= 9933 || 9935 <= r && r <= 9953 || 9955 == r || 9960 <= r && r <= 9983 || 10045 == r || 10071 == r || 10102 <= r && r <= 10111 || 11093 <= r && r <= 11097 || 12872 <= r && r <= 12879 || 57344 <= r && r <= 63743 || 65024 <= r && r <= 65039 || 65533 == r || 127232 <= r && r <= 127242 || 127248 <= r && r <= 127277 || 127280 <= r && r <= 127337 || 127344 <= r && r <= 127386 || 917760 <= r && r <= 917999 || 983040 <= r && r <= 1048573 || 1048576 <= r && r <= 1114109 ? "A" : "N";
                }, t.characterLength = function(e1) {
                    var t = this.eastAsianWidth(e1);
                    return "F" == t || "W" == t || "A" == t ? 2 : 1;
                }, t.length = function(e1) {
                    for(var t = n(e1), r = 0, i = 0; i < t.length; i++)r += this.characterLength(t[i]);
                    return r;
                }, t.slice = function(e1, r, i) {
                    textLen = t.length(e1), i = i || 1, (r = r || 0) < 0 && (r = textLen + r), i < 0 && (i = textLen + i);
                    for(var s = "", a = 0, o = n(e1), l = 0; l < o.length; l++){
                        var c = o[l], u = t.length(c);
                        if (a >= r - (2 == u ? 1 : 0)) {
                            if (!(a + u <= i)) break;
                            s += c;
                        }
                        a += u;
                    }
                    return s;
                };
            },
            3150: (e1)=>{
                "use strict";
                var t = /[|\\{}()[\]^$+*?.]/g;
                e1.exports = function(e1) {
                    if ("string" != typeof e1) throw new TypeError("Expected a string");
                    return e1.replace(t, "\\$&");
                };
            },
            1272: (e1, t, n)=>{
                "use strict";
                e1.exports = n(8487);
            },
            645: (e1, t)=>{
                t.read = function(e1, t, n, r, i) {
                    var s, a, o = 8 * i - r - 1, l = (1 << o) - 1, c = l >> 1, u = -7, p = n ? i - 1 : 0, h = n ? -1 : 1, d = e1[t + p];
                    for(p += h, s = d & (1 << -u) - 1, d >>= -u, u += o; u > 0; s = 256 * s + e1[t + p], p += h, u -= 8);
                    for(a = s & (1 << -u) - 1, s >>= -u, u += r; u > 0; a = 256 * a + e1[t + p], p += h, u -= 8);
                    if (0 === s) s = 1 - c;
                    else {
                        if (s === l) return a ? NaN : 1 / 0 * (d ? -1 : 1);
                        a += Math.pow(2, r), s -= c;
                    }
                    return (d ? -1 : 1) * a * Math.pow(2, s - r);
                }, t.write = function(e1, t, n, r, i, s) {
                    var a, o, l, c = 8 * s - i - 1, u = (1 << c) - 1, p = u >> 1, h = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = r ? 0 : s - 1, f = r ? 1 : -1, y = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
                    for(t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (o = isNaN(t) ? 1 : 0, a = u) : (a = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), (t += a + p >= 1 ? h / l : h * Math.pow(2, 1 - p)) * l >= 2 && (a++, l /= 2), a + p >= u ? (o = 0, a = u) : a + p >= 1 ? (o = (t * l - 1) * Math.pow(2, i), a += p) : (o = t * Math.pow(2, p - 1) * Math.pow(2, i), a = 0)); i >= 8; e1[n + d] = 255 & o, d += f, o /= 256, i -= 8);
                    for(a = a << i | o, c += i; c > 0; e1[n + d] = 255 & a, d += f, a /= 256, c -= 8);
                    e1[n + d - f] |= 128 * y;
                };
            },
            6188: (e1, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g, t.matchToToken = function(e1) {
                    var t = {
                        type: "invalid",
                        value: e1[0],
                        closed: void 0
                    };
                    return e1[1] ? (t.type = "string", t.closed = !(!e1[3] && !e1[4])) : e1[5] ? t.type = "comment" : e1[6] ? (t.type = "comment", t.closed = !!e1[7]) : e1[8] ? t.type = "regex" : e1[9] ? t.type = "number" : e1[10] ? t.type = "name" : e1[11] ? t.type = "punctuator" : e1[12] && (t.type = "whitespace"), t;
                };
            },
            3312: (e1, t, n)=>{
                "use strict";
                var r = n(8764).lW;
                const i = {}, s = i.hasOwnProperty, a = (e1, t)=>{
                    for(const n in e1)s.call(e1, n) && t(n, e1[n]);
                }, o = i.toString, l = Array.isArray, c = r.isBuffer, u = {
                    '"': '\\"',
                    "'": "\\'",
                    "\\": "\\\\",
                    "\b": "\\b",
                    "\f": "\\f",
                    "\n": "\\n",
                    "\r": "\\r",
                    "\t": "\\t"
                }, p = /["'\\\b\f\n\r\t]/, h = /[0-9]/, d = /[ !#-&\(-\[\]-~]/, f = (e1, t)=>{
                    const n = ()=>{
                        E = b, ++t.indentLevel, b = t.indent.repeat(t.indentLevel);
                    }, r = {
                        escapeEverything: !1,
                        minimal: !1,
                        isScriptContext: !1,
                        quotes: "single",
                        wrap: !1,
                        es6: !1,
                        json: !1,
                        compact: !0,
                        lowercaseHex: !1,
                        numbers: "decimal",
                        indent: "\t",
                        indentLevel: 0,
                        __inline1__: !1,
                        __inline2__: !1
                    }, i = t && t.json;
                    var s, y;
                    i && (r.quotes = "double", r.wrap = !0), s = r, t = (y = t) ? (a(y, (e1, t)=>{
                        s[e1] = t;
                    }), s) : s, "single" != t.quotes && "double" != t.quotes && "backtick" != t.quotes && (t.quotes = "single");
                    const m = "double" == t.quotes ? '"' : "backtick" == t.quotes ? "`" : "'", T = t.compact, g = t.lowercaseHex;
                    let b = t.indent.repeat(t.indentLevel), E = "";
                    const S = t.__inline1__, P = t.__inline2__, x = T ? "" : "\n";
                    let D, A = !0;
                    const v = "binary" == t.numbers, C = "octal" == t.numbers, w = "decimal" == t.numbers, O = "hexadecimal" == t.numbers;
                    if (i && e1 && "function" == typeof e1.toJSON && (e1 = e1.toJSON()), "string" != typeof (I = e1) && "[object String]" != o.call(I)) {
                        if (((e1)=>"[object Map]" == o.call(e1))(e1)) return 0 == e1.size ? "new Map()" : (T || (t.__inline1__ = !0, t.__inline2__ = !1), "new Map(" + f(Array.from(e1), t) + ")");
                        if (((e1)=>"[object Set]" == o.call(e1))(e1)) return 0 == e1.size ? "new Set()" : "new Set(" + f(Array.from(e1), t) + ")";
                        if (c(e1)) return 0 == e1.length ? "Buffer.from([])" : "Buffer.from(" + f(Array.from(e1), t) + ")";
                        if (l(e1)) return D = [], t.wrap = !0, S && (t.__inline1__ = !1, t.__inline2__ = !0), P || n(), ((e1, t)=>{
                            const n = e1.length;
                            let r = -1;
                            for(; ++r < n;)t(e1[r]);
                        })(e1, (e1)=>{
                            A = !1, P && (t.__inline2__ = !1), D.push((T || P ? "" : b) + f(e1, t));
                        }), A ? "[]" : P ? "[" + D.join(", ") + "]" : "[" + x + D.join("," + x) + x + (T ? "" : E) + "]";
                        if (!((e1)=>"number" == typeof e1 || "[object Number]" == o.call(e1))(e1)) return ((e1)=>"[object Object]" == o.call(e1))(e1) ? (D = [], t.wrap = !0, n(), a(e1, (e1, n)=>{
                            A = !1, D.push((T ? "" : b) + f(e1, t) + ":" + (T ? "" : " ") + f(n, t));
                        }), A ? "{}" : "{" + x + D.join("," + x) + x + (T ? "" : E) + "}") : i ? JSON.stringify(e1) || "null" : String(e1);
                        if (i) return JSON.stringify(e1);
                        if (w) return String(e1);
                        if (O) {
                            let t = e1.toString(16);
                            return g || (t = t.toUpperCase()), "0x" + t;
                        }
                        if (v) return "0b" + e1.toString(2);
                        if (C) return "0o" + e1.toString(8);
                    }
                    var I;
                    const N = e1;
                    let F = -1;
                    const k = N.length;
                    for(D = ""; ++F < k;){
                        const e1 = N.charAt(F);
                        if (t.es6) {
                            const e1 = N.charCodeAt(F);
                            if (e1 >= 55296 && e1 <= 56319 && k > F + 1) {
                                const t = N.charCodeAt(F + 1);
                                if (t >= 56320 && t <= 57343) {
                                    let n = (1024 * (e1 - 55296) + t - 56320 + 65536).toString(16);
                                    g || (n = n.toUpperCase()), D += "\\u{" + n + "}", ++F;
                                    continue;
                                }
                            }
                        }
                        if (!t.escapeEverything) {
                            if (d.test(e1)) {
                                D += e1;
                                continue;
                            }
                            if ('"' == e1) {
                                D += m == e1 ? '\\"' : e1;
                                continue;
                            }
                            if ("`" == e1) {
                                D += m == e1 ? "\\`" : e1;
                                continue;
                            }
                            if ("'" == e1) {
                                D += m == e1 ? "\\'" : e1;
                                continue;
                            }
                        }
                        if ("\0" == e1 && !i && !h.test(N.charAt(F + 1))) {
                            D += "\\0";
                            continue;
                        }
                        if (p.test(e1)) {
                            D += u[e1];
                            continue;
                        }
                        const n = e1.charCodeAt(0);
                        if (t.minimal && 8232 != n && 8233 != n) {
                            D += e1;
                            continue;
                        }
                        let r = n.toString(16);
                        g || (r = r.toUpperCase());
                        const s = r.length > 2 || i, a = "\\" + (s ? "u" : "x") + ("0000" + r).slice(s ? -4 : -2);
                        D += a;
                    }
                    return t.wrap && (D = m + D + m), "`" == m && (D = D.replace(/\$\{/g, "\\${")), t.isScriptContext ? D.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, i ? "\\u003C!--" : "\\x3C!--") : D;
                };
                f.version = "2.5.1", e1.exports = f;
            },
            7824: (e1)=>{
                var t = 1e3, n = 60 * t, r = 60 * n, i = 24 * r;
                function s(e1, t, n, r) {
                    var i = t >= 1.5 * n;
                    return Math.round(e1 / n) + " " + r + (i ? "s" : "");
                }
                e1.exports = function(e1, a) {
                    a = a || {};
                    var o, l, c = typeof e1;
                    if ("string" === c && e1.length > 0) return function(e1) {
                        if (!((e1 = String(e1)).length > 100)) {
                            var s = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e1);
                            if (s) {
                                var a = parseFloat(s[1]);
                                switch((s[2] || "ms").toLowerCase()){
                                    case "years":
                                    case "year":
                                    case "yrs":
                                    case "yr":
                                    case "y":
                                        return 315576e5 * a;
                                    case "weeks":
                                    case "week":
                                    case "w":
                                        return 6048e5 * a;
                                    case "days":
                                    case "day":
                                    case "d":
                                        return a * i;
                                    case "hours":
                                    case "hour":
                                    case "hrs":
                                    case "hr":
                                    case "h":
                                        return a * r;
                                    case "minutes":
                                    case "minute":
                                    case "mins":
                                    case "min":
                                    case "m":
                                        return a * n;
                                    case "seconds":
                                    case "second":
                                    case "secs":
                                    case "sec":
                                    case "s":
                                        return a * t;
                                    case "milliseconds":
                                    case "millisecond":
                                    case "msecs":
                                    case "msec":
                                    case "ms":
                                        return a;
                                    default:
                                        return;
                                }
                            }
                        }
                    }(e1);
                    if ("number" === c && isFinite(e1)) return a.long ? (o = e1, (l = Math.abs(o)) >= i ? s(o, l, i, "day") : l >= r ? s(o, l, r, "hour") : l >= n ? s(o, l, n, "minute") : l >= t ? s(o, l, t, "second") : o + " ms") : function(e1) {
                        var s = Math.abs(e1);
                        return s >= i ? Math.round(e1 / i) + "d" : s >= r ? Math.round(e1 / r) + "h" : s >= n ? Math.round(e1 / n) + "m" : s >= t ? Math.round(e1 / t) + "s" : e1 + "ms";
                    }(e1);
                    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e1));
                };
            },
            4155: (e1)=>{
                var t, n, r = e1.exports = {};
                function i() {
                    throw new Error("setTimeout has not been defined");
                }
                function s() {
                    throw new Error("clearTimeout has not been defined");
                }
                function a(e1) {
                    if (t === setTimeout) return setTimeout(e1, 0);
                    if ((t === i || !t) && setTimeout) return t = setTimeout, setTimeout(e1, 0);
                    try {
                        return t(e1, 0);
                    } catch (n) {
                        try {
                            return t.call(null, e1, 0);
                        } catch (n) {
                            return t.call(this, e1, 0);
                        }
                    }
                }
                !function() {
                    try {
                        t = "function" == typeof setTimeout ? setTimeout : i;
                    } catch (e1) {
                        t = i;
                    }
                    try {
                        n = "function" == typeof clearTimeout ? clearTimeout : s;
                    } catch (e1) {
                        n = s;
                    }
                }();
                var o, l = [], c = !1, u = -1;
                function p() {
                    c && o && (c = !1, o.length ? l = o.concat(l) : u = -1, l.length && h());
                }
                function h() {
                    if (!c) {
                        var e1 = a(p);
                        c = !0;
                        for(var t = l.length; t;){
                            for(o = l, l = []; ++u < t;)o && o[u].run();
                            u = -1, t = l.length;
                        }
                        o = null, c = !1, function(e1) {
                            if (n === clearTimeout) return clearTimeout(e1);
                            if ((n === s || !n) && clearTimeout) return n = clearTimeout, clearTimeout(e1);
                            try {
                                return n(e1);
                            } catch (t) {
                                try {
                                    return n.call(null, e1);
                                } catch (t) {
                                    return n.call(this, e1);
                                }
                            }
                        }(e1);
                    }
                }
                function d(e1, t) {
                    this.fun = e1, this.array = t;
                }
                function f() {}
                r.nextTick = function(e1) {
                    var t = new Array(arguments.length - 1);
                    if (arguments.length > 1) for(var n = 1; n < arguments.length; n++)t[n - 1] = arguments[n];
                    l.push(new d(e1, t)), 1 !== l.length || c || a(h);
                }, d.prototype.run = function() {
                    this.fun.apply(null, this.array);
                }, r.title = "browser", r.browser = !0, r.env = {}, r.argv = [], r.version = "", r.versions = {}, r.on = f, r.addListener = f, r.once = f, r.off = f, r.removeListener = f, r.removeAllListeners = f, r.emit = f, r.prependListener = f, r.prependOnceListener = f, r.listeners = function(e1) {
                    return [];
                }, r.binding = function(e1) {
                    throw new Error("process.binding is not supported");
                }, r.cwd = function() {
                    return "/";
                }, r.chdir = function(e1) {
                    throw new Error("process.chdir is not supported");
                }, r.umask = function() {
                    return 0;
                };
            },
            8555: (e1)=>{
                "use strict";
                e1.exports = {
                    stdout: !1,
                    stderr: !1
                };
            },
            3164: (e1)=>{
                "use strict";
                let t = null;
                function n(e1) {
                    if (null !== t && (t.property, 1)) {
                        const e1 = t;
                        return t = n.prototype = null, e1;
                    }
                    return t = n.prototype = null == e1 ? Object.create(null) : e1, new n;
                }
                n(), e1.exports = function(e1) {
                    return n(e1);
                };
            },
            737: (e1)=>{
                (e1.exports = function e1(t, n) {
                    var r;
                    if (null != t) return n = (n || "").replace(/[^&"<>\']/g, ""), r = "([&\"<>'])".replace(new RegExp("[" + n + "]", "g"), ""), t.replace(new RegExp(r, "g"), function(t, n) {
                        return e1.map[n];
                    });
                }).map = {
                    ">": "&gt;",
                    "<": "&lt;",
                    "'": "&apos;",
                    '"': "&quot;",
                    "&": "&amp;"
                };
            },
            4704: (e1, t, n)=>{
                "use strict";
                var r = n(4155);
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.codeFrameColumns = u, t.default = function(e1, t, n, i = {}) {
                    if (!l) {
                        l = !0;
                        const e1 = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
                        r.emitWarning ? r.emitWarning(e1, "DeprecationWarning") : (new Error(e1).name = "DeprecationWarning", console.warn(new Error(e1)));
                    }
                    return u(e1, {
                        start: {
                            column: n = Math.max(n, 0),
                            line: t
                        }
                    }, i);
                };
                var i = n(8530), s = function(e1, t) {
                    if (null === e1 || "object" != typeof e1 && "function" != typeof e1) return {
                        default: e1
                    };
                    var n = a(true);
                    if (n && n.has(e1)) return n.get(e1);
                    var r = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
                    for(var s in e1)if ("default" !== s && Object.prototype.hasOwnProperty.call(e1, s)) {
                        var o = i ? Object.getOwnPropertyDescriptor(e1, s) : null;
                        o && (o.get || o.set) ? Object.defineProperty(r, s, o) : r[s] = e1[s];
                    }
                    return r.default = e1, n && n.set(e1, r), r;
                }(n(2589));
                function a(e1) {
                    if ("function" != typeof WeakMap) return null;
                    var t = new WeakMap, n = new WeakMap;
                    return (a = function(e1) {
                        return e1 ? n : t;
                    })(e1);
                }
                let o, l = !1;
                const c = /\r\n|[\n\r\u2028\u2029]/;
                function u(e1, t, n = {}) {
                    const r = (n.highlightCode || n.forceColor) && (0, i.shouldHighlight)(n), a = n.forceColor ? (null != o || (o = new s.default.constructor({
                        enabled: !0,
                        level: 1
                    })), o) : s.default, l = function(e1) {
                        return {
                            gutter: e1.grey,
                            marker: e1.red.bold,
                            message: e1.red.bold
                        };
                    }(a), u1 = (e1, t)=>r ? e1(t) : t, p = e1.split(c), { start: h, end: d, markerLines: f } = function(e1, t, n) {
                        const r = Object.assign({
                            column: 0,
                            line: -1
                        }, e1.start), i = Object.assign({}, r, e1.end), { linesAbove: s = 2, linesBelow: a = 3 } = n || {}, o = r.line, l = r.column, c = i.line, u = i.column;
                        let p = Math.max(o - (s + 1), 0), h = Math.min(t.length, c + a);
                        -1 === o && (p = 0), -1 === c && (h = t.length);
                        const d = c - o, f = {};
                        if (d) for(let e1 = 0; e1 <= d; e1++){
                            const n = e1 + o;
                            if (l) if (0 === e1) {
                                const e1 = t[n - 1].length;
                                f[n] = [
                                    l,
                                    e1 - l + 1
                                ];
                            } else if (e1 === d) f[n] = [
                                0,
                                u
                            ];
                            else {
                                const r = t[n - e1].length;
                                f[n] = [
                                    0,
                                    r
                                ];
                            }
                            else f[n] = !0;
                        }
                        else f[o] = l === u ? !l || [
                            l,
                            0
                        ] : [
                            l,
                            u - l
                        ];
                        return {
                            start: p,
                            end: h,
                            markerLines: f
                        };
                    }(t, p, n), y = t.start && "number" == typeof t.start.column, m = String(d).length;
                    let T = (r ? (0, i.default)(e1, n) : e1).split(c, d).slice(h, d).map((e1, t)=>{
                        const r = h + 1 + t, i = ` ${` ${r}`.slice(-m)} |`, s = f[r], a = !f[r + 1];
                        if (s) {
                            let t = "";
                            if (Array.isArray(s)) {
                                const r = e1.slice(0, Math.max(s[0] - 1, 0)).replace(/[^\t]/g, " "), o = s[1] || 1;
                                t = [
                                    "\n ",
                                    u1(l.gutter, i.replace(/\d/g, " ")),
                                    " ",
                                    r,
                                    u1(l.marker, "^").repeat(o)
                                ].join(""), a && n.message && (t += " " + u1(l.message, n.message));
                            }
                            return [
                                u1(l.marker, ">"),
                                u1(l.gutter, i),
                                e1.length > 0 ? ` ${e1}` : "",
                                t
                            ].join("");
                        }
                        return ` ${u1(l.gutter, i)}${e1.length > 0 ? ` ${e1}` : ""}`;
                    }).join("\n");
                    return n.message && !y && (T = `${" ".repeat(m + 1)}${n.message}\n${T}`), r ? a.reset(T) : T;
                }
            },
            8726: (e1, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0, t.default = class {
                    constructor(e1){
                        this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this._canMarkIdName = !0, this._position = {
                            line: 1,
                            column: 0
                        }, this._sourcePosition = {
                            identifierName: void 0,
                            identifierNamePos: void 0,
                            line: void 0,
                            column: void 0,
                            filename: void 0
                        }, this._map = e1, this._allocQueue();
                    }
                    _allocQueue() {
                        const e1 = this._queue;
                        for(let t = 0; t < 16; t++)e1.push({
                            char: 0,
                            repeat: 1,
                            line: void 0,
                            column: void 0,
                            identifierName: void 0,
                            identifierNamePos: void 0,
                            filename: ""
                        });
                    }
                    _pushQueue(e1, t, n, r, i) {
                        const s = this._queueCursor;
                        s === this._queue.length && this._allocQueue();
                        const a = this._queue[s];
                        a.char = e1, a.repeat = t, a.line = n, a.column = r, a.filename = i, this._queueCursor++;
                    }
                    _popQueue() {
                        if (0 === this._queueCursor) throw new Error("Cannot pop from empty queue");
                        return this._queue[--this._queueCursor];
                    }
                    get() {
                        this._flush();
                        const e1 = this._map, t = {
                            code: (this._buf + this._str).trimRight(),
                            decodedMap: null == e1 ? void 0 : e1.getDecoded(),
                            get __mergedMap () {
                                return this.map;
                            },
                            get map () {
                                const n = e1 ? e1.get() : null;
                                return t.map = n, n;
                            },
                            set map (e){
                                Object.defineProperty(t, "map", {
                                    value: e,
                                    writable: !0
                                });
                            },
                            get rawMappings () {
                                const n = null == e1 ? void 0 : e1.getRawMappings();
                                return t.rawMappings = n, n;
                            },
                            set rawMappings (e){
                                Object.defineProperty(t, "rawMappings", {
                                    value: e,
                                    writable: !0
                                });
                            }
                        };
                        return t;
                    }
                    append(e1, t) {
                        this._flush(), this._append(e1, this._sourcePosition, t);
                    }
                    appendChar(e1) {
                        this._flush(), this._appendChar(e1, 1, this._sourcePosition);
                    }
                    queue(e1) {
                        if (10 === e1) for(; 0 !== this._queueCursor;){
                            const e1 = this._queue[this._queueCursor - 1].char;
                            if (32 !== e1 && 9 !== e1) break;
                            this._queueCursor--;
                        }
                        const t = this._sourcePosition;
                        this._pushQueue(e1, 1, t.line, t.column, t.filename);
                    }
                    queueIndentation(e1, t) {
                        this._pushQueue(e1, t, void 0, void 0, void 0);
                    }
                    _flush() {
                        const e1 = this._queueCursor, t = this._queue;
                        for(let n = 0; n < e1; n++){
                            const e1 = t[n];
                            this._appendChar(e1.char, e1.repeat, e1);
                        }
                        this._queueCursor = 0;
                    }
                    _appendChar(e1, t, n) {
                        this._last = e1, this._str += t > 1 ? String.fromCharCode(e1).repeat(t) : String.fromCharCode(e1), 10 !== e1 ? (this._mark(n.line, n.column, n.identifierName, n.identifierNamePos, n.filename), this._position.column += t) : (this._position.line++, this._position.column = 0), this._canMarkIdName && (n.identifierName = void 0, n.identifierNamePos = void 0);
                    }
                    _append(e1, t, n) {
                        const r = e1.length, i = this._position;
                        if (this._last = e1.charCodeAt(r - 1), ++this._appendCount > 4096 ? (this._str, this._buf += this._str, this._str = e1, this._appendCount = 0) : this._str += e1, !n && !this._map) return void (i.column += r);
                        const { column: s, identifierName: a, identifierNamePos: o, filename: l } = t;
                        let c = t.line;
                        null == a && null == o || !this._canMarkIdName || (t.identifierName = void 0, t.identifierNamePos = void 0);
                        let u = e1.indexOf("\n"), p = 0;
                        for(0 !== u && this._mark(c, s, a, o, l); -1 !== u;)i.line++, i.column = 0, p = u + 1, p < r && void 0 !== c && this._mark(++c, 0, null, null, l), u = e1.indexOf("\n", p);
                        i.column += r - p;
                    }
                    _mark(e1, t, n, r, i) {
                        var s;
                        null == (s = this._map) || s.mark(this._position, e1, t, n, r, i);
                    }
                    removeTrailingNewline() {
                        const e1 = this._queueCursor;
                        0 !== e1 && 10 === this._queue[e1 - 1].char && this._queueCursor--;
                    }
                    removeLastSemicolon() {
                        const e1 = this._queueCursor;
                        0 !== e1 && 59 === this._queue[e1 - 1].char && this._queueCursor--;
                    }
                    getLastChar() {
                        const e1 = this._queueCursor;
                        return 0 !== e1 ? this._queue[e1 - 1].char : this._last;
                    }
                    getNewlineCount() {
                        const e1 = this._queueCursor;
                        let t = 0;
                        if (0 === e1) return 10 === this._last ? 1 : 0;
                        for(let n = e1 - 1; n >= 0 && 10 === this._queue[n].char; n--)t++;
                        return t === e1 && 10 === this._last ? t + 1 : t;
                    }
                    endsWithCharAndNewline() {
                        const e1 = this._queue, t = this._queueCursor;
                        if (0 !== t) {
                            if (10 !== e1[t - 1].char) return;
                            return t > 1 ? e1[t - 2].char : this._last;
                        }
                    }
                    hasContent() {
                        return 0 !== this._queueCursor || !!this._last;
                    }
                    exactSource(e1, t) {
                        if (!this._map) return void t();
                        this.source("start", e1);
                        const n = e1.identifierName, r = this._sourcePosition;
                        n && (this._canMarkIdName = !1, r.identifierName = n), t(), n && (this._canMarkIdName = !0, r.identifierName = void 0, r.identifierNamePos = void 0), this.source("end", e1);
                    }
                    source(e1, t) {
                        this._map && this._normalizePosition(e1, t, 0);
                    }
                    sourceWithOffset(e1, t, n) {
                        this._map && this._normalizePosition(e1, t, n);
                    }
                    withSource(e1, t, n) {
                        this._map && this.source(e1, t), n();
                    }
                    _normalizePosition(e1, t, n) {
                        const r = t[e1], i = this._sourcePosition;
                        r && (i.line = r.line, i.column = Math.max(r.column + n, 0), i.filename = t.filename);
                    }
                    getCurrentColumn() {
                        const e1 = this._queue, t = this._queueCursor;
                        let n = -1, r = 0;
                        for(let i = 0; i < t; i++){
                            const t = e1[i];
                            10 === t.char && (n = r), r += t.repeat;
                        }
                        return -1 === n ? this._position.column + r : r - 1 - n;
                    }
                    getCurrentLine() {
                        let e1 = 0;
                        const t = this._queue;
                        for(let n = 0; n < this._queueCursor; n++)10 === t[n].char && e1++;
                        return this._position.line + e1;
                    }
                };
            },
            9230: (e1, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.BlockStatement = function(e1) {
                    var t;
                    this.tokenChar(123);
                    const n = null == (t = e1.directives) ? void 0 : t.length;
                    if (n) {
                        var r;
                        const t = e1.body.length ? 2 : 1;
                        this.printSequence(e1.directives, e1, {
                            indent: !0,
                            trailingCommentsLineOffset: t
                        }), null != (r = e1.directives[n - 1].trailingComments) && r.length || this.newline(t);
                    }
                    this.printSequence(e1.body, e1, {
                        indent: !0
                    }), this.rightBrace(e1);
                }, t.Directive = function(e1) {
                    this.print(e1.value, e1), this.semicolon();
                }, t.DirectiveLiteral = function(e1) {
                    const t = this.getPossibleRaw(e1);
                    if (!this.format.minified && void 0 !== t) return void this.token(t);
                    const { value: i } = e1;
                    if (r.test(i)) {
                        if (n.test(i)) throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
                        this.token(`'${i}'`);
                    } else this.token(`"${i}"`);
                }, t.File = function(e1) {
                    e1.program && this.print(e1.program.interpreter, e1), this.print(e1.program, e1);
                }, t.InterpreterDirective = function(e1) {
                    this.token(`#!${e1.value}`), this.newline(1, !0);
                }, t.Placeholder = function(e1) {
                    this.token("%%"), this.print(e1.name), this.token("%%"), "Statement" === e1.expectedNode && this.semicolon();
                }, t.Program = function(e1) {
                    var t;
                    this.noIndentInnerCommentsHere(), this.printInnerComments();
                    const n = null == (t = e1.directives) ? void 0 : t.length;
                    if (n) {
                        var r;
                        const t = e1.body.length ? 2 : 1;
                        this.printSequence(e1.directives, e1, {
                            trailingCommentsLineOffset: t
                        }), null != (r = e1.directives[n - 1].trailingComments) && r.length || this.newline(t);
                    }
                    this.printSequence(e1.body, e1);
                };
                const n = /(?:^|[^\\])(?:\\\\)*'/, r = /(?:^|[^\\])(?:\\\\)*"/;
            },
            695: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ClassAccessorProperty = function(e1) {
                    var t;
                    this.printJoin(e1.decorators, e1);
                    const n = null == (t = e1.key.loc) || null == (t = t.end) ? void 0 : t.line;
                    n && this.catchUp(n), this.tsPrintClassMemberModifiers(e1), this.word("accessor", !0), this.space(), e1.computed ? (this.tokenChar(91), this.print(e1.key, e1), this.tokenChar(93)) : (this._variance(e1), this.print(e1.key, e1)), e1.optional && this.tokenChar(63), e1.definite && this.tokenChar(33), this.print(e1.typeAnnotation, e1), e1.value && (this.space(), this.tokenChar(61), this.space(), this.print(e1.value, e1)), this.semicolon();
                }, t.ClassBody = function(e1) {
                    this.tokenChar(123), 0 === e1.body.length ? this.tokenChar(125) : (this.newline(), this.printSequence(e1.body, e1, {
                        indent: !0
                    }), this.endsWith(10) || this.newline(), this.rightBrace(e1));
                }, t.ClassExpression = t.ClassDeclaration = function(e1, t) {
                    (i(t) || s(t)) && this._shouldPrintDecoratorsBeforeExport(t) || this.printJoin(e1.decorators, e1), e1.declare && (this.word("declare"), this.space()), e1.abstract && (this.word("abstract"), this.space()), this.word("class"), e1.id && (this.space(), this.print(e1.id, e1)), this.print(e1.typeParameters, e1), e1.superClass && (this.space(), this.word("extends"), this.space(), this.print(e1.superClass, e1), this.print(e1.superTypeParameters, e1)), e1.implements && (this.space(), this.word("implements"), this.space(), this.printList(e1.implements, e1)), this.space(), this.print(e1.body, e1);
                }, t.ClassMethod = function(e1) {
                    this._classMethodHead(e1), this.space(), this.print(e1.body, e1);
                }, t.ClassPrivateMethod = function(e1) {
                    this._classMethodHead(e1), this.space(), this.print(e1.body, e1);
                }, t.ClassPrivateProperty = function(e1) {
                    this.printJoin(e1.decorators, e1), e1.static && (this.word("static"), this.space()), this.print(e1.key, e1), this.print(e1.typeAnnotation, e1), e1.value && (this.space(), this.tokenChar(61), this.space(), this.print(e1.value, e1)), this.semicolon();
                }, t.ClassProperty = function(e1) {
                    var t;
                    this.printJoin(e1.decorators, e1);
                    const n = null == (t = e1.key.loc) || null == (t = t.end) ? void 0 : t.line;
                    n && this.catchUp(n), this.tsPrintClassMemberModifiers(e1), e1.computed ? (this.tokenChar(91), this.print(e1.key, e1), this.tokenChar(93)) : (this._variance(e1), this.print(e1.key, e1)), e1.optional && this.tokenChar(63), e1.definite && this.tokenChar(33), this.print(e1.typeAnnotation, e1), e1.value && (this.space(), this.tokenChar(61), this.space(), this.print(e1.value, e1)), this.semicolon();
                }, t.StaticBlock = function(e1) {
                    this.word("static"), this.space(), this.tokenChar(123), 0 === e1.body.length ? this.tokenChar(125) : (this.newline(), this.printSequence(e1.body, e1, {
                        indent: !0
                    }), this.rightBrace(e1));
                }, t._classMethodHead = function(e1) {
                    var t;
                    this.printJoin(e1.decorators, e1);
                    const n = null == (t = e1.key.loc) || null == (t = t.end) ? void 0 : t.line;
                    n && this.catchUp(n), this.tsPrintClassMemberModifiers(e1), this._methodHead(e1);
                };
                var r = n(6067);
                const { isExportDefaultDeclaration: i, isExportNamedDeclaration: s } = r;
            },
            7240: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.LogicalExpression = t.BinaryExpression = t.AssignmentExpression = function(e1, t) {
                    const n = this.inForStatementInitCounter && "in" === e1.operator && !i.needsParens(e1, t);
                    n && this.tokenChar(40), this.print(e1.left, e1), this.space(), "in" === e1.operator || "instanceof" === e1.operator ? this.word(e1.operator) : this.token(e1.operator), this.space(), this.print(e1.right, e1), n && this.tokenChar(41);
                }, t.AssignmentPattern = function(e1) {
                    this.print(e1.left, e1), e1.left.optional && this.tokenChar(63), this.print(e1.left.typeAnnotation, e1), this.space(), this.tokenChar(61), this.space(), this.print(e1.right, e1);
                }, t.AwaitExpression = function(e1) {
                    this.word("await"), e1.argument && (this.space(), this.printTerminatorless(e1.argument, e1, !1));
                }, t.BindExpression = function(e1) {
                    this.print(e1.object, e1), this.token("::"), this.print(e1.callee, e1);
                }, t.CallExpression = function(e1) {
                    this.print(e1.callee, e1), this.print(e1.typeArguments, e1), this.print(e1.typeParameters, e1), this.tokenChar(40), this.printList(e1.arguments, e1), this.rightParens(e1);
                }, t.ConditionalExpression = function(e1) {
                    this.print(e1.test, e1), this.space(), this.tokenChar(63), this.space(), this.print(e1.consequent, e1), this.space(), this.tokenChar(58), this.space(), this.print(e1.alternate, e1);
                }, t.Decorator = function(e1) {
                    this.tokenChar(64);
                    const { expression: t } = e1;
                    !function(e1) {
                        return "ParenthesizedExpression" !== e1.type && !c("CallExpression" === e1.type ? e1.callee : e1);
                    }(t) ? this.print(t, e1) : (this.tokenChar(40), this.print(t, e1), this.tokenChar(41)), this.newline();
                }, t.DoExpression = function(e1) {
                    e1.async && (this.word("async", !0), this.space()), this.word("do"), this.space(), this.print(e1.body, e1);
                }, t.EmptyStatement = function() {
                    this.semicolon(!0);
                }, t.ExpressionStatement = function(e1) {
                    this.print(e1.expression, e1), this.semicolon();
                }, t.Import = function() {
                    this.word("import");
                }, t.MemberExpression = function(e1) {
                    if (this.print(e1.object, e1), !e1.computed && o(e1.property)) throw new TypeError("Got a MemberExpression for MemberExpression property");
                    let t = e1.computed;
                    a(e1.property) && "number" == typeof e1.property.value && (t = !0), t ? (this.tokenChar(91), this.print(e1.property, e1), this.tokenChar(93)) : (this.tokenChar(46), this.print(e1.property, e1));
                }, t.MetaProperty = function(e1) {
                    this.print(e1.meta, e1), this.tokenChar(46), this.print(e1.property, e1);
                }, t.ModuleExpression = function(e1) {
                    this.word("module", !0), this.space(), this.tokenChar(123), this.indent();
                    const { body: t } = e1;
                    (t.body.length || t.directives.length) && this.newline(), this.print(t, e1), this.dedent(), this.rightBrace(e1);
                }, t.NewExpression = function(e1, t) {
                    this.word("new"), this.space(), this.print(e1.callee, e1), (!this.format.minified || 0 !== e1.arguments.length || e1.optional || s(t, {
                        callee: e1
                    }) || o(t) || l(t)) && (this.print(e1.typeArguments, e1), this.print(e1.typeParameters, e1), e1.optional && this.token("?."), this.tokenChar(40), this.printList(e1.arguments, e1), this.rightParens(e1));
                }, t.OptionalCallExpression = function(e1) {
                    this.print(e1.callee, e1), this.print(e1.typeParameters, e1), e1.optional && this.token("?."), this.print(e1.typeArguments, e1), this.tokenChar(40), this.printList(e1.arguments, e1), this.rightParens(e1);
                }, t.OptionalMemberExpression = function(e1) {
                    let { computed: t } = e1;
                    const { optional: n, property: r } = e1;
                    if (this.print(e1.object, e1), !t && o(r)) throw new TypeError("Got a MemberExpression for MemberExpression property");
                    a(r) && "number" == typeof r.value && (t = !0), n && this.token("?."), t ? (this.tokenChar(91), this.print(r, e1), this.tokenChar(93)) : (n || this.tokenChar(46), this.print(r, e1));
                }, t.ParenthesizedExpression = function(e1) {
                    this.tokenChar(40), this.print(e1.expression, e1), this.rightParens(e1);
                }, t.PrivateName = function(e1) {
                    this.tokenChar(35), this.print(e1.id, e1);
                }, t.SequenceExpression = function(e1) {
                    this.printList(e1.expressions, e1);
                }, t.Super = function() {
                    this.word("super");
                }, t.ThisExpression = function() {
                    this.word("this");
                }, t.UnaryExpression = function(e1) {
                    const { operator: t } = e1;
                    "void" === t || "delete" === t || "typeof" === t || "throw" === t ? (this.word(t), this.space()) : this.token(t), this.print(e1.argument, e1);
                }, t.UpdateExpression = function(e1) {
                    e1.prefix ? (this.token(e1.operator), this.print(e1.argument, e1)) : (this.printTerminatorless(e1.argument, e1, !0), this.token(e1.operator));
                }, t.V8IntrinsicIdentifier = function(e1) {
                    this.tokenChar(37), this.word(e1.name);
                }, t.YieldExpression = function(e1) {
                    this.word("yield", !0), e1.delegate ? (this.tokenChar(42), e1.argument && (this.space(), this.print(e1.argument, e1))) : e1.argument && (this.space(), this.printTerminatorless(e1.argument, e1, !1));
                }, t._shouldPrintDecoratorsBeforeExport = function(e1) {
                    return "boolean" == typeof this.format.decoratorsBeforeExport ? this.format.decoratorsBeforeExport : "number" == typeof e1.start && e1.start === e1.declaration.start;
                };
                var r = n(6067), i = n(7533);
                const { isCallExpression: s, isLiteral: a, isMemberExpression: o, isNewExpression: l } = r;
                function c(e1) {
                    switch(e1.type){
                        case "Identifier":
                            return !0;
                        case "MemberExpression":
                            return !e1.computed && "Identifier" === e1.property.type && c(e1.object);
                        default:
                            return !1;
                    }
                }
            },
            4735: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.AnyTypeAnnotation = function() {
                    this.word("any");
                }, t.ArrayTypeAnnotation = function(e1) {
                    this.print(e1.elementType, e1, !0), this.tokenChar(91), this.tokenChar(93);
                }, t.BooleanLiteralTypeAnnotation = function(e1) {
                    this.word(e1.value ? "true" : "false");
                }, t.BooleanTypeAnnotation = function() {
                    this.word("boolean");
                }, t.DeclareClass = function(e1, t) {
                    a(t) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(e1);
                }, t.DeclareExportAllDeclaration = function(e1) {
                    this.word("declare"), this.space(), i.ExportAllDeclaration.call(this, e1);
                }, t.DeclareExportDeclaration = function(e1) {
                    this.word("declare"), this.space(), this.word("export"), this.space(), e1.default && (this.word("default"), this.space()), p.call(this, e1);
                }, t.DeclareFunction = function(e1, t) {
                    a(t) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(e1.id, e1), this.print(e1.id.typeAnnotation.typeAnnotation, e1), e1.predicate && (this.space(), this.print(e1.predicate, e1)), this.semicolon();
                }, t.DeclareInterface = function(e1) {
                    this.word("declare"), this.space(), this.InterfaceDeclaration(e1);
                }, t.DeclareModule = function(e1) {
                    this.word("declare"), this.space(), this.word("module"), this.space(), this.print(e1.id, e1), this.space(), this.print(e1.body, e1);
                }, t.DeclareModuleExports = function(e1) {
                    this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(e1.typeAnnotation, e1);
                }, t.DeclareOpaqueType = function(e1, t) {
                    a(t) || (this.word("declare"), this.space()), this.OpaqueType(e1);
                }, t.DeclareTypeAlias = function(e1) {
                    this.word("declare"), this.space(), this.TypeAlias(e1);
                }, t.DeclareVariable = function(e1, t) {
                    a(t) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(e1.id, e1), this.print(e1.id.typeAnnotation, e1), this.semicolon();
                }, t.DeclaredPredicate = function(e1) {
                    this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(e1.value, e1), this.tokenChar(41);
                }, t.EmptyTypeAnnotation = function() {
                    this.word("empty");
                }, t.EnumBooleanBody = function(e1) {
                    const { explicitType: t } = e1;
                    l(this, "boolean", t), c(this, e1);
                }, t.EnumBooleanMember = function(e1) {
                    u(this, e1);
                }, t.EnumDeclaration = function(e1) {
                    const { id: t, body: n } = e1;
                    this.word("enum"), this.space(), this.print(t, e1), this.print(n, e1);
                }, t.EnumDefaultedMember = function(e1) {
                    const { id: t } = e1;
                    this.print(t, e1), this.tokenChar(44);
                }, t.EnumNumberBody = function(e1) {
                    const { explicitType: t } = e1;
                    l(this, "number", t), c(this, e1);
                }, t.EnumNumberMember = function(e1) {
                    u(this, e1);
                }, t.EnumStringBody = function(e1) {
                    const { explicitType: t } = e1;
                    l(this, "string", t), c(this, e1);
                }, t.EnumStringMember = function(e1) {
                    u(this, e1);
                }, t.EnumSymbolBody = function(e1) {
                    l(this, "symbol", !0), c(this, e1);
                }, t.ExistsTypeAnnotation = function() {
                    this.tokenChar(42);
                }, t.FunctionTypeAnnotation = function(e1, t) {
                    this.print(e1.typeParameters, e1), this.tokenChar(40), e1.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(e1.this.typeAnnotation, e1), (e1.params.length || e1.rest) && (this.tokenChar(44), this.space())), this.printList(e1.params, e1), e1.rest && (e1.params.length && (this.tokenChar(44), this.space()), this.token("..."), this.print(e1.rest, e1)), this.tokenChar(41);
                    const n = null == t ? void 0 : t.type;
                    null != n && ("ObjectTypeCallProperty" === n || "ObjectTypeInternalSlot" === n || "DeclareFunction" === n || "ObjectTypeProperty" === n && t.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(e1.returnType, e1);
                }, t.FunctionTypeParam = function(e1) {
                    this.print(e1.name, e1), e1.optional && this.tokenChar(63), e1.name && (this.tokenChar(58), this.space()), this.print(e1.typeAnnotation, e1);
                }, t.IndexedAccessType = function(e1) {
                    this.print(e1.objectType, e1, !0), this.tokenChar(91), this.print(e1.indexType, e1), this.tokenChar(93);
                }, t.InferredPredicate = function() {
                    this.tokenChar(37), this.word("checks");
                }, t.InterfaceDeclaration = function(e1) {
                    this.word("interface"), this.space(), this._interfaceish(e1);
                }, t.GenericTypeAnnotation = t.ClassImplements = t.InterfaceExtends = function(e1) {
                    this.print(e1.id, e1), this.print(e1.typeParameters, e1, !0);
                }, t.InterfaceTypeAnnotation = function(e1) {
                    var t;
                    this.word("interface"), null != (t = e1.extends) && t.length && (this.space(), this.word("extends"), this.space(), this.printList(e1.extends, e1)), this.space(), this.print(e1.body, e1);
                }, t.IntersectionTypeAnnotation = function(e1) {
                    this.printJoin(e1.types, e1, {
                        separator: h
                    });
                }, t.MixedTypeAnnotation = function() {
                    this.word("mixed");
                }, t.NullLiteralTypeAnnotation = function() {
                    this.word("null");
                }, t.NullableTypeAnnotation = function(e1) {
                    this.tokenChar(63), this.print(e1.typeAnnotation, e1);
                }, Object.defineProperty(t, "NumberLiteralTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return s.NumericLiteral;
                    }
                }), t.NumberTypeAnnotation = function() {
                    this.word("number");
                }, t.ObjectTypeAnnotation = function(e1) {
                    e1.exact ? this.token("{|") : this.tokenChar(123);
                    const t = [
                        ...e1.properties,
                        ...e1.callProperties || [],
                        ...e1.indexers || [],
                        ...e1.internalSlots || []
                    ];
                    t.length && (this.newline(), this.space(), this.printJoin(t, e1, {
                        addNewlines (e1) {
                            if (e1 && !t[0]) return 1;
                        },
                        indent: !0,
                        statement: !0,
                        iterator: ()=>{
                            (1 !== t.length || e1.inexact) && (this.tokenChar(44), this.space());
                        }
                    }), this.space()), e1.inexact && (this.indent(), this.token("..."), t.length && this.newline(), this.dedent()), e1.exact ? this.token("|}") : this.tokenChar(125);
                }, t.ObjectTypeCallProperty = function(e1) {
                    e1.static && (this.word("static"), this.space()), this.print(e1.value, e1);
                }, t.ObjectTypeIndexer = function(e1) {
                    e1.static && (this.word("static"), this.space()), this._variance(e1), this.tokenChar(91), e1.id && (this.print(e1.id, e1), this.tokenChar(58), this.space()), this.print(e1.key, e1), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(e1.value, e1);
                }, t.ObjectTypeInternalSlot = function(e1) {
                    e1.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(e1.id, e1), this.tokenChar(93), this.tokenChar(93), e1.optional && this.tokenChar(63), e1.method || (this.tokenChar(58), this.space()), this.print(e1.value, e1);
                }, t.ObjectTypeProperty = function(e1) {
                    e1.proto && (this.word("proto"), this.space()), e1.static && (this.word("static"), this.space()), "get" !== e1.kind && "set" !== e1.kind || (this.word(e1.kind), this.space()), this._variance(e1), this.print(e1.key, e1), e1.optional && this.tokenChar(63), e1.method || (this.tokenChar(58), this.space()), this.print(e1.value, e1);
                }, t.ObjectTypeSpreadProperty = function(e1) {
                    this.token("..."), this.print(e1.argument, e1);
                }, t.OpaqueType = function(e1) {
                    this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(e1.id, e1), this.print(e1.typeParameters, e1), e1.supertype && (this.tokenChar(58), this.space(), this.print(e1.supertype, e1)), e1.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(e1.impltype, e1)), this.semicolon();
                }, t.OptionalIndexedAccessType = function(e1) {
                    this.print(e1.objectType, e1), e1.optional && this.token("?."), this.tokenChar(91), this.print(e1.indexType, e1), this.tokenChar(93);
                }, t.QualifiedTypeIdentifier = function(e1) {
                    this.print(e1.qualification, e1), this.tokenChar(46), this.print(e1.id, e1);
                }, Object.defineProperty(t, "StringLiteralTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return s.StringLiteral;
                    }
                }), t.StringTypeAnnotation = function() {
                    this.word("string");
                }, t.SymbolTypeAnnotation = function() {
                    this.word("symbol");
                }, t.ThisTypeAnnotation = function() {
                    this.word("this");
                }, t.TupleTypeAnnotation = function(e1) {
                    this.tokenChar(91), this.printList(e1.types, e1), this.tokenChar(93);
                }, t.TypeAlias = function(e1) {
                    this.word("type"), this.space(), this.print(e1.id, e1), this.print(e1.typeParameters, e1), this.space(), this.tokenChar(61), this.space(), this.print(e1.right, e1), this.semicolon();
                }, t.TypeAnnotation = function(e1) {
                    this.tokenChar(58), this.space(), e1.optional && this.tokenChar(63), this.print(e1.typeAnnotation, e1);
                }, t.TypeCastExpression = function(e1) {
                    this.tokenChar(40), this.print(e1.expression, e1), this.print(e1.typeAnnotation, e1), this.tokenChar(41);
                }, t.TypeParameter = function(e1) {
                    this._variance(e1), this.word(e1.name), e1.bound && this.print(e1.bound, e1), e1.default && (this.space(), this.tokenChar(61), this.space(), this.print(e1.default, e1));
                }, t.TypeParameterDeclaration = t.TypeParameterInstantiation = function(e1) {
                    this.tokenChar(60), this.printList(e1.params, e1, {}), this.tokenChar(62);
                }, t.TypeofTypeAnnotation = function(e1) {
                    this.word("typeof"), this.space(), this.print(e1.argument, e1);
                }, t.UnionTypeAnnotation = function(e1) {
                    this.printJoin(e1.types, e1, {
                        separator: d
                    });
                }, t.Variance = function(e1) {
                    "plus" === e1.kind ? this.tokenChar(43) : this.tokenChar(45);
                }, t.VoidTypeAnnotation = function() {
                    this.word("void");
                }, t._interfaceish = function(e1) {
                    var t, n, r;
                    (this.print(e1.id, e1), this.print(e1.typeParameters, e1), null != (t = e1.extends) && t.length && (this.space(), this.word("extends"), this.space(), this.printList(e1.extends, e1)), "DeclareClass" === e1.type) && (null != (n = e1.mixins) && n.length && (this.space(), this.word("mixins"), this.space(), this.printList(e1.mixins, e1)), null != (r = e1.implements) && r.length && (this.space(), this.word("implements"), this.space(), this.printList(e1.implements, e1)));
                    this.space(), this.print(e1.body, e1);
                }, t._variance = function(e1) {
                    var t;
                    const n = null == (t = e1.variance) ? void 0 : t.kind;
                    null != n && ("plus" === n ? this.tokenChar(43) : "minus" === n && this.tokenChar(45));
                };
                var r = n(6067), i = n(4272), s = n(7585);
                const { isDeclareExportDeclaration: a, isStatement: o } = r;
                function l(e1, t, n) {
                    n && (e1.space(), e1.word("of"), e1.space(), e1.word(t)), e1.space();
                }
                function c(e1, t) {
                    const { members: n } = t;
                    e1.token("{"), e1.indent(), e1.newline();
                    for (const r of n)e1.print(r, t), e1.newline();
                    t.hasUnknownMembers && (e1.token("..."), e1.newline()), e1.dedent(), e1.token("}");
                }
                function u(e1, t) {
                    const { id: n, init: r } = t;
                    e1.print(n, t), e1.space(), e1.token("="), e1.space(), e1.print(r, t), e1.token(",");
                }
                function p(e1) {
                    if (e1.declaration) {
                        const t = e1.declaration;
                        this.print(t, e1), o(t) || this.semicolon();
                    } else this.tokenChar(123), e1.specifiers.length && (this.space(), this.printList(e1.specifiers, e1), this.space()), this.tokenChar(125), e1.source && (this.space(), this.word("from"), this.space(), this.print(e1.source, e1)), this.semicolon();
                }
                function h() {
                    this.space(), this.tokenChar(38), this.space();
                }
                function d() {
                    this.space(), this.tokenChar(124), this.space();
                }
            },
            4236: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var r = n(9716);
                Object.keys(r).forEach(function(e1) {
                    "default" !== e1 && "__esModule" !== e1 && (e1 in t && t[e1] === r[e1] || Object.defineProperty(t, e1, {
                        enumerable: !0,
                        get: function() {
                            return r[e1];
                        }
                    }));
                });
                var i = n(7240);
                Object.keys(i).forEach(function(e1) {
                    "default" !== e1 && "__esModule" !== e1 && (e1 in t && t[e1] === i[e1] || Object.defineProperty(t, e1, {
                        enumerable: !0,
                        get: function() {
                            return i[e1];
                        }
                    }));
                });
                var s = n(5448);
                Object.keys(s).forEach(function(e1) {
                    "default" !== e1 && "__esModule" !== e1 && (e1 in t && t[e1] === s[e1] || Object.defineProperty(t, e1, {
                        enumerable: !0,
                        get: function() {
                            return s[e1];
                        }
                    }));
                });
                var a = n(695);
                Object.keys(a).forEach(function(e1) {
                    "default" !== e1 && "__esModule" !== e1 && (e1 in t && t[e1] === a[e1] || Object.defineProperty(t, e1, {
                        enumerable: !0,
                        get: function() {
                            return a[e1];
                        }
                    }));
                });
                var o = n(7011);
                Object.keys(o).forEach(function(e1) {
                    "default" !== e1 && "__esModule" !== e1 && (e1 in t && t[e1] === o[e1] || Object.defineProperty(t, e1, {
                        enumerable: !0,
                        get: function() {
                            return o[e1];
                        }
                    }));
                });
                var l = n(4272);
                Object.keys(l).forEach(function(e1) {
                    "default" !== e1 && "__esModule" !== e1 && (e1 in t && t[e1] === l[e1] || Object.defineProperty(t, e1, {
                        enumerable: !0,
                        get: function() {
                            return l[e1];
                        }
                    }));
                });
                var c = n(7585);
                Object.keys(c).forEach(function(e1) {
                    "default" !== e1 && "__esModule" !== e1 && (e1 in t && t[e1] === c[e1] || Object.defineProperty(t, e1, {
                        enumerable: !0,
                        get: function() {
                            return c[e1];
                        }
                    }));
                });
                var u = n(4735);
                Object.keys(u).forEach(function(e1) {
                    "default" !== e1 && "__esModule" !== e1 && (e1 in t && t[e1] === u[e1] || Object.defineProperty(t, e1, {
                        enumerable: !0,
                        get: function() {
                            return u[e1];
                        }
                    }));
                });
                var p = n(9230);
                Object.keys(p).forEach(function(e1) {
                    "default" !== e1 && "__esModule" !== e1 && (e1 in t && t[e1] === p[e1] || Object.defineProperty(t, e1, {
                        enumerable: !0,
                        get: function() {
                            return p[e1];
                        }
                    }));
                });
                var h = n(7878);
                Object.keys(h).forEach(function(e1) {
                    "default" !== e1 && "__esModule" !== e1 && (e1 in t && t[e1] === h[e1] || Object.defineProperty(t, e1, {
                        enumerable: !0,
                        get: function() {
                            return h[e1];
                        }
                    }));
                });
                var d = n(5447);
                Object.keys(d).forEach(function(e1) {
                    "default" !== e1 && "__esModule" !== e1 && (e1 in t && t[e1] === d[e1] || Object.defineProperty(t, e1, {
                        enumerable: !0,
                        get: function() {
                            return d[e1];
                        }
                    }));
                });
            },
            7878: (e1, t)=>{
                "use strict";
                function n() {
                    this.space();
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.JSXAttribute = function(e1) {
                    this.print(e1.name, e1), e1.value && (this.tokenChar(61), this.print(e1.value, e1));
                }, t.JSXClosingElement = function(e1) {
                    this.token("</"), this.print(e1.name, e1), this.tokenChar(62);
                }, t.JSXClosingFragment = function() {
                    this.token("</"), this.tokenChar(62);
                }, t.JSXElement = function(e1) {
                    const t = e1.openingElement;
                    if (this.print(t, e1), !t.selfClosing) {
                        this.indent();
                        for (const t of e1.children)this.print(t, e1);
                        this.dedent(), this.print(e1.closingElement, e1);
                    }
                }, t.JSXEmptyExpression = function() {
                    this.printInnerComments();
                }, t.JSXExpressionContainer = function(e1) {
                    this.tokenChar(123), this.print(e1.expression, e1), this.tokenChar(125);
                }, t.JSXFragment = function(e1) {
                    this.print(e1.openingFragment, e1), this.indent();
                    for (const t of e1.children)this.print(t, e1);
                    this.dedent(), this.print(e1.closingFragment, e1);
                }, t.JSXIdentifier = function(e1) {
                    this.word(e1.name);
                }, t.JSXMemberExpression = function(e1) {
                    this.print(e1.object, e1), this.tokenChar(46), this.print(e1.property, e1);
                }, t.JSXNamespacedName = function(e1) {
                    this.print(e1.namespace, e1), this.tokenChar(58), this.print(e1.name, e1);
                }, t.JSXOpeningElement = function(e1) {
                    this.tokenChar(60), this.print(e1.name, e1), this.print(e1.typeParameters, e1), e1.attributes.length > 0 && (this.space(), this.printJoin(e1.attributes, e1, {
                        separator: n
                    })), e1.selfClosing ? (this.space(), this.token("/>")) : this.tokenChar(62);
                }, t.JSXOpeningFragment = function() {
                    this.tokenChar(60), this.tokenChar(62);
                }, t.JSXSpreadAttribute = function(e1) {
                    this.tokenChar(123), this.token("..."), this.print(e1.argument, e1), this.tokenChar(125);
                }, t.JSXSpreadChild = function(e1) {
                    this.tokenChar(123), this.token("..."), this.print(e1.expression, e1), this.tokenChar(125);
                }, t.JSXText = function(e1) {
                    const t = this.getPossibleRaw(e1);
                    void 0 !== t ? this.token(t, !0) : this.token(e1.value, !0);
                };
            },
            7011: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ArrowFunctionExpression = function(e1, t) {
                    let n;
                    e1.async && (this.word("async", !0), this.space()), this.format.retainLines || 1 !== e1.params.length || !i(n = e1.params[0]) || function(e1, t) {
                        var n, r;
                        return !!(e1.typeParameters || e1.returnType || e1.predicate || t.typeAnnotation || t.optional || null != (n = t.leadingComments) && n.length || null != (r = t.trailingComments) && r.length);
                    }(e1, n) ? this._params(e1, void 0, t) : this.print(n, e1, !0), this._predicate(e1, !0), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.print(e1.body, e1);
                }, t.FunctionDeclaration = t.FunctionExpression = function(e1, t) {
                    this._functionHead(e1, t), this.space(), this.print(e1.body, e1);
                }, t._functionHead = function(e1, t) {
                    e1.async && (this.word("async"), this._endsWithInnerRaw = !1, this.space()), this.word("function"), e1.generator && (this._endsWithInnerRaw = !1, this.tokenChar(42)), this.space(), e1.id && this.print(e1.id, e1), this._params(e1, e1.id, t), "TSDeclareFunction" !== e1.type && this._predicate(e1);
                }, t._methodHead = function(e1) {
                    const t = e1.kind, n = e1.key;
                    "get" !== t && "set" !== t || (this.word(t), this.space()), e1.async && (this.word("async", !0), this.space()), "method" !== t && "init" !== t || e1.generator && this.tokenChar(42), e1.computed ? (this.tokenChar(91), this.print(n, e1), this.tokenChar(93)) : this.print(n, e1), e1.optional && this.tokenChar(63), this._params(e1, e1.computed && "StringLiteral" !== e1.key.type ? void 0 : e1.key, void 0);
                }, t._param = function(e1, t) {
                    this.printJoin(e1.decorators, e1), this.print(e1, t), e1.optional && this.tokenChar(63), this.print(e1.typeAnnotation, e1);
                }, t._parameters = function(e1, t) {
                    const n = e1.length;
                    for(let r = 0; r < n; r++)this._param(e1[r], t), r < e1.length - 1 && (this.tokenChar(44), this.space());
                }, t._params = function(e1, t, n) {
                    this.print(e1.typeParameters, e1);
                    const r = s.call(this, t, n);
                    r && this.sourceIdentifierName(r.name, r.pos), this.tokenChar(40), this._parameters(e1.params, e1), this.tokenChar(41);
                    const i = "ArrowFunctionExpression" === e1.type;
                    this.print(e1.returnType, e1, i), this._noLineTerminator = i;
                }, t._predicate = function(e1, t) {
                    e1.predicate && (e1.returnType || this.tokenChar(58), this.space(), this.print(e1.predicate, e1, t));
                };
                var r = n(6067);
                const { isIdentifier: i } = r;
                function s(e1, t) {
                    let n, r = e1;
                    if (!r && t) {
                        const e1 = t.type;
                        "VariableDeclarator" === e1 ? r = t.id : "AssignmentExpression" === e1 || "AssignmentPattern" === e1 ? r = t.left : "ObjectProperty" === e1 || "ClassProperty" === e1 ? t.computed && "StringLiteral" !== t.key.type || (r = t.key) : "ClassPrivateProperty" !== e1 && "ClassAccessorProperty" !== e1 || (r = t.key);
                    }
                    if (r) {
                        var i, s;
                        if ("Identifier" === r.type) n = {
                            pos: null == (i = r.loc) ? void 0 : i.start,
                            name: (null == (s = r.loc) ? void 0 : s.identifierName) || r.name
                        };
                        else if ("PrivateName" === r.type) {
                            var a;
                            n = {
                                pos: null == (a = r.loc) ? void 0 : a.start,
                                name: "#" + r.id.name
                            };
                        } else if ("StringLiteral" === r.type) {
                            var o;
                            n = {
                                pos: null == (o = r.loc) ? void 0 : o.start,
                                name: r.value
                            };
                        }
                        return n;
                    }
                }
            },
            4272: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ExportAllDeclaration = function(e1) {
                    var t, n;
                    this.word("export"), this.space(), "type" === e1.exportKind && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.word("from"), this.space(), null != (t = e1.attributes) && t.length || null != (n = e1.assertions) && n.length ? (this.print(e1.source, e1, !0), this.space(), this._printAttributes(e1)) : this.print(e1.source, e1), this.semicolon();
                }, t.ExportDefaultDeclaration = function(e1) {
                    p(this, e1), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space();
                    const t = e1.declaration;
                    this.print(t, e1), c(t) || this.semicolon();
                }, t.ExportDefaultSpecifier = function(e1) {
                    this.print(e1.exported, e1);
                }, t.ExportNamedDeclaration = function(e1) {
                    if (p(this, e1), this.word("export"), this.space(), e1.declaration) {
                        const t = e1.declaration;
                        this.print(t, e1), c(t) || this.semicolon();
                    } else {
                        "type" === e1.exportKind && (this.word("type"), this.space());
                        const r = e1.specifiers.slice(0);
                        let i = !1;
                        for(;;){
                            const t = r[0];
                            if (!s(t) && !a(t)) break;
                            i = !0, this.print(r.shift(), e1), r.length && (this.tokenChar(44), this.space());
                        }
                        var t, n;
                        (r.length || !r.length && !i) && (this.tokenChar(123), r.length && (this.space(), this.printList(r, e1), this.space()), this.tokenChar(125)), e1.source && (this.space(), this.word("from"), this.space(), null != (t = e1.attributes) && t.length || null != (n = e1.assertions) && n.length ? (this.print(e1.source, e1, !0), this.space(), this._printAttributes(e1)) : this.print(e1.source, e1)), this.semicolon();
                    }
                }, t.ExportNamespaceSpecifier = function(e1) {
                    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e1.exported, e1);
                }, t.ExportSpecifier = function(e1) {
                    "type" === e1.exportKind && (this.word("type"), this.space()), this.print(e1.local, e1), e1.exported && e1.local.name !== e1.exported.name && (this.space(), this.word("as"), this.space(), this.print(e1.exported, e1));
                }, t.ImportAttribute = function(e1) {
                    this.print(e1.key), this.tokenChar(58), this.space(), this.print(e1.value);
                }, t.ImportDeclaration = function(e1) {
                    var t, n;
                    this.word("import"), this.space();
                    const r = "type" === e1.importKind || "typeof" === e1.importKind;
                    r ? (this.noIndentInnerCommentsHere(), this.word(e1.importKind), this.space()) : e1.module && (this.noIndentInnerCommentsHere(), this.word("module"), this.space());
                    const i = e1.specifiers.slice(0), s = !!i.length;
                    for(; s;){
                        const t = i[0];
                        if (!o(t) && !l(t)) break;
                        this.print(i.shift(), e1), i.length && (this.tokenChar(44), this.space());
                    }
                    i.length ? (this.tokenChar(123), this.space(), this.printList(i, e1), this.space(), this.tokenChar(125)) : r && !s && (this.tokenChar(123), this.tokenChar(125)), (s || r) && (this.space(), this.word("from"), this.space()), null != (t = e1.attributes) && t.length || null != (n = e1.assertions) && n.length ? (this.print(e1.source, e1, !0), this.space(), this._printAttributes(e1)) : this.print(e1.source, e1), this.semicolon();
                }, t.ImportDefaultSpecifier = function(e1) {
                    this.print(e1.local, e1);
                }, t.ImportNamespaceSpecifier = function(e1) {
                    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e1.local, e1);
                }, t.ImportSpecifier = function(e1) {
                    "type" !== e1.importKind && "typeof" !== e1.importKind || (this.word(e1.importKind), this.space()), this.print(e1.imported, e1), e1.local && e1.local.name !== e1.imported.name && (this.space(), this.word("as"), this.space(), this.print(e1.local, e1));
                }, t._printAttributes = function(e1) {
                    const { importAttributesKeyword: t } = this.format, { attributes: n, assertions: r } = e1;
                    !n || t || u || (u = !0, console.warn('You are using import attributes, without specifying the desired output syntax.\nPlease specify the "importAttributesKeyword" generator option, whose value can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\n - "assert"      : `import { a } from "b" assert { type: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
                    const i = "assert" === t || !t && r;
                    this.word(i ? "assert" : "with"), this.space(), i || "with" === t ? (this.tokenChar(123), this.space(), this.printList(n || r, e1), this.space(), this.tokenChar(125)) : this.printList(n || r, e1);
                };
                var r = n(6067);
                const { isClassDeclaration: i, isExportDefaultSpecifier: s, isExportNamespaceSpecifier: a, isImportDefaultSpecifier: o, isImportNamespaceSpecifier: l, isStatement: c } = r;
                let u = !1;
                function p(e1, t) {
                    i(t.declaration) && e1._shouldPrintDecoratorsBeforeExport(t) && e1.printJoin(t.declaration.decorators, t);
                }
            },
            5448: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.BreakStatement = function(e1) {
                    this.word("break"), h(this, e1.label, e1, !0);
                }, t.CatchClause = function(e1) {
                    this.word("catch"), this.space(), e1.param && (this.tokenChar(40), this.print(e1.param, e1), this.print(e1.param.typeAnnotation, e1), this.tokenChar(41), this.space()), this.print(e1.body, e1);
                }, t.ContinueStatement = function(e1) {
                    this.word("continue"), h(this, e1.label, e1, !0);
                }, t.DebuggerStatement = function() {
                    this.word("debugger"), this.semicolon();
                }, t.DoWhileStatement = function(e1) {
                    this.word("do"), this.space(), this.print(e1.body, e1), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(e1.test, e1), this.tokenChar(41), this.semicolon();
                }, t.ForOfStatement = t.ForInStatement = void 0, t.ForStatement = function(e1) {
                    this.word("for"), this.space(), this.tokenChar(40), this.inForStatementInitCounter++, this.print(e1.init, e1), this.inForStatementInitCounter--, this.tokenChar(59), e1.test && (this.space(), this.print(e1.test, e1)), this.tokenChar(59), e1.update && (this.space(), this.print(e1.update, e1)), this.tokenChar(41), this.printBlock(e1);
                }, t.IfStatement = function(e1) {
                    this.word("if"), this.space(), this.tokenChar(40), this.print(e1.test, e1), this.tokenChar(41), this.space();
                    const t = e1.alternate && a(l(e1.consequent));
                    t && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(e1.consequent, e1), t && (this.dedent(), this.newline(), this.tokenChar(125)), e1.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(e1.alternate, e1));
                }, t.LabeledStatement = function(e1) {
                    this.print(e1.label, e1), this.tokenChar(58), this.space(), this.print(e1.body, e1);
                }, t.ReturnStatement = function(e1) {
                    this.word("return"), h(this, e1.argument, e1, !1);
                }, t.SwitchCase = function(e1) {
                    e1.test ? (this.word("case"), this.space(), this.print(e1.test, e1), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), e1.consequent.length && (this.newline(), this.printSequence(e1.consequent, e1, {
                        indent: !0
                    }));
                }, t.SwitchStatement = function(e1) {
                    this.word("switch"), this.space(), this.tokenChar(40), this.print(e1.discriminant, e1), this.tokenChar(41), this.space(), this.tokenChar(123), this.printSequence(e1.cases, e1, {
                        indent: !0,
                        addNewlines (t, n) {
                            if (!t && e1.cases[e1.cases.length - 1] === n) return -1;
                        }
                    }), this.rightBrace(e1);
                }, t.ThrowStatement = function(e1) {
                    this.word("throw"), h(this, e1.argument, e1, !1);
                }, t.TryStatement = function(e1) {
                    this.word("try"), this.space(), this.print(e1.block, e1), this.space(), e1.handlers ? this.print(e1.handlers[0], e1) : this.print(e1.handler, e1), e1.finalizer && (this.space(), this.word("finally"), this.space(), this.print(e1.finalizer, e1));
                }, t.VariableDeclaration = function(e1, t) {
                    e1.declare && (this.word("declare"), this.space());
                    const { kind: n } = e1;
                    this.word(n, "using" === n || "await using" === n), this.space();
                    let r = !1;
                    if (!i(t)) for (const t of e1.declarations)t.init && (r = !0);
                    if (this.printList(e1.declarations, e1, {
                        separator: r ? function() {
                            this.tokenChar(44), this.newline();
                        } : void 0,
                        indent: e1.declarations.length > 1
                    }), i(t)) {
                        if (s(t)) {
                            if (t.init === e1) return;
                        } else if (t.left === e1) return;
                    }
                    this.semicolon();
                }, t.VariableDeclarator = function(e1) {
                    this.print(e1.id, e1), e1.definite && this.tokenChar(33), this.print(e1.id.typeAnnotation, e1), e1.init && (this.space(), this.tokenChar(61), this.space(), this.print(e1.init, e1));
                }, t.WhileStatement = function(e1) {
                    this.word("while"), this.space(), this.tokenChar(40), this.print(e1.test, e1), this.tokenChar(41), this.printBlock(e1);
                }, t.WithStatement = function(e1) {
                    this.word("with"), this.space(), this.tokenChar(40), this.print(e1.object, e1), this.tokenChar(41), this.printBlock(e1);
                };
                var r = n(6067);
                const { isFor: i, isForStatement: s, isIfStatement: a, isStatement: o } = r;
                function l(e1) {
                    const { body: t } = e1;
                    return !1 === o(t) ? e1 : l(t);
                }
                function c(e1) {
                    this.word("for"), this.space();
                    const t = "ForOfStatement" === e1.type;
                    t && e1.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40), this.print(e1.left, e1), this.space(), this.word(t ? "of" : "in"), this.space(), this.print(e1.right, e1), this.tokenChar(41), this.printBlock(e1);
                }
                const u = c;
                t.ForInStatement = u;
                const p = c;
                function h(e1, t, n, r) {
                    t && (e1.space(), e1.printTerminatorless(t, n, r)), e1.semicolon();
                }
                t.ForOfStatement = p;
            },
            9716: (e1, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.TaggedTemplateExpression = function(e1) {
                    this.print(e1.tag, e1), this.print(e1.typeParameters, e1), this.print(e1.quasi, e1);
                }, t.TemplateElement = function(e1, t) {
                    const n = t.quasis[0] === e1, r = t.quasis[t.quasis.length - 1] === e1, i = (n ? "`" : "}") + e1.value.raw + (r ? "`" : "${");
                    this.token(i, !0);
                }, t.TemplateLiteral = function(e1) {
                    const t = e1.quasis;
                    for(let n = 0; n < t.length; n++)this.print(t[n], e1), n + 1 < t.length && this.print(e1.expressions[n], e1);
                };
            },
            7585: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ArgumentPlaceholder = function() {
                    this.tokenChar(63);
                }, t.ArrayPattern = t.ArrayExpression = function(e1) {
                    const t = e1.elements, n = t.length;
                    this.tokenChar(91);
                    for(let r = 0; r < t.length; r++){
                        const i = t[r];
                        i ? (r > 0 && this.space(), this.print(i, e1), r < n - 1 && this.tokenChar(44)) : this.tokenChar(44);
                    }
                    this.tokenChar(93);
                }, t.BigIntLiteral = function(e1) {
                    const t = this.getPossibleRaw(e1);
                    this.format.minified || void 0 === t ? this.word(e1.value + "n") : this.word(t);
                }, t.BooleanLiteral = function(e1) {
                    this.word(e1.value ? "true" : "false");
                }, t.DecimalLiteral = function(e1) {
                    const t = this.getPossibleRaw(e1);
                    this.format.minified || void 0 === t ? this.word(e1.value + "m") : this.word(t);
                }, t.Identifier = function(e1) {
                    var t;
                    this.sourceIdentifierName((null == (t = e1.loc) ? void 0 : t.identifierName) || e1.name), this.word(e1.name);
                }, t.NullLiteral = function() {
                    this.word("null");
                }, t.NumericLiteral = function(e1) {
                    const t = this.getPossibleRaw(e1), n = this.format.jsescOption, r = e1.value + "";
                    n.numbers ? this.number(i(e1.value, n)) : null == t ? this.number(r) : this.format.minified ? this.number(t.length < r.length ? t : r) : this.number(t);
                }, t.ObjectPattern = t.ObjectExpression = function(e1) {
                    const t = e1.properties;
                    this.tokenChar(123), t.length && (this.space(), this.printList(t, e1, {
                        indent: !0,
                        statement: !0
                    }), this.space()), this.sourceWithOffset("end", e1.loc, -1), this.tokenChar(125);
                }, t.ObjectMethod = function(e1) {
                    this.printJoin(e1.decorators, e1), this._methodHead(e1), this.space(), this.print(e1.body, e1);
                }, t.ObjectProperty = function(e1) {
                    if (this.printJoin(e1.decorators, e1), e1.computed) this.tokenChar(91), this.print(e1.key, e1), this.tokenChar(93);
                    else {
                        if (s(e1.value) && a(e1.key) && e1.key.name === e1.value.left.name) return void this.print(e1.value, e1);
                        if (this.print(e1.key, e1), e1.shorthand && a(e1.key) && a(e1.value) && e1.key.name === e1.value.name) return;
                    }
                    this.tokenChar(58), this.space(), this.print(e1.value, e1);
                }, t.PipelineBareFunction = function(e1) {
                    this.print(e1.callee, e1);
                }, t.PipelinePrimaryTopicReference = function() {
                    this.tokenChar(35);
                }, t.PipelineTopicExpression = function(e1) {
                    this.print(e1.expression, e1);
                }, t.RecordExpression = function(e1) {
                    const t = e1.properties;
                    let n, r;
                    if ("bar" === this.format.recordAndTupleSyntaxType) n = "{|", r = "|}";
                    else {
                        if ("hash" !== this.format.recordAndTupleSyntaxType && null != this.format.recordAndTupleSyntaxType) throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
                        n = "#{", r = "}";
                    }
                    this.token(n), t.length && (this.space(), this.printList(t, e1, {
                        indent: !0,
                        statement: !0
                    }), this.space()), this.token(r);
                }, t.RegExpLiteral = function(e1) {
                    this.word(`/${e1.pattern}/${e1.flags}`);
                }, t.SpreadElement = t.RestElement = function(e1) {
                    this.token("..."), this.print(e1.argument, e1);
                }, t.StringLiteral = function(e1) {
                    const t = this.getPossibleRaw(e1);
                    if (!this.format.minified && void 0 !== t) return void this.token(t);
                    const n = i(e1.value, this.format.jsescOption);
                    this.token(n);
                }, t.TopicReference = function() {
                    const { topicToken: e1 } = this.format;
                    if (!o.has(e1)) {
                        const t = JSON.stringify(e1), n = Array.from(o, (e1)=>JSON.stringify(e1));
                        throw new Error(`The "topicToken" generator option must be one of ${n.join(", ")} (${t} received instead).`);
                    }
                    this.token(e1);
                }, t.TupleExpression = function(e1) {
                    const t = e1.elements, n = t.length;
                    let r, i;
                    if ("bar" === this.format.recordAndTupleSyntaxType) r = "[|", i = "|]";
                    else {
                        if ("hash" !== this.format.recordAndTupleSyntaxType) throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
                        r = "#[", i = "]";
                    }
                    this.token(r);
                    for(let r = 0; r < t.length; r++){
                        const i = t[r];
                        i && (r > 0 && this.space(), this.print(i, e1), r < n - 1 && this.tokenChar(44));
                    }
                    this.token(i);
                };
                var r = n(6067), i = n(3312);
                const { isAssignmentPattern: s, isIdentifier: a } = r, o = new Set([
                    "^^",
                    "@@",
                    "^",
                    "%",
                    "#"
                ]);
            },
            5447: (e1, t)=>{
                "use strict";
                function n(e1, t, n) {
                    if (e1.token("{"), t.length) {
                        e1.indent(), e1.newline();
                        for (const r of t)e1.print(r, n), e1.newline();
                        e1.dedent();
                    }
                    e1.rightBrace(n);
                }
                function r(e1, t, n) {
                    e1.printJoin(t.types, t, {
                        separator () {
                            this.space(), this.token(n), this.space();
                        }
                    });
                }
                function i(e1, t) {
                    !0 !== t && e1.token(t);
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.TSAnyKeyword = function() {
                    this.word("any");
                }, t.TSArrayType = function(e1) {
                    this.print(e1.elementType, e1, !0), this.token("[]");
                }, t.TSSatisfiesExpression = t.TSAsExpression = function(e1) {
                    var t;
                    const { type: n, expression: r, typeAnnotation: i } = e1, s = !(null == (t = r.trailingComments) || !t.length);
                    this.print(r, e1, !0, void 0, s), this.space(), this.word("TSAsExpression" === n ? "as" : "satisfies"), this.space(), this.print(i, e1);
                }, t.TSBigIntKeyword = function() {
                    this.word("bigint");
                }, t.TSBooleanKeyword = function() {
                    this.word("boolean");
                }, t.TSCallSignatureDeclaration = function(e1) {
                    this.tsPrintSignatureDeclarationBase(e1), this.tokenChar(59);
                }, t.TSConditionalType = function(e1) {
                    this.print(e1.checkType), this.space(), this.word("extends"), this.space(), this.print(e1.extendsType), this.space(), this.tokenChar(63), this.space(), this.print(e1.trueType), this.space(), this.tokenChar(58), this.space(), this.print(e1.falseType);
                }, t.TSConstructSignatureDeclaration = function(e1) {
                    this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(e1), this.tokenChar(59);
                }, t.TSConstructorType = function(e1) {
                    e1.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(e1);
                }, t.TSDeclareFunction = function(e1, t) {
                    e1.declare && (this.word("declare"), this.space()), this._functionHead(e1, t), this.tokenChar(59);
                }, t.TSDeclareMethod = function(e1) {
                    this._classMethodHead(e1), this.tokenChar(59);
                }, t.TSEnumDeclaration = function(e1) {
                    const { declare: t, const: r, id: i, members: s } = e1;
                    t && (this.word("declare"), this.space()), r && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(i, e1), this.space(), n(this, s, e1);
                }, t.TSEnumMember = function(e1) {
                    const { id: t, initializer: n } = e1;
                    this.print(t, e1), n && (this.space(), this.tokenChar(61), this.space(), this.print(n, e1)), this.tokenChar(44);
                }, t.TSExportAssignment = function(e1) {
                    this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(e1.expression, e1), this.tokenChar(59);
                }, t.TSExpressionWithTypeArguments = function(e1) {
                    this.print(e1.expression, e1), this.print(e1.typeParameters, e1);
                }, t.TSExternalModuleReference = function(e1) {
                    this.token("require("), this.print(e1.expression, e1), this.tokenChar(41);
                }, t.TSFunctionType = function(e1) {
                    this.tsPrintFunctionOrConstructorType(e1);
                }, t.TSImportEqualsDeclaration = function(e1) {
                    const { isExport: t, id: n, moduleReference: r } = e1;
                    t && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(n, e1), this.space(), this.tokenChar(61), this.space(), this.print(r, e1), this.tokenChar(59);
                }, t.TSImportType = function(e1) {
                    const { argument: t, qualifier: n, typeParameters: r } = e1;
                    this.word("import"), this.tokenChar(40), this.print(t, e1), this.tokenChar(41), n && (this.tokenChar(46), this.print(n, e1)), r && this.print(r, e1);
                }, t.TSIndexSignature = function(e1) {
                    const { readonly: t, static: n } = e1;
                    n && (this.word("static"), this.space()), t && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(e1.parameters, e1), this.tokenChar(93), this.print(e1.typeAnnotation, e1), this.tokenChar(59);
                }, t.TSIndexedAccessType = function(e1) {
                    this.print(e1.objectType, e1, !0), this.tokenChar(91), this.print(e1.indexType, e1), this.tokenChar(93);
                }, t.TSInferType = function(e1) {
                    this.token("infer"), this.space(), this.print(e1.typeParameter);
                }, t.TSInstantiationExpression = function(e1) {
                    this.print(e1.expression, e1), this.print(e1.typeParameters, e1);
                }, t.TSInterfaceBody = function(e1) {
                    this.tsPrintTypeLiteralOrInterfaceBody(e1.body, e1);
                }, t.TSInterfaceDeclaration = function(e1) {
                    const { declare: t, id: n, typeParameters: r, extends: i, body: s } = e1;
                    t && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(n, e1), this.print(r, e1), null != i && i.length && (this.space(), this.word("extends"), this.space(), this.printList(i, e1)), this.space(), this.print(s, e1);
                }, t.TSIntersectionType = function(e1) {
                    r(this, e1, "&");
                }, t.TSIntrinsicKeyword = function() {
                    this.word("intrinsic");
                }, t.TSLiteralType = function(e1) {
                    this.print(e1.literal, e1);
                }, t.TSMappedType = function(e1) {
                    const { nameType: t, optional: n, readonly: r, typeParameter: s } = e1;
                    this.tokenChar(123), this.space(), r && (i(this, r), this.word("readonly"), this.space()), this.tokenChar(91), this.word(s.name), this.space(), this.word("in"), this.space(), this.print(s.constraint, s), t && (this.space(), this.word("as"), this.space(), this.print(t, e1)), this.tokenChar(93), n && (i(this, n), this.tokenChar(63)), this.tokenChar(58), this.space(), this.print(e1.typeAnnotation, e1), this.space(), this.tokenChar(125);
                }, t.TSMethodSignature = function(e1) {
                    const { kind: t } = e1;
                    "set" !== t && "get" !== t || (this.word(t), this.space()), this.tsPrintPropertyOrMethodName(e1), this.tsPrintSignatureDeclarationBase(e1), this.tokenChar(59);
                }, t.TSModuleBlock = function(e1) {
                    n(this, e1.body, e1);
                }, t.TSModuleDeclaration = function(e1) {
                    const { declare: t, id: n } = e1;
                    if (t && (this.word("declare"), this.space()), e1.global || (this.word("Identifier" === n.type ? "namespace" : "module"), this.space()), this.print(n, e1), !e1.body) return void this.tokenChar(59);
                    let r = e1.body;
                    for(; "TSModuleDeclaration" === r.type;)this.tokenChar(46), this.print(r.id, r), r = r.body;
                    this.space(), this.print(r, e1);
                }, t.TSNamedTupleMember = function(e1) {
                    this.print(e1.label, e1), e1.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(e1.elementType, e1);
                }, t.TSNamespaceExportDeclaration = function(e1) {
                    this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(e1.id, e1);
                }, t.TSNeverKeyword = function() {
                    this.word("never");
                }, t.TSNonNullExpression = function(e1) {
                    this.print(e1.expression, e1), this.tokenChar(33);
                }, t.TSNullKeyword = function() {
                    this.word("null");
                }, t.TSNumberKeyword = function() {
                    this.word("number");
                }, t.TSObjectKeyword = function() {
                    this.word("object");
                }, t.TSOptionalType = function(e1) {
                    this.print(e1.typeAnnotation, e1), this.tokenChar(63);
                }, t.TSParameterProperty = function(e1) {
                    e1.accessibility && (this.word(e1.accessibility), this.space()), e1.readonly && (this.word("readonly"), this.space()), this._param(e1.parameter);
                }, t.TSParenthesizedType = function(e1) {
                    this.tokenChar(40), this.print(e1.typeAnnotation, e1), this.tokenChar(41);
                }, t.TSPropertySignature = function(e1) {
                    const { readonly: t, initializer: n } = e1;
                    t && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(e1), this.print(e1.typeAnnotation, e1), n && (this.space(), this.tokenChar(61), this.space(), this.print(n, e1)), this.tokenChar(59);
                }, t.TSQualifiedName = function(e1) {
                    this.print(e1.left, e1), this.tokenChar(46), this.print(e1.right, e1);
                }, t.TSRestType = function(e1) {
                    this.token("..."), this.print(e1.typeAnnotation, e1);
                }, t.TSStringKeyword = function() {
                    this.word("string");
                }, t.TSSymbolKeyword = function() {
                    this.word("symbol");
                }, t.TSThisType = function() {
                    this.word("this");
                }, t.TSTupleType = function(e1) {
                    this.tokenChar(91), this.printList(e1.elementTypes, e1), this.tokenChar(93);
                }, t.TSTypeAliasDeclaration = function(e1) {
                    const { declare: t, id: n, typeParameters: r, typeAnnotation: i } = e1;
                    t && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(n, e1), this.print(r, e1), this.space(), this.tokenChar(61), this.space(), this.print(i, e1), this.tokenChar(59);
                }, t.TSTypeAnnotation = function(e1) {
                    this.tokenChar(58), this.space(), e1.optional && this.tokenChar(63), this.print(e1.typeAnnotation, e1);
                }, t.TSTypeAssertion = function(e1) {
                    const { typeAnnotation: t, expression: n } = e1;
                    this.tokenChar(60), this.print(t, e1), this.tokenChar(62), this.space(), this.print(n, e1);
                }, t.TSTypeLiteral = function(e1) {
                    this.tsPrintTypeLiteralOrInterfaceBody(e1.members, e1);
                }, t.TSTypeOperator = function(e1) {
                    this.word(e1.operator), this.space(), this.print(e1.typeAnnotation, e1);
                }, t.TSTypeParameter = function(e1) {
                    e1.in && (this.word("in"), this.space()), e1.out && (this.word("out"), this.space()), this.word(e1.name), e1.constraint && (this.space(), this.word("extends"), this.space(), this.print(e1.constraint, e1)), e1.default && (this.space(), this.tokenChar(61), this.space(), this.print(e1.default, e1));
                }, t.TSTypeParameterDeclaration = t.TSTypeParameterInstantiation = function(e1, t) {
                    this.tokenChar(60), this.printList(e1.params, e1, {}), "ArrowFunctionExpression" === t.type && 1 === e1.params.length && this.tokenChar(44), this.tokenChar(62);
                }, t.TSTypePredicate = function(e1) {
                    e1.asserts && (this.word("asserts"), this.space()), this.print(e1.parameterName), e1.typeAnnotation && (this.space(), this.word("is"), this.space(), this.print(e1.typeAnnotation.typeAnnotation));
                }, t.TSTypeQuery = function(e1) {
                    this.word("typeof"), this.space(), this.print(e1.exprName), e1.typeParameters && this.print(e1.typeParameters, e1);
                }, t.TSTypeReference = function(e1) {
                    this.print(e1.typeName, e1, !0), this.print(e1.typeParameters, e1, !0);
                }, t.TSUndefinedKeyword = function() {
                    this.word("undefined");
                }, t.TSUnionType = function(e1) {
                    r(this, e1, "|");
                }, t.TSUnknownKeyword = function() {
                    this.word("unknown");
                }, t.TSVoidKeyword = function() {
                    this.word("void");
                }, t.tsPrintClassMemberModifiers = function(e1) {
                    const t = "ClassAccessorProperty" === e1.type || "ClassProperty" === e1.type;
                    t && e1.declare && (this.word("declare"), this.space()), e1.accessibility && (this.word(e1.accessibility), this.space()), e1.static && (this.word("static"), this.space()), e1.override && (this.word("override"), this.space()), e1.abstract && (this.word("abstract"), this.space()), t && e1.readonly && (this.word("readonly"), this.space());
                }, t.tsPrintFunctionOrConstructorType = function(e1) {
                    const { typeParameters: t } = e1, n = e1.parameters;
                    this.print(t, e1), this.tokenChar(40), this._parameters(n, e1), this.tokenChar(41), this.space(), this.token("=>"), this.space();
                    const r = e1.typeAnnotation;
                    this.print(r.typeAnnotation, e1);
                }, t.tsPrintPropertyOrMethodName = function(e1) {
                    e1.computed && this.tokenChar(91), this.print(e1.key, e1), e1.computed && this.tokenChar(93), e1.optional && this.tokenChar(63);
                }, t.tsPrintSignatureDeclarationBase = function(e1) {
                    const { typeParameters: t } = e1, n = e1.parameters;
                    this.print(t, e1), this.tokenChar(40), this._parameters(n, e1), this.tokenChar(41);
                    const r = e1.typeAnnotation;
                    this.print(r, e1);
                }, t.tsPrintTypeLiteralOrInterfaceBody = function(e1, t) {
                    n(this, e1, t);
                };
            },
            7848: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CodeGenerator = void 0, t.default = function(e1, t, n) {
                    return new s(e1, t, n).generate();
                };
                var r = n(2564), i = n(516);
                class s extends i.default {
                    constructor(e1, t = {}, n){
                        const i = function(e1, t) {
                            var n;
                            const r = {
                                auxiliaryCommentBefore: t.auxiliaryCommentBefore,
                                auxiliaryCommentAfter: t.auxiliaryCommentAfter,
                                shouldPrintComment: t.shouldPrintComment,
                                retainLines: t.retainLines,
                                retainFunctionParens: t.retainFunctionParens,
                                comments: null == t.comments || t.comments,
                                compact: t.compact,
                                minified: t.minified,
                                concise: t.concise,
                                indent: {
                                    adjustMultilineComment: !0,
                                    style: "  "
                                },
                                jsescOption: Object.assign({
                                    quotes: "double",
                                    wrap: !0,
                                    minimal: !1
                                }, t.jsescOption),
                                recordAndTupleSyntaxType: null != (n = t.recordAndTupleSyntaxType) ? n : "hash",
                                topicToken: t.topicToken,
                                importAttributesKeyword: t.importAttributesKeyword
                            };
                            r.decoratorsBeforeExport = t.decoratorsBeforeExport, r.jsescOption.json = t.jsonCompatibleStrings, r.minified ? (r.compact = !0, r.shouldPrintComment = r.shouldPrintComment || (()=>r.comments)) : r.shouldPrintComment = r.shouldPrintComment || ((e1)=>r.comments || e1.includes("@license") || e1.includes("@preserve")), "auto" === r.compact && (r.compact = "string" == typeof e1 && e1.length > 5e5, r.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${t.filename} as it exceeds the max of 500KB.`)), r.compact && (r.indent.adjustMultilineComment = !1);
                            const { auxiliaryCommentBefore: i, auxiliaryCommentAfter: s, shouldPrintComment: a } = r;
                            return i && !a(i) && (r.auxiliaryCommentBefore = void 0), s && !a(s) && (r.auxiliaryCommentAfter = void 0), r;
                        }(n, t);
                        super(i, t.sourceMaps ? new r.default(t, n) : null), this.ast = void 0, this.ast = e1;
                    }
                    generate() {
                        return super.generate(this.ast);
                    }
                }
                t.CodeGenerator = class {
                    constructor(e1, t, n){
                        this._generator = void 0, this._generator = new s(e1, t, n);
                    }
                    generate() {
                        return this._generator.generate();
                    }
                };
            },
            7533: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.needsParens = function(e1, t, n) {
                    return !!t && (!(!u(t) || t.callee !== e1 || !y(e1)) || f(h, e1, t, n));
                }, t.needsWhitespace = m, t.needsWhitespaceAfter = function(e1, t) {
                    return m(e1, t, 2);
                }, t.needsWhitespaceBefore = function(e1, t) {
                    return m(e1, t, 1);
                };
                var r = n(9750), i = n(7363), s = n(6067);
                const { FLIPPED_ALIAS_KEYS: a, isCallExpression: o, isExpressionStatement: l, isMemberExpression: c, isNewExpression: u } = s;
                function p(e1) {
                    const t = {};
                    function n(e1, n) {
                        const r = t[e1];
                        t[e1] = r ? function(e1, t, i) {
                            const s = r(e1, t, i);
                            return null == s ? n(e1, t, i) : s;
                        } : n;
                    }
                    for (const t of Object.keys(e1)){
                        const r = a[t];
                        if (r) for (const i of r)n(i, e1[t]);
                        else n(t, e1[t]);
                    }
                    return t;
                }
                const h = p(i), d = p(r.nodes);
                function f(e1, t, n, r) {
                    const i = e1[t.type];
                    return i ? i(t, n, r) : null;
                }
                function y(e1) {
                    return !!o(e1) || c(e1) && y(e1.object);
                }
                function m(e1, t, n) {
                    if (!e1) return !1;
                    l(e1) && (e1 = e1.expression);
                    const r = f(d, e1, t);
                    return "number" == typeof r && 0 != (r & n);
                }
            },
            7363: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ArrowFunctionExpression = function(e1, t) {
                    return m(t) || ae(e1, t);
                }, t.AssignmentExpression = function(e1, t) {
                    return !!N(e1.left) || ae(e1, t);
                }, t.Binary = function(e1, t) {
                    if ("**" === e1.operator && c(t, {
                        operator: "**"
                    })) return t.left === e1;
                    if (re(e1, t)) return !0;
                    if (ie(e1, t) || $(t) || o(t)) return !0;
                    if (l(t)) {
                        const n = t.operator, r = te[n], i = e1.operator, s = te[i];
                        if (r === s && t.right === e1 && !C(t) || r > s) return !0;
                    }
                }, t.BinaryExpression = function(e1, t) {
                    return "in" === e1.operator && (z(t) || b(t));
                }, t.ClassExpression = function(e1, t, n) {
                    return oe(n, 5);
                }, t.ConditionalExpression = ae, t.DoExpression = function(e1, t, n) {
                    return !e1.async && oe(n, 1);
                }, t.FunctionExpression = function(e1, t, n) {
                    return oe(n, 5);
                }, t.FunctionTypeAnnotation = function(e1, t, n) {
                    if (!(n.length < 3)) return G(t) || v(t) || i(t) || J(t) && s(n[n.length - 3]);
                }, t.Identifier = function(e1, t, n) {
                    var r;
                    return !(null == (r = e1.extra) || !r.parenthesized || !a(t, {
                        left: e1
                    }) || !x(t.right) && !d(t.right) || null != t.right.id) || ("let" === e1.name ? oe(n, w(t, {
                        object: e1,
                        computed: !0
                    }) || k(t, {
                        object: e1,
                        computed: !0,
                        optional: !1
                    }) ? 57 : 32) : "async" === e1.name && S(t) && e1 === t.left);
                }, t.LogicalExpression = function(e1, t) {
                    if (ne(t)) return !0;
                    switch(e1.operator){
                        case "||":
                            return !!C(t) && ("??" === t.operator || "&&" === t.operator);
                        case "&&":
                            return C(t, {
                                operator: "??"
                            });
                        case "??":
                            return C(t) && "??" !== t.operator;
                    }
                }, t.NullableTypeAnnotation = function(e1, t) {
                    return i(t);
                }, t.ObjectExpression = function(e1, t, n) {
                    return oe(n, 3);
                }, t.OptionalIndexedAccessType = function(e1, t) {
                    return A(t, {
                        objectType: e1
                    });
                }, t.OptionalCallExpression = t.OptionalMemberExpression = function(e1, t) {
                    return p(t, {
                        callee: e1
                    }) || w(t, {
                        object: e1
                    });
                }, t.SequenceExpression = function(e1, t) {
                    return !(P(t) || H(t) || L(t) || D(t) && t.test === e1 || Q(t) && t.test === e1 || E(t) && t.right === e1 || M(t) && t.discriminant === e1 || g(t) && t.expression === e1);
                }, t.TSTypeAssertion = t.TSSatisfiesExpression = t.TSAsExpression = function() {
                    return !0;
                }, t.TSInferType = function(e1, t) {
                    return B(t) || K(t);
                }, t.TSInstantiationExpression = function(e1, t) {
                    return (p(t) || F(t) || O(t) || R(t)) && !!t.typeParameters;
                }, t.TSIntersectionType = t.TSUnionType = function(e1, t) {
                    return B(t) || K(t) || U(t) || Y(t) || W(t);
                }, t.UnaryLike = se, t.IntersectionTypeAnnotation = t.UnionTypeAnnotation = function(e1, t) {
                    return i(t) || I(t) || v(t) || G(t);
                }, t.UpdateExpression = function(e1, t) {
                    return ie(e1, t) || re(e1, t);
                }, t.AwaitExpression = t.YieldExpression = function(e1, t) {
                    return l(t) || $(t) || ie(e1, t) || o(t) && Z(e1) || y(t) && e1 === t.test || re(e1, t);
                };
                var r = n(6067);
                const { isArrayTypeAnnotation: i, isArrowFunctionExpression: s, isAssignmentExpression: a, isAwaitExpression: o, isBinary: l, isBinaryExpression: c, isUpdateExpression: u, isCallExpression: p, isClass: h, isClassExpression: d, isConditional: f, isConditionalExpression: y, isExportDeclaration: m, isExportDefaultDeclaration: T, isExpressionStatement: g, isFor: b, isForInStatement: E, isForOfStatement: S, isForStatement: P, isFunctionExpression: x, isIfStatement: D, isIndexedAccessType: A, isIntersectionTypeAnnotation: v, isLogicalExpression: C, isMemberExpression: w, isNewExpression: O, isNullableTypeAnnotation: I, isObjectPattern: N, isOptionalCallExpression: F, isOptionalMemberExpression: k, isReturnStatement: L, isSequenceExpression: _, isSwitchStatement: M, isTSArrayType: B, isTSAsExpression: j, isTSInstantiationExpression: R, isTSIntersectionType: U, isTSNonNullExpression: V, isTSOptionalType: K, isTSRestType: W, isTSTypeAssertion: X, isTSUnionType: Y, isTaggedTemplateExpression: q, isThrowStatement: H, isTypeAnnotation: J, isUnaryLike: $, isUnionTypeAnnotation: G, isVariableDeclarator: z, isWhileStatement: Q, isYieldExpression: Z, isTSSatisfiesExpression: ee } = r, te = {
                    "||": 0,
                    "??": 0,
                    "|>": 0,
                    "&&": 1,
                    "|": 2,
                    "^": 3,
                    "&": 4,
                    "==": 5,
                    "===": 5,
                    "!=": 5,
                    "!==": 5,
                    "<": 6,
                    ">": 6,
                    "<=": 6,
                    ">=": 6,
                    in: 6,
                    instanceof: 6,
                    ">>": 7,
                    "<<": 7,
                    ">>>": 7,
                    "+": 8,
                    "-": 8,
                    "*": 9,
                    "/": 9,
                    "%": 9,
                    "**": 10
                };
                function ne(e1) {
                    return j(e1) || ee(e1) || X(e1);
                }
                const re = (e1, t)=>h(t, {
                        superClass: e1
                    }), ie = (e1, t)=>(w(t) || k(t)) && t.object === e1 || (p(t) || F(t) || O(t)) && t.callee === e1 || q(t) && t.tag === e1 || V(t);
                function se(e1, t) {
                    return ie(e1, t) || c(t, {
                        operator: "**",
                        left: e1
                    }) || re(e1, t);
                }
                function ae(e1, t) {
                    return !!($(t) || l(t) || y(t, {
                        test: e1
                    }) || o(t) || ne(t)) || se(e1, t);
                }
                function oe(e1, t) {
                    const n = 1 & t, r = 2 & t, i = 4 & t, o = 8 & t, c = 16 & t, p = 32 & t;
                    let h = e1.length - 1;
                    if (h <= 0) return;
                    let d = e1[h];
                    h--;
                    let y = e1[h];
                    for(; h >= 0;){
                        if (n && g(y, {
                            expression: d
                        }) || i && T(y, {
                            declaration: d
                        }) || r && s(y, {
                            body: d
                        }) || o && P(y, {
                            init: d
                        }) || c && E(y, {
                            left: d
                        }) || p && S(y, {
                            left: d
                        })) return !0;
                        if (!(h > 0 && (ie(d, y) && !O(y) || _(y) && y.expressions[0] === d || u(y) && !y.prefix || f(y, {
                            test: d
                        }) || l(y, {
                            left: d
                        }) || a(y, {
                            left: d
                        })))) return !1;
                        d = y, h--, y = e1[h];
                    }
                    return !1;
                }
            },
            9750: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.nodes = void 0;
                var r = n(6067);
                const { FLIPPED_ALIAS_KEYS: i, isArrayExpression: s, isAssignmentExpression: a, isBinary: o, isBlockStatement: l, isCallExpression: c, isFunction: u, isIdentifier: p, isLiteral: h, isMemberExpression: d, isObjectExpression: f, isOptionalCallExpression: y, isOptionalMemberExpression: m, isStringLiteral: T } = r;
                function g(e1, t) {
                    return e1 ? (d(e1) || m(e1) ? (g(e1.object, t), e1.computed && g(e1.property, t)) : o(e1) || a(e1) ? (g(e1.left, t), g(e1.right, t)) : c(e1) || y(e1) ? (t.hasCall = !0, g(e1.callee, t)) : u(e1) ? t.hasFunction = !0 : p(e1) && (t.hasHelper = t.hasHelper || e1.callee && E(e1.callee)), t) : t;
                }
                function b(e1) {
                    return g(e1, {
                        hasCall: !1,
                        hasFunction: !1,
                        hasHelper: !1
                    });
                }
                function E(e1) {
                    return !!e1 && (d(e1) ? E(e1.object) || E(e1.property) : p(e1) ? "require" === e1.name || 95 === e1.name.charCodeAt(0) : c(e1) ? E(e1.callee) : !(!o(e1) && !a(e1)) && (p(e1.left) && E(e1.left) || E(e1.right)));
                }
                function S(e1) {
                    return h(e1) || f(e1) || s(e1) || p(e1) || d(e1);
                }
                const P = {
                    AssignmentExpression (e1) {
                        const t = b(e1.right);
                        if (t.hasCall && t.hasHelper || t.hasFunction) return t.hasFunction ? 3 : 2;
                    },
                    SwitchCase: (e1, t)=>(e1.consequent.length || t.cases[0] === e1 ? 1 : 0) | (e1.consequent.length || t.cases[t.cases.length - 1] !== e1 ? 0 : 2),
                    LogicalExpression (e1) {
                        if (u(e1.left) || u(e1.right)) return 2;
                    },
                    Literal (e1) {
                        if (T(e1) && "use strict" === e1.value) return 2;
                    },
                    CallExpression (e1) {
                        if (u(e1.callee) || E(e1)) return 3;
                    },
                    OptionalCallExpression (e1) {
                        if (u(e1.callee)) return 3;
                    },
                    VariableDeclaration (e1) {
                        for(let t = 0; t < e1.declarations.length; t++){
                            const n = e1.declarations[t];
                            let r = E(n.id) && !S(n.init);
                            if (!r && n.init) {
                                const e1 = b(n.init);
                                r = E(n.init) && e1.hasCall || e1.hasFunction;
                            }
                            if (r) return 3;
                        }
                    },
                    IfStatement (e1) {
                        if (l(e1.consequent)) return 3;
                    }
                };
                t.nodes = P, P.ObjectProperty = P.ObjectTypeProperty = P.ObjectMethod = function(e1, t) {
                    if (t.properties[0] === e1) return 1;
                }, P.ObjectTypeCallProperty = function(e1, t) {
                    var n;
                    if (t.callProperties[0] === e1 && (null == (n = t.properties) || !n.length)) return 1;
                }, P.ObjectTypeIndexer = function(e1, t) {
                    var n, r;
                    if (!(t.indexers[0] !== e1 || null != (n = t.properties) && n.length || null != (r = t.callProperties) && r.length)) return 1;
                }, P.ObjectTypeInternalSlot = function(e1, t) {
                    var n, r, i;
                    if (!(t.internalSlots[0] !== e1 || null != (n = t.properties) && n.length || null != (r = t.callProperties) && r.length || null != (i = t.indexers) && i.length)) return 1;
                }, [
                    [
                        "Function",
                        !0
                    ],
                    [
                        "Class",
                        !0
                    ],
                    [
                        "Loop",
                        !0
                    ],
                    [
                        "LabeledStatement",
                        !0
                    ],
                    [
                        "SwitchStatement",
                        !0
                    ],
                    [
                        "TryStatement",
                        !0
                    ]
                ].forEach(function([e1, t]) {
                    [
                        e1
                    ].concat(i[e1] || []).forEach(function(e1) {
                        const n = t ? 3 : 0;
                        P[e1] = ()=>n;
                    });
                });
            },
            516: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var r = n(8726), i = n(7533), s = n(6067), a = n(4236);
                const { isFunction: o, isStatement: l, isClassBody: c, isTSInterfaceBody: u, isTSEnumDeclaration: p } = s, h = /e/i, d = /\.0+$/, f = /^0[box]/, y = /^\s*[@#]__PURE__\s*$/, m = /[\n\r\u2028\u2029]/, T = /\*\//, { needsParens: g } = i;
                class b {
                    constructor(e1, t){
                        this.inForStatementInitCounter = 0, this._printStack = [], this._indent = 0, this._indentChar = 0, this._indentRepeat = 0, this._insideAux = !1, this._parenPushNewlineState = null, this._noLineTerminator = !1, this._printAuxAfterOnNextUserNode = !1, this._printedComments = new Set, this._endsWithInteger = !1, this._endsWithWord = !1, this._lastCommentLine = 0, this._endsWithInnerRaw = !1, this._indentInnerComments = !0, this.format = e1, this._buf = new r.default(t), this._indentChar = e1.indent.style.charCodeAt(0), this._indentRepeat = e1.indent.style.length, this._inputMap = null == t ? void 0 : t._inputMap;
                    }
                    generate(e1) {
                        return this.print(e1), this._maybeAddAuxComment(), this._buf.get();
                    }
                    indent() {
                        this.format.compact || this.format.concise || this._indent++;
                    }
                    dedent() {
                        this.format.compact || this.format.concise || this._indent--;
                    }
                    semicolon(e1 = !1) {
                        this._maybeAddAuxComment(), e1 ? this._appendChar(59) : this._queue(59), this._noLineTerminator = !1;
                    }
                    rightBrace(e1) {
                        this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", e1.loc, -1), this.tokenChar(125);
                    }
                    rightParens(e1) {
                        this.sourceWithOffset("end", e1.loc, -1), this.tokenChar(41);
                    }
                    space(e1 = !1) {
                        if (!this.format.compact) {
                            if (e1) this._space();
                            else if (this._buf.hasContent()) {
                                const e1 = this.getLastChar();
                                32 !== e1 && 10 !== e1 && this._space();
                            }
                        }
                    }
                    word(e1, t = !1) {
                        this._maybePrintInnerComments(), (this._endsWithWord || 47 === e1.charCodeAt(0) && this.endsWith(47)) && this._space(), this._maybeAddAuxComment(), this._append(e1, !1), this._endsWithWord = !0, this._noLineTerminator = t;
                    }
                    number(e1) {
                        this.word(e1), this._endsWithInteger = Number.isInteger(+e1) && !f.test(e1) && !h.test(e1) && !d.test(e1) && 46 !== e1.charCodeAt(e1.length - 1);
                    }
                    token(e1, t = !1) {
                        this._maybePrintInnerComments();
                        const n = this.getLastChar(), r = e1.charCodeAt(0);
                        (33 === n && ("--" === e1 || 61 === r) || 43 === r && 43 === n || 45 === r && 45 === n || 46 === r && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._append(e1, t), this._noLineTerminator = !1;
                    }
                    tokenChar(e1) {
                        this._maybePrintInnerComments();
                        const t = this.getLastChar();
                        (43 === e1 && 43 === t || 45 === e1 && 45 === t || 46 === e1 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._appendChar(e1), this._noLineTerminator = !1;
                    }
                    newline(e1 = 1, t) {
                        if (!(e1 <= 0)) {
                            if (!t) {
                                if (this.format.retainLines || this.format.compact) return;
                                if (this.format.concise) return void this.space();
                            }
                            e1 > 2 && (e1 = 2), e1 -= this._buf.getNewlineCount();
                            for(let t = 0; t < e1; t++)this._newline();
                        }
                    }
                    endsWith(e1) {
                        return this.getLastChar() === e1;
                    }
                    getLastChar() {
                        return this._buf.getLastChar();
                    }
                    endsWithCharAndNewline() {
                        return this._buf.endsWithCharAndNewline();
                    }
                    removeTrailingNewline() {
                        this._buf.removeTrailingNewline();
                    }
                    exactSource(e1, t) {
                        e1 ? (this._catchUp("start", e1), this._buf.exactSource(e1, t)) : t();
                    }
                    source(e1, t) {
                        t && (this._catchUp(e1, t), this._buf.source(e1, t));
                    }
                    sourceWithOffset(e1, t, n) {
                        t && (this._catchUp(e1, t), this._buf.sourceWithOffset(e1, t, n));
                    }
                    withSource(e1, t, n) {
                        t ? (this._catchUp(e1, t), this._buf.withSource(e1, t, n)) : n();
                    }
                    sourceIdentifierName(e1, t) {
                        if (!this._buf._canMarkIdName) return;
                        const n = this._buf._sourcePosition;
                        n.identifierNamePos = t, n.identifierName = e1;
                    }
                    _space() {
                        this._queue(32);
                    }
                    _newline() {
                        this._queue(10);
                    }
                    _append(e1, t) {
                        this._maybeAddParen(e1), this._maybeIndent(e1.charCodeAt(0)), this._buf.append(e1, t), this._endsWithWord = !1, this._endsWithInteger = !1;
                    }
                    _appendChar(e1) {
                        this._maybeAddParenChar(e1), this._maybeIndent(e1), this._buf.appendChar(e1), this._endsWithWord = !1, this._endsWithInteger = !1;
                    }
                    _queue(e1) {
                        this._maybeAddParenChar(e1), this._maybeIndent(e1), this._buf.queue(e1), this._endsWithWord = !1, this._endsWithInteger = !1;
                    }
                    _maybeIndent(e1) {
                        this._indent && 10 !== e1 && this.endsWith(10) && this._buf.queueIndentation(this._indentChar, this._getIndent());
                    }
                    _shouldIndent(e1) {
                        if (this._indent && 10 !== e1 && this.endsWith(10)) return !0;
                    }
                    _maybeAddParenChar(e1) {
                        const t = this._parenPushNewlineState;
                        t && 32 !== e1 && (10 === e1 ? (this.tokenChar(40), this.indent(), t.printed = !0) : this._parenPushNewlineState = null);
                    }
                    _maybeAddParen(e1) {
                        const t = this._parenPushNewlineState;
                        if (!t) return;
                        const n = e1.length;
                        let r;
                        for(r = 0; r < n && 32 === e1.charCodeAt(r); r++)continue;
                        if (r === n) return;
                        const i = e1.charCodeAt(r);
                        if (10 !== i) {
                            if (47 !== i || r + 1 === n) return void (this._parenPushNewlineState = null);
                            const t = e1.charCodeAt(r + 1);
                            if (42 === t) {
                                if (y.test(e1.slice(r + 2, n - 2))) return;
                            } else if (47 !== t) return void (this._parenPushNewlineState = null);
                        }
                        this.tokenChar(40), this.indent(), t.printed = !0;
                    }
                    catchUp(e1) {
                        if (!this.format.retainLines) return;
                        const t = e1 - this._buf.getCurrentLine();
                        for(let e1 = 0; e1 < t; e1++)this._newline();
                    }
                    _catchUp(e1, t) {
                        var n;
                        if (!this.format.retainLines) return;
                        const r = null == t || null == (n = t[e1]) ? void 0 : n.line;
                        if (null != r) {
                            const e1 = r - this._buf.getCurrentLine();
                            for(let t = 0; t < e1; t++)this._newline();
                        }
                    }
                    _getIndent() {
                        return this._indentRepeat * this._indent;
                    }
                    printTerminatorless(e1, t, n) {
                        if (n) this._noLineTerminator = !0, this.print(e1, t);
                        else {
                            const n = {
                                printed: !1
                            };
                            this._parenPushNewlineState = n, this.print(e1, t), n.printed && (this.dedent(), this.newline(), this.tokenChar(41));
                        }
                    }
                    print(e1, t, n, r, i) {
                        var s;
                        if (!e1) return;
                        this._endsWithInnerRaw = !1;
                        const a = e1.type, o = this.format, l = o.concise;
                        e1._compact && (o.concise = !0);
                        const c = this[a];
                        if (void 0 === c) throw new ReferenceError(`unknown node of type ${JSON.stringify(a)} with constructor ${JSON.stringify(e1.constructor.name)}`);
                        this._printStack.push(e1);
                        const u = this._insideAux;
                        this._insideAux = null == e1.loc, this._maybeAddAuxComment(this._insideAux && !u);
                        const p = i || o.retainFunctionParens && "FunctionExpression" === a && (null == (s = e1.extra) ? void 0 : s.parenthesized) || g(e1, t, this._printStack);
                        p && (this.tokenChar(40), this._endsWithInnerRaw = !1), this._lastCommentLine = 0, this._printLeadingComments(e1, t);
                        const h = "Program" === a || "File" === a ? null : e1.loc;
                        this.exactSource(h, c.bind(this, e1, t)), p ? (this._printTrailingComments(e1, t), this.tokenChar(41), this._noLineTerminator = n) : n && !this._noLineTerminator ? (this._noLineTerminator = !0, this._printTrailingComments(e1, t)) : this._printTrailingComments(e1, t, r), this._printStack.pop(), o.concise = l, this._insideAux = u, this._endsWithInnerRaw = !1;
                    }
                    _maybeAddAuxComment(e1) {
                        e1 && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
                    }
                    _printAuxBeforeComment() {
                        if (this._printAuxAfterOnNextUserNode) return;
                        this._printAuxAfterOnNextUserNode = !0;
                        const e1 = this.format.auxiliaryCommentBefore;
                        e1 && this._printComment({
                            type: "CommentBlock",
                            value: e1
                        }, 0);
                    }
                    _printAuxAfterComment() {
                        if (!this._printAuxAfterOnNextUserNode) return;
                        this._printAuxAfterOnNextUserNode = !1;
                        const e1 = this.format.auxiliaryCommentAfter;
                        e1 && this._printComment({
                            type: "CommentBlock",
                            value: e1
                        }, 0);
                    }
                    getPossibleRaw(e1) {
                        const t = e1.extra;
                        if (null != (null == t ? void 0 : t.raw) && null != t.rawValue && e1.value === t.rawValue) return t.raw;
                    }
                    printJoin(e1, t, n = {}) {
                        if (null == e1 || !e1.length) return;
                        let { indent: r } = n;
                        if (null == r && this.format.retainLines) {
                            var i;
                            const t = null == (i = e1[0].loc) ? void 0 : i.start.line;
                            null != t && t !== this._buf.getCurrentLine() && (r = !0);
                        }
                        r && this.indent();
                        const s = {
                            addNewlines: n.addNewlines,
                            nextNodeStartLine: 0
                        }, a = n.separator ? n.separator.bind(this) : null, o = e1.length;
                        for(let r = 0; r < o; r++){
                            const i = e1[r];
                            if (i && (n.statement && this._printNewline(0 === r, s), this.print(i, t, void 0, n.trailingCommentsLineOffset || 0), null == n.iterator || n.iterator(i, r), r < o - 1 && (null == a || a()), n.statement)) if (r + 1 === o) this.newline(1);
                            else {
                                var l;
                                const t = e1[r + 1];
                                s.nextNodeStartLine = (null == (l = t.loc) ? void 0 : l.start.line) || 0, this._printNewline(!0, s);
                            }
                        }
                        r && this.dedent();
                    }
                    printAndIndentOnComments(e1, t) {
                        const n = e1.leadingComments && e1.leadingComments.length > 0;
                        n && this.indent(), this.print(e1, t), n && this.dedent();
                    }
                    printBlock(e1) {
                        const t = e1.body;
                        "EmptyStatement" !== t.type && this.space(), this.print(t, e1);
                    }
                    _printTrailingComments(e1, t, n) {
                        const { innerComments: r, trailingComments: i } = e1;
                        null != r && r.length && this._printComments(2, r, e1, t, n), null != i && i.length && this._printComments(2, i, e1, t, n);
                    }
                    _printLeadingComments(e1, t) {
                        const n = e1.leadingComments;
                        null != n && n.length && this._printComments(0, n, e1, t);
                    }
                    _maybePrintInnerComments() {
                        this._endsWithInnerRaw && this.printInnerComments(), this._endsWithInnerRaw = !0, this._indentInnerComments = !0;
                    }
                    printInnerComments() {
                        const e1 = this._printStack[this._printStack.length - 1], t = e1.innerComments;
                        if (null == t || !t.length) return;
                        const n = this.endsWith(32), r = this._indentInnerComments, i = this._printedComments.size;
                        r && this.indent(), this._printComments(1, t, e1), n && i !== this._printedComments.size && this.space(), r && this.dedent();
                    }
                    noIndentInnerCommentsHere() {
                        this._indentInnerComments = !1;
                    }
                    printSequence(e1, t, n = {}) {
                        n.statement = !0, null != n.indent || (n.indent = !1), this.printJoin(e1, t, n);
                    }
                    printList(e1, t, n = {}) {
                        null == n.separator && (n.separator = S), this.printJoin(e1, t, n);
                    }
                    _printNewline(e1, t) {
                        const n = this.format;
                        if (n.retainLines || n.compact) return;
                        if (n.concise) return void this.space();
                        if (!e1) return;
                        const r = t.nextNodeStartLine, i = this._lastCommentLine;
                        if (r > 0 && i > 0) {
                            const e1 = r - i;
                            if (e1 >= 0) return void this.newline(e1 || 1);
                        }
                        this._buf.hasContent() && this.newline(1);
                    }
                    _shouldPrintComment(e1) {
                        return e1.ignore || this._printedComments.has(e1) ? 0 : this._noLineTerminator && (m.test(e1.value) || T.test(e1.value)) ? 2 : (this._printedComments.add(e1), this.format.shouldPrintComment(e1.value) ? 1 : 0);
                    }
                    _printComment(e1, t) {
                        const n = this._noLineTerminator, r = "CommentBlock" === e1.type, i = r && 1 !== t && !this._noLineTerminator;
                        i && this._buf.hasContent() && 2 !== t && this.newline(1);
                        const s = this.getLastChar();
                        let a;
                        if (91 !== s && 123 !== s && this.space(), r) {
                            if (a = `/*${e1.value}*/`, this.format.indent.adjustMultilineComment) {
                                var o;
                                const t = null == (o = e1.loc) ? void 0 : o.start.column;
                                if (t) {
                                    const e1 = new RegExp("\\n\\s{1," + t + "}", "g");
                                    a = a.replace(e1, "\n");
                                }
                                let n = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
                                (this._shouldIndent(47) || this.format.retainLines) && (n += this._getIndent()), a = a.replace(/\n(?!$)/g, `\n${" ".repeat(n)}`);
                            }
                        } else a = n ? `/*${e1.value}*/` : `//${e1.value}`;
                        this.endsWith(47) && this._space(), this.source("start", e1.loc), this._append(a, r), r || n || this.newline(1, !0), i && 3 !== t && this.newline(1);
                    }
                    _printComments(e1, t, n, r, i = 0) {
                        const s = n.loc, a = t.length;
                        let h = !!s;
                        const d = h ? s.start.line : 0, f = h ? s.end.line : 0;
                        let y = 0, T = 0;
                        const g = this._noLineTerminator ? function() {} : this.newline.bind(this);
                        for(let s = 0; s < a; s++){
                            const b = t[s], E = this._shouldPrintComment(b);
                            if (2 === E) {
                                h = !1;
                                break;
                            }
                            if (h && b.loc && 1 === E) {
                                const t = b.loc.start.line, n = b.loc.end.line;
                                if (0 === e1) {
                                    let e1 = 0;
                                    0 === s ? !this._buf.hasContent() || "CommentLine" !== b.type && t == n || (e1 = T = 1) : e1 = t - y, y = n, g(e1), this._printComment(b, 1), s + 1 === a && (g(Math.max(d - y, T)), y = d);
                                } else if (1 === e1) {
                                    const e1 = t - (0 === s ? d : y);
                                    y = n, g(e1), this._printComment(b, 1), s + 1 === a && (g(Math.min(1, f - y)), y = f);
                                } else {
                                    const e1 = t - (0 === s ? f - i : y);
                                    y = n, g(e1), this._printComment(b, 1);
                                }
                            } else {
                                if (h = !1, 1 !== E) continue;
                                if (1 === a) {
                                    const t = b.loc ? b.loc.start.line === b.loc.end.line : !m.test(b.value), i = t && !l(n) && !c(r) && !u(r) && !p(r);
                                    0 === e1 ? this._printComment(b, i && "ObjectExpression" !== n.type || t && o(r, {
                                        body: n
                                    }) ? 1 : 0) : i && 2 === e1 ? this._printComment(b, 1) : this._printComment(b, 0);
                                } else 1 !== e1 || "ObjectExpression" === n.type && n.properties.length > 1 || "ClassBody" === n.type || "TSInterfaceBody" === n.type ? this._printComment(b, 0) : this._printComment(b, 0 === s ? 2 : s === a - 1 ? 3 : 0);
                            }
                        }
                        2 === e1 && h && y && (this._lastCommentLine = y);
                    }
                }
                Object.assign(b.prototype, a), b.prototype.Noop = function() {};
                var E = b;
                function S() {
                    this.tokenChar(44), this.space();
                }
                t.default = E;
            },
            2564: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var r = n(2509), i = n(3446);
                t.default = class {
                    constructor(e1, t){
                        var n;
                        this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn = 0, this._inputMap = void 0;
                        const s = this._map = new r.GenMapping({
                            sourceRoot: e1.sourceRoot
                        });
                        if (this._sourceFileName = null == (n = e1.sourceFileName) ? void 0 : n.replace(/\\/g, "/"), this._rawMappings = void 0, e1.inputSourceMap) {
                            this._inputMap = new i.TraceMap(e1.inputSourceMap);
                            const t = this._inputMap.resolvedSources;
                            if (t.length) for(let e1 = 0; e1 < t.length; e1++){
                                var a;
                                (0, r.setSourceContent)(s, t[e1], null == (a = this._inputMap.sourcesContent) ? void 0 : a[e1]);
                            }
                        }
                        if ("string" != typeof t || e1.inputSourceMap) {
                            if ("object" == typeof t) for (const e1 of Object.keys(t))(0, r.setSourceContent)(s, e1.replace(/\\/g, "/"), t[e1]);
                        } else (0, r.setSourceContent)(s, this._sourceFileName, t);
                    }
                    get() {
                        return (0, r.toEncodedMap)(this._map);
                    }
                    getDecoded() {
                        return (0, r.toDecodedMap)(this._map);
                    }
                    getRawMappings() {
                        return this._rawMappings || (this._rawMappings = (0, r.allMappings)(this._map));
                    }
                    mark(e1, t, n, s, a, o) {
                        var l;
                        let c;
                        if (this._rawMappings = void 0, null != t) if (this._inputMap) {
                            if (c = (0, i.originalPositionFor)(this._inputMap, {
                                line: t,
                                column: n
                            }), !c.name && a) {
                                const e1 = (0, i.originalPositionFor)(this._inputMap, a);
                                e1.name && (s = e1.name);
                            }
                        } else c = {
                            source: (null == o ? void 0 : o.replace(/\\/g, "/")) || this._sourceFileName,
                            line: t,
                            column: n
                        };
                        (0, r.maybeAddMapping)(this._map, {
                            name: s,
                            generated: e1,
                            source: null == (l = c) ? void 0 : l.source,
                            original: c
                        });
                    }
                };
            },
            4705: (e1, t)=>{
                "use strict";
                function n(e1) {
                    const { context: t, node: n } = e1;
                    if (n.computed && t.maybeQueue(e1.get("key")), n.decorators) for (const n of e1.get("decorators"))t.maybeQueue(n);
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0, t.requeueComputedKeyAndDecorators = n, t.skipAllButComputedKey = function(e1) {
                    e1.skip(), e1.node.computed && e1.context.maybeQueue(e1.get("key"));
                };
                var r = {
                    FunctionParent (e1) {
                        e1.isArrowFunctionExpression() || (e1.skip(), e1.isMethod() && n(e1));
                    },
                    Property (e1) {
                        e1.isObjectProperty() || (e1.skip(), n(e1));
                    }
                };
                t.default = r;
            },
            2023: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function({ node: e1, parent: t, scope: n, id: r }, i = !1, D = !1) {
                    if (e1.id) return;
                    if (!y(t) && !f(t, {
                        kind: "method"
                    }) || t.computed && !h(t.key)) {
                        if (b(t)) {
                            if (r = t.id, p(r) && !i) {
                                const t = n.parent.getBinding(r.name);
                                if (t && t.constant && n.getBinding(r.name) === t) return e1.id = a(r), void (e1.id[s] = !0);
                            }
                        } else if (l(t, {
                            operator: "="
                        })) r = t.left;
                        else if (!r) return;
                    } else r = t.key;
                    let A;
                    if (r && h(r) ? A = function(e1) {
                        return d(e1) ? "null" : m(e1) ? `_${e1.pattern}_${e1.flags}` : g(e1) ? e1.quasis.map((e1)=>e1.value.raw).join("") : void 0 !== e1.value ? e1.value + "" : "";
                    }(r) : r && p(r) && (A = r.name), void 0 === A) return;
                    if (!D && u(e1) && /[\uD800-\uDFFF]/.test(A)) return;
                    A = E(A);
                    const v = o(A);
                    return v[s] = !0, function(e1, t, n, r) {
                        if (e1.selfReference) {
                            if (!r.hasBinding(n.name) || r.hasGlobal(n.name)) {
                                if (!u(t)) return;
                                let e1 = S;
                                t.generator && (e1 = P);
                                const i = e1({
                                    FUNCTION: t,
                                    FUNCTION_ID: n,
                                    FUNCTION_KEY: r.generateUidIdentifier(n.name)
                                }).expression, s = i.callee.body.body[0].params;
                                for(let e1 = 0, n = function(e1) {
                                    const t = e1.params.findIndex((e1)=>c(e1) || T(e1));
                                    return -1 === t ? e1.params.length : t;
                                }(t); e1 < n; e1++)s.push(r.generateUidIdentifier("x"));
                                return i;
                            }
                            r.rename(n.name);
                        }
                        t.id = n, r.getProgramParent().references[n.name] = !0;
                    }(function(e1, t, n) {
                        const r = {
                            selfAssignment: !1,
                            selfReference: !1,
                            outerDeclar: n.getBindingIdentifier(t),
                            name: t
                        }, i = n.getOwnBinding(t);
                        return i ? "param" === i.kind && (r.selfReference = !0) : (r.outerDeclar || n.hasGlobal(t)) && n.traverse(e1, x, r), r;
                    }(e1, A, n), e1, v, n) || e1;
                };
                var r = n(6849), i = n(6067);
                const { NOT_LOCAL_BINDING: s, cloneNode: a, identifier: o, isAssignmentExpression: l, isAssignmentPattern: c, isFunction: u, isIdentifier: p, isLiteral: h, isNullLiteral: d, isObjectMethod: f, isObjectProperty: y, isRegExpLiteral: m, isRestElement: T, isTemplateLiteral: g, isVariableDeclarator: b, toBindingIdentifierName: E } = i, S = r.default.statement("\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"), P = r.default.statement("\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"), x = {
                    "ReferencedIdentifier|BindingIdentifier" (e1, t) {
                        e1.node.name === t.name && e1.scope.getBindingIdentifier(t.name) === t.outerDeclar && (t.selfReference = !0, e1.stop());
                    }
                };
            },
            7438: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t, n = "var") {
                    e1.traverse(o, {
                        kind: n,
                        emit: t
                    });
                };
                var r = n(6067);
                const { assignmentExpression: i, expressionStatement: s, identifier: a } = r, o = {
                    Scope (e1, t) {
                        "let" === t.kind && e1.skip();
                    },
                    FunctionParent (e1) {
                        e1.skip();
                    },
                    VariableDeclaration (e1, t) {
                        if (t.kind && e1.node.kind !== t.kind) return;
                        const n = [], r = e1.get("declarations");
                        let o;
                        for (const e1 of r){
                            o = e1.node.id, e1.node.init && n.push(s(i("=", e1.node.id, e1.node.init)));
                            for (const n of Object.keys(e1.getBindingIdentifiers()))t.emit(a(n), n, null !== e1.node.init);
                        }
                        e1.parentPath.isFor({
                            left: e1.node
                        }) ? e1.replaceWith(o) : e1.replaceWithMultiple(n);
                    }
                };
            },
            3472: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1) {
                    if (!e1.isExportDeclaration() || e1.isExportAllDeclaration()) throw new Error("Only default and named export declarations can be split.");
                    if (e1.isExportDefaultDeclaration()) {
                        const t = e1.get("declaration"), n = t.isFunctionDeclaration() || t.isClassDeclaration(), r = t.isFunctionExpression() || t.isClassExpression(), u = t.isScope() ? t.scope.parent : t.scope;
                        let p = t.node.id, h = !1;
                        p ? r && u.hasBinding(p.name) && (h = !0, p = u.generateUidIdentifier(p.name)) : (h = !0, p = u.generateUidIdentifier("default"), (n || r) && (t.node.id = i(p)));
                        const d = n ? t.node : l("var", [
                            c(i(p), t.node)
                        ]), f = s(null, [
                            a(i(p), o("default"))
                        ]);
                        return e1.insertAfter(f), e1.replaceWith(d), h && u.registerDeclaration(e1), e1;
                    }
                    if (e1.get("specifiers").length > 0) throw new Error("It doesn't make sense to split exported specifiers.");
                    const t = e1.get("declaration"), n = t.getOuterBindingIdentifiers(), r = Object.keys(n).map((e1)=>a(o(e1), o(e1))), u = s(null, r);
                    return e1.insertAfter(u), e1.replaceWith(t.node), e1;
                };
                var r = n(6067);
                const { cloneNode: i, exportNamedDeclaration: s, exportSpecifier: a, identifier: o, variableDeclaration: l, variableDeclarator: c } = r;
            },
            7648: (e1, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.readCodePoint = c, t.readInt = l, t.readStringContents = function(e1, t, n, r, i, o) {
                    const l = n, c = r, u = i;
                    let p = "", h = null, d = n;
                    const { length: f } = t;
                    for(;;){
                        if (n >= f) {
                            o.unterminated(l, c, u), p += t.slice(d, n);
                            break;
                        }
                        const y = t.charCodeAt(n);
                        if (s(e1, y, t, n)) {
                            p += t.slice(d, n);
                            break;
                        }
                        if (92 === y) {
                            p += t.slice(d, n);
                            const s = a(t, n, r, i, "template" === e1, o);
                            null !== s.ch || h ? p += s.ch : h = {
                                pos: n,
                                lineStart: r,
                                curLine: i
                            }, ({ pos: n, lineStart: r, curLine: i } = s), d = n;
                        } else 8232 === y || 8233 === y ? (++i, r = ++n) : 10 === y || 13 === y ? "template" === e1 ? (p += t.slice(d, n) + "\n", ++n, 13 === y && 10 === t.charCodeAt(n) && ++n, ++i, d = r = n) : o.unterminated(l, c, u) : ++n;
                    }
                    return {
                        pos: n,
                        str: p,
                        firstInvalidLoc: h,
                        lineStart: r,
                        curLine: i,
                        containsInvalid: !!h
                    };
                };
                var n = function(e1) {
                    return e1 >= 48 && e1 <= 57;
                };
                const r = {
                    decBinOct: new Set([
                        46,
                        66,
                        69,
                        79,
                        95,
                        98,
                        101,
                        111
                    ]),
                    hex: new Set([
                        46,
                        88,
                        95,
                        120
                    ])
                }, i = {
                    bin: (e1)=>48 === e1 || 49 === e1,
                    oct: (e1)=>e1 >= 48 && e1 <= 55,
                    dec: (e1)=>e1 >= 48 && e1 <= 57,
                    hex: (e1)=>e1 >= 48 && e1 <= 57 || e1 >= 65 && e1 <= 70 || e1 >= 97 && e1 <= 102
                };
                function s(e1, t, n, r) {
                    return "template" === e1 ? 96 === t || 36 === t && 123 === n.charCodeAt(r + 1) : t === ("double" === e1 ? 34 : 39);
                }
                function a(e1, t, n, r, i, s) {
                    const a = !i;
                    t++;
                    const l = (e1)=>({
                            pos: t,
                            ch: e1,
                            lineStart: n,
                            curLine: r
                        }), u = e1.charCodeAt(t++);
                    switch(u){
                        case 110:
                            return l("\n");
                        case 114:
                            return l("\r");
                        case 120:
                            {
                                let i;
                                return { code: i, pos: t } = o(e1, t, n, r, 2, !1, a, s), l(null === i ? null : String.fromCharCode(i));
                            }
                        case 117:
                            {
                                let i;
                                return { code: i, pos: t } = c(e1, t, n, r, a, s), l(null === i ? null : String.fromCodePoint(i));
                            }
                        case 116:
                            return l("\t");
                        case 98:
                            return l("\b");
                        case 118:
                            return l("\v");
                        case 102:
                            return l("\f");
                        case 13:
                            10 === e1.charCodeAt(t) && ++t;
                        case 10:
                            n = t, ++r;
                        case 8232:
                        case 8233:
                            return l("");
                        case 56:
                        case 57:
                            if (i) return l(null);
                            s.strictNumericEscape(t - 1, n, r);
                        default:
                            if (u >= 48 && u <= 55) {
                                const a = t - 1;
                                let o = e1.slice(a, t + 2).match(/^[0-7]+/)[0], c = parseInt(o, 8);
                                c > 255 && (o = o.slice(0, -1), c = parseInt(o, 8)), t += o.length - 1;
                                const u = e1.charCodeAt(t);
                                if ("0" !== o || 56 === u || 57 === u) {
                                    if (i) return l(null);
                                    s.strictNumericEscape(a, n, r);
                                }
                                return l(String.fromCharCode(c));
                            }
                            return l(String.fromCharCode(u));
                    }
                }
                function o(e1, t, n, r, i, s, a, o) {
                    const c = t;
                    let u;
                    return { n: u, pos: t } = l(e1, t, n, r, 16, i, s, !1, o, !a), null === u && (a ? o.invalidEscapeSequence(c, n, r) : t = c - 1), {
                        code: u,
                        pos: t
                    };
                }
                function l(e1, t, s, a, o, l, c, u, p, h) {
                    const d = t, f = 16 === o ? r.hex : r.decBinOct, y = 16 === o ? i.hex : 10 === o ? i.dec : 8 === o ? i.oct : i.bin;
                    let m = !1, T = 0;
                    for(let r = 0, i = null == l ? 1 / 0 : l; r < i; ++r){
                        const r = e1.charCodeAt(t);
                        let i;
                        if (95 !== r || "bail" === u) {
                            if (i = r >= 97 ? r - 97 + 10 : r >= 65 ? r - 65 + 10 : n(r) ? r - 48 : 1 / 0, i >= o) {
                                if (i <= 9 && h) return {
                                    n: null,
                                    pos: t
                                };
                                if (i <= 9 && p.invalidDigit(t, s, a, o)) i = 0;
                                else {
                                    if (!c) break;
                                    i = 0, m = !0;
                                }
                            }
                            ++t, T = T * o + i;
                        } else {
                            const n = e1.charCodeAt(t - 1), r = e1.charCodeAt(t + 1);
                            if (u) {
                                if (Number.isNaN(r) || !y(r) || f.has(n) || f.has(r)) {
                                    if (h) return {
                                        n: null,
                                        pos: t
                                    };
                                    p.unexpectedNumericSeparator(t, s, a);
                                }
                            } else {
                                if (h) return {
                                    n: null,
                                    pos: t
                                };
                                p.numericSeparatorInEscapeSequence(t, s, a);
                            }
                            ++t;
                        }
                    }
                    return t === d || null != l && t - d !== l || m ? {
                        n: null,
                        pos: t
                    } : {
                        n: T,
                        pos: t
                    };
                }
                function c(e1, t, n, r, i, s) {
                    let a;
                    if (123 === e1.charCodeAt(t)) {
                        if (++t, { code: a, pos: t } = o(e1, t, n, r, e1.indexOf("}", t) - t, !0, i, s), ++t, null !== a && a > 1114111) {
                            if (!i) return {
                                code: null,
                                pos: t
                            };
                            s.invalidCodePoint(t, n, r);
                        }
                    } else ({ code: a, pos: t } = o(e1, t, n, r, 4, !1, i, s));
                    return {
                        code: a,
                        pos: t
                    };
                }
            },
            7749: (e1, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.isIdentifierChar = u, t.isIdentifierName = function(e1) {
                    let t = !0;
                    for(let n = 0; n < e1.length; n++){
                        let r = e1.charCodeAt(n);
                        if (55296 == (64512 & r) && n + 1 < e1.length) {
                            const t = e1.charCodeAt(++n);
                            56320 == (64512 & t) && (r = 65536 + ((1023 & r) << 10) + (1023 & t));
                        }
                        if (t) {
                            if (t = !1, !c(r)) return !1;
                        } else if (!u(r)) return !1;
                    }
                    return !t;
                }, t.isIdentifierStart = c;
                let n = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", r = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
                const i = new RegExp("[" + n + "]"), s = new RegExp("[" + n + r + "]");
                n = r = null;
                const a = [
                    0,
                    11,
                    2,
                    25,
                    2,
                    18,
                    2,
                    1,
                    2,
                    14,
                    3,
                    13,
                    35,
                    122,
                    70,
                    52,
                    268,
                    28,
                    4,
                    48,
                    48,
                    31,
                    14,
                    29,
                    6,
                    37,
                    11,
                    29,
                    3,
                    35,
                    5,
                    7,
                    2,
                    4,
                    43,
                    157,
                    19,
                    35,
                    5,
                    35,
                    5,
                    39,
                    9,
                    51,
                    13,
                    10,
                    2,
                    14,
                    2,
                    6,
                    2,
                    1,
                    2,
                    10,
                    2,
                    14,
                    2,
                    6,
                    2,
                    1,
                    68,
                    310,
                    10,
                    21,
                    11,
                    7,
                    25,
                    5,
                    2,
                    41,
                    2,
                    8,
                    70,
                    5,
                    3,
                    0,
                    2,
                    43,
                    2,
                    1,
                    4,
                    0,
                    3,
                    22,
                    11,
                    22,
                    10,
                    30,
                    66,
                    18,
                    2,
                    1,
                    11,
                    21,
                    11,
                    25,
                    71,
                    55,
                    7,
                    1,
                    65,
                    0,
                    16,
                    3,
                    2,
                    2,
                    2,
                    28,
                    43,
                    28,
                    4,
                    28,
                    36,
                    7,
                    2,
                    27,
                    28,
                    53,
                    11,
                    21,
                    11,
                    18,
                    14,
                    17,
                    111,
                    72,
                    56,
                    50,
                    14,
                    50,
                    14,
                    35,
                    349,
                    41,
                    7,
                    1,
                    79,
                    28,
                    11,
                    0,
                    9,
                    21,
                    43,
                    17,
                    47,
                    20,
                    28,
                    22,
                    13,
                    52,
                    58,
                    1,
                    3,
                    0,
                    14,
                    44,
                    33,
                    24,
                    27,
                    35,
                    30,
                    0,
                    3,
                    0,
                    9,
                    34,
                    4,
                    0,
                    13,
                    47,
                    15,
                    3,
                    22,
                    0,
                    2,
                    0,
                    36,
                    17,
                    2,
                    24,
                    20,
                    1,
                    64,
                    6,
                    2,
                    0,
                    2,
                    3,
                    2,
                    14,
                    2,
                    9,
                    8,
                    46,
                    39,
                    7,
                    3,
                    1,
                    3,
                    21,
                    2,
                    6,
                    2,
                    1,
                    2,
                    4,
                    4,
                    0,
                    19,
                    0,
                    13,
                    4,
                    159,
                    52,
                    19,
                    3,
                    21,
                    2,
                    31,
                    47,
                    21,
                    1,
                    2,
                    0,
                    185,
                    46,
                    42,
                    3,
                    37,
                    47,
                    21,
                    0,
                    60,
                    42,
                    14,
                    0,
                    72,
                    26,
                    38,
                    6,
                    186,
                    43,
                    117,
                    63,
                    32,
                    7,
                    3,
                    0,
                    3,
                    7,
                    2,
                    1,
                    2,
                    23,
                    16,
                    0,
                    2,
                    0,
                    95,
                    7,
                    3,
                    38,
                    17,
                    0,
                    2,
                    0,
                    29,
                    0,
                    11,
                    39,
                    8,
                    0,
                    22,
                    0,
                    12,
                    45,
                    20,
                    0,
                    19,
                    72,
                    264,
                    8,
                    2,
                    36,
                    18,
                    0,
                    50,
                    29,
                    113,
                    6,
                    2,
                    1,
                    2,
                    37,
                    22,
                    0,
                    26,
                    5,
                    2,
                    1,
                    2,
                    31,
                    15,
                    0,
                    328,
                    18,
                    16,
                    0,
                    2,
                    12,
                    2,
                    33,
                    125,
                    0,
                    80,
                    921,
                    103,
                    110,
                    18,
                    195,
                    2637,
                    96,
                    16,
                    1071,
                    18,
                    5,
                    4026,
                    582,
                    8634,
                    568,
                    8,
                    30,
                    18,
                    78,
                    18,
                    29,
                    19,
                    47,
                    17,
                    3,
                    32,
                    20,
                    6,
                    18,
                    689,
                    63,
                    129,
                    74,
                    6,
                    0,
                    67,
                    12,
                    65,
                    1,
                    2,
                    0,
                    29,
                    6135,
                    9,
                    1237,
                    43,
                    8,
                    8936,
                    3,
                    2,
                    6,
                    2,
                    1,
                    2,
                    290,
                    16,
                    0,
                    30,
                    2,
                    3,
                    0,
                    15,
                    3,
                    9,
                    395,
                    2309,
                    106,
                    6,
                    12,
                    4,
                    8,
                    8,
                    9,
                    5991,
                    84,
                    2,
                    70,
                    2,
                    1,
                    3,
                    0,
                    3,
                    1,
                    3,
                    3,
                    2,
                    11,
                    2,
                    0,
                    2,
                    6,
                    2,
                    64,
                    2,
                    3,
                    3,
                    7,
                    2,
                    6,
                    2,
                    27,
                    2,
                    3,
                    2,
                    4,
                    2,
                    0,
                    4,
                    6,
                    2,
                    339,
                    3,
                    24,
                    2,
                    24,
                    2,
                    30,
                    2,
                    24,
                    2,
                    30,
                    2,
                    24,
                    2,
                    30,
                    2,
                    24,
                    2,
                    30,
                    2,
                    24,
                    2,
                    7,
                    1845,
                    30,
                    7,
                    5,
                    262,
                    61,
                    147,
                    44,
                    11,
                    6,
                    17,
                    0,
                    322,
                    29,
                    19,
                    43,
                    485,
                    27,
                    757,
                    6,
                    2,
                    3,
                    2,
                    1,
                    2,
                    14,
                    2,
                    196,
                    60,
                    67,
                    8,
                    0,
                    1205,
                    3,
                    2,
                    26,
                    2,
                    1,
                    2,
                    0,
                    3,
                    0,
                    2,
                    9,
                    2,
                    3,
                    2,
                    0,
                    2,
                    0,
                    7,
                    0,
                    5,
                    0,
                    2,
                    0,
                    2,
                    0,
                    2,
                    2,
                    2,
                    1,
                    2,
                    0,
                    3,
                    0,
                    2,
                    0,
                    2,
                    0,
                    2,
                    0,
                    2,
                    0,
                    2,
                    1,
                    2,
                    0,
                    3,
                    3,
                    2,
                    6,
                    2,
                    3,
                    2,
                    3,
                    2,
                    0,
                    2,
                    9,
                    2,
                    16,
                    6,
                    2,
                    2,
                    4,
                    2,
                    16,
                    4421,
                    42719,
                    33,
                    4153,
                    7,
                    221,
                    3,
                    5761,
                    15,
                    7472,
                    3104,
                    541,
                    1507,
                    4938,
                    6,
                    4191
                ], o = [
                    509,
                    0,
                    227,
                    0,
                    150,
                    4,
                    294,
                    9,
                    1368,
                    2,
                    2,
                    1,
                    6,
                    3,
                    41,
                    2,
                    5,
                    0,
                    166,
                    1,
                    574,
                    3,
                    9,
                    9,
                    370,
                    1,
                    81,
                    2,
                    71,
                    10,
                    50,
                    3,
                    123,
                    2,
                    54,
                    14,
                    32,
                    10,
                    3,
                    1,
                    11,
                    3,
                    46,
                    10,
                    8,
                    0,
                    46,
                    9,
                    7,
                    2,
                    37,
                    13,
                    2,
                    9,
                    6,
                    1,
                    45,
                    0,
                    13,
                    2,
                    49,
                    13,
                    9,
                    3,
                    2,
                    11,
                    83,
                    11,
                    7,
                    0,
                    3,
                    0,
                    158,
                    11,
                    6,
                    9,
                    7,
                    3,
                    56,
                    1,
                    2,
                    6,
                    3,
                    1,
                    3,
                    2,
                    10,
                    0,
                    11,
                    1,
                    3,
                    6,
                    4,
                    4,
                    193,
                    17,
                    10,
                    9,
                    5,
                    0,
                    82,
                    19,
                    13,
                    9,
                    214,
                    6,
                    3,
                    8,
                    28,
                    1,
                    83,
                    16,
                    16,
                    9,
                    82,
                    12,
                    9,
                    9,
                    84,
                    14,
                    5,
                    9,
                    243,
                    14,
                    166,
                    9,
                    71,
                    5,
                    2,
                    1,
                    3,
                    3,
                    2,
                    0,
                    2,
                    1,
                    13,
                    9,
                    120,
                    6,
                    3,
                    6,
                    4,
                    0,
                    29,
                    9,
                    41,
                    6,
                    2,
                    3,
                    9,
                    0,
                    10,
                    10,
                    47,
                    15,
                    406,
                    7,
                    2,
                    7,
                    17,
                    9,
                    57,
                    21,
                    2,
                    13,
                    123,
                    5,
                    4,
                    0,
                    2,
                    1,
                    2,
                    6,
                    2,
                    0,
                    9,
                    9,
                    49,
                    4,
                    2,
                    1,
                    2,
                    4,
                    9,
                    9,
                    330,
                    3,
                    10,
                    1,
                    2,
                    0,
                    49,
                    6,
                    4,
                    4,
                    14,
                    9,
                    5351,
                    0,
                    7,
                    14,
                    13835,
                    9,
                    87,
                    9,
                    39,
                    4,
                    60,
                    6,
                    26,
                    9,
                    1014,
                    0,
                    2,
                    54,
                    8,
                    3,
                    82,
                    0,
                    12,
                    1,
                    19628,
                    1,
                    4706,
                    45,
                    3,
                    22,
                    543,
                    4,
                    4,
                    5,
                    9,
                    7,
                    3,
                    6,
                    31,
                    3,
                    149,
                    2,
                    1418,
                    49,
                    513,
                    54,
                    5,
                    49,
                    9,
                    0,
                    15,
                    0,
                    23,
                    4,
                    2,
                    14,
                    1361,
                    6,
                    2,
                    16,
                    3,
                    6,
                    2,
                    1,
                    2,
                    4,
                    101,
                    0,
                    161,
                    6,
                    10,
                    9,
                    357,
                    0,
                    62,
                    13,
                    499,
                    13,
                    983,
                    6,
                    110,
                    6,
                    6,
                    9,
                    4759,
                    9,
                    787719,
                    239
                ];
                function l(e1, t) {
                    let n = 65536;
                    for(let r = 0, i = t.length; r < i; r += 2){
                        if (n += t[r], n > e1) return !1;
                        if (n += t[r + 1], n >= e1) return !0;
                    }
                    return !1;
                }
                function c(e1) {
                    return e1 < 65 ? 36 === e1 : e1 <= 90 || (e1 < 97 ? 95 === e1 : e1 <= 122 || (e1 <= 65535 ? e1 >= 170 && i.test(String.fromCharCode(e1)) : l(e1, a)));
                }
                function u(e1) {
                    return e1 < 48 ? 36 === e1 : e1 < 58 || !(e1 < 65) && (e1 <= 90 || (e1 < 97 ? 95 === e1 : e1 <= 122 || (e1 <= 65535 ? e1 >= 170 && s.test(String.fromCharCode(e1)) : l(e1, a) || l(e1, o))));
                }
            },
            9649: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), Object.defineProperty(t, "isIdentifierChar", {
                    enumerable: !0,
                    get: function() {
                        return r.isIdentifierChar;
                    }
                }), Object.defineProperty(t, "isIdentifierName", {
                    enumerable: !0,
                    get: function() {
                        return r.isIdentifierName;
                    }
                }), Object.defineProperty(t, "isIdentifierStart", {
                    enumerable: !0,
                    get: function() {
                        return r.isIdentifierStart;
                    }
                }), Object.defineProperty(t, "isKeyword", {
                    enumerable: !0,
                    get: function() {
                        return i.isKeyword;
                    }
                }), Object.defineProperty(t, "isReservedWord", {
                    enumerable: !0,
                    get: function() {
                        return i.isReservedWord;
                    }
                }), Object.defineProperty(t, "isStrictBindOnlyReservedWord", {
                    enumerable: !0,
                    get: function() {
                        return i.isStrictBindOnlyReservedWord;
                    }
                }), Object.defineProperty(t, "isStrictBindReservedWord", {
                    enumerable: !0,
                    get: function() {
                        return i.isStrictBindReservedWord;
                    }
                }), Object.defineProperty(t, "isStrictReservedWord", {
                    enumerable: !0,
                    get: function() {
                        return i.isStrictReservedWord;
                    }
                });
                var r = n(7749), i = n(5562);
            },
            5562: (e1, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.isKeyword = function(e1) {
                    return n.has(e1);
                }, t.isReservedWord = s, t.isStrictBindOnlyReservedWord = o, t.isStrictBindReservedWord = function(e1, t) {
                    return a(e1, t) || o(e1);
                }, t.isStrictReservedWord = a;
                const n = new Set([
                    "break",
                    "case",
                    "catch",
                    "continue",
                    "debugger",
                    "default",
                    "do",
                    "else",
                    "finally",
                    "for",
                    "function",
                    "if",
                    "return",
                    "switch",
                    "throw",
                    "try",
                    "var",
                    "const",
                    "while",
                    "with",
                    "new",
                    "this",
                    "super",
                    "class",
                    "extends",
                    "export",
                    "import",
                    "null",
                    "true",
                    "false",
                    "in",
                    "instanceof",
                    "typeof",
                    "void",
                    "delete"
                ]), r = new Set([
                    "implements",
                    "interface",
                    "let",
                    "package",
                    "private",
                    "protected",
                    "public",
                    "static",
                    "yield"
                ]), i = new Set([
                    "eval",
                    "arguments"
                ]);
                function s(e1, t) {
                    return t && "await" === e1 || "enum" === e1;
                }
                function a(e1, t) {
                    return s(e1, t) || r.has(e1);
                }
                function o(e1) {
                    return i.has(e1);
                }
            },
            8530: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t = {}) {
                    return "" !== e1 && h(t) ? function(e1, t) {
                        let n = "";
                        for (const { type: r, value: i } of u(t)){
                            const t = e1[r];
                            n += t ? i.split(l).map((e1)=>t(e1)).join("\n") : i;
                        }
                        return n;
                    }({
                        keyword: (n = d(t.forceColor)).cyan,
                        capitalized: n.yellow,
                        jsxIdentifier: n.yellow,
                        punctuator: n.yellow,
                        number: n.magenta,
                        string: n.green,
                        regex: n.magenta,
                        comment: n.grey,
                        invalid: n.white.bgRed.bold
                    }, e1) : e1;
                    "TURBOPACK unreachable";
                    var n;
                }, t.shouldHighlight = h;
                var r = n(6188), i = n(9649), s = function(e1, t) {
                    if (null === e1 || "object" != typeof e1 && "function" != typeof e1) return {
                        default: e1
                    };
                    var n = a(true);
                    if (n && n.has(e1)) return n.get(e1);
                    var r = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
                    for(var s in e1)if ("default" !== s && Object.prototype.hasOwnProperty.call(e1, s)) {
                        var o = i ? Object.getOwnPropertyDescriptor(e1, s) : null;
                        o && (o.get || o.set) ? Object.defineProperty(r, s, o) : r[s] = e1[s];
                    }
                    return r.default = e1, n && n.set(e1, r), r;
                }(n(2589));
                function a(e1) {
                    if ("function" != typeof WeakMap) return null;
                    var t = new WeakMap, n = new WeakMap;
                    return (a = function(e1) {
                        return e1 ? n : t;
                    })(e1);
                }
                const o = new Set([
                    "as",
                    "async",
                    "from",
                    "get",
                    "of",
                    "set"
                ]), l = /\r\n|[\n\r\u2028\u2029]/, c = /^[()[\]{}]$/;
                let u, p;
                {
                    const e1 = /^[a-z][\w-]*$/i, t = function(t, n, r) {
                        if ("name" === t.type) {
                            if ((0, i.isKeyword)(t.value) || (0, i.isStrictReservedWord)(t.value, !0) || o.has(t.value)) return "keyword";
                            if (e1.test(t.value) && ("<" === r[n - 1] || "</" == r.slice(n - 2, n))) return "jsxIdentifier";
                            if (t.value[0] !== t.value[0].toLowerCase()) return "capitalized";
                        }
                        return "punctuator" === t.type && c.test(t.value) ? "bracket" : "invalid" !== t.type || "@" !== t.value && "#" !== t.value ? t.type : "punctuator";
                    };
                    u = function*(e1) {
                        let n;
                        for(; n = r.default.exec(e1);){
                            const i = r.matchToToken(n);
                            yield {
                                type: t(i, n.index, e1),
                                value: i.value
                            };
                        }
                    };
                }
                function h(e1) {
                    return s.default.level > 0 || e1.forceColor;
                }
                function d(e1) {
                    return e1 ? (null != p || (p = new s.default.constructor({
                        enabled: !0,
                        level: 1
                    })), p) : s.default;
                }
                t.getChalk = (e1)=>d(e1.forceColor);
            },
            7191: (e1, t)=>{
                "use strict";
                function n(e1, t) {
                    if (null == e1) return {};
                    var n, r, i = {}, s = Object.keys(e1);
                    for(r = 0; r < s.length; r++)n = s[r], t.indexOf(n) >= 0 || (i[n] = e1[n]);
                    return i;
                }
                class r {
                    constructor(e1, t, n){
                        this.line = void 0, this.column = void 0, this.index = void 0, this.line = e1, this.column = t, this.index = n;
                    }
                }
                class i {
                    constructor(e1, t){
                        this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e1, this.end = t;
                    }
                }
                function s(e1, t) {
                    const { line: n, column: i, index: s } = e1;
                    return new r(n, i + t, s + t);
                }
                const a = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
                var o = {
                    ImportMetaOutsideModule: {
                        message: "import.meta may appear only with 'sourceType: \"module\"'",
                        code: a
                    },
                    ImportOutsideModule: {
                        message: "'import' and 'export' may appear only with 'sourceType: \"module\"'",
                        code: a
                    }
                };
                const l = {
                    ArrayPattern: "array destructuring pattern",
                    AssignmentExpression: "assignment expression",
                    AssignmentPattern: "assignment expression",
                    ArrowFunctionExpression: "arrow function expression",
                    ConditionalExpression: "conditional expression",
                    CatchClause: "catch clause",
                    ForOfStatement: "for-of statement",
                    ForInStatement: "for-in statement",
                    ForStatement: "for-loop",
                    FormalParameters: "function parameter list",
                    Identifier: "identifier",
                    ImportSpecifier: "import specifier",
                    ImportDefaultSpecifier: "import default specifier",
                    ImportNamespaceSpecifier: "import namespace specifier",
                    ObjectPattern: "object destructuring pattern",
                    ParenthesizedExpression: "parenthesized expression",
                    RestElement: "rest element",
                    UpdateExpression: {
                        true: "prefix operation",
                        false: "postfix operation"
                    },
                    VariableDeclarator: "variable declaration",
                    YieldExpression: "yield expression"
                }, c = ({ type: e1, prefix: t })=>"UpdateExpression" === e1 ? l.UpdateExpression[String(t)] : l[e1];
                var u = {
                    AccessorIsGenerator: ({ kind: e1 })=>`A ${e1}ter cannot be a generator.`,
                    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
                    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
                    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
                    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
                    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
                    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
                    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
                    AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
                    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
                    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
                    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
                    ConstructorClassField: "Classes may not have a field named 'constructor'.",
                    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
                    ConstructorIsAccessor: "Class constructor may not be an accessor.",
                    ConstructorIsAsync: "Constructor can't be an async function.",
                    ConstructorIsGenerator: "Constructor can't be a generator.",
                    DeclarationMissingInitializer: ({ kind: e1 })=>`Missing initializer in ${e1} declaration.`,
                    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
                    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
                    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
                    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
                    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
                    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
                    DecoratorStaticBlock: "Decorators can't be used with a static block.",
                    DeletePrivateField: "Deleting a private field is not allowed.",
                    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
                    DuplicateConstructor: "Duplicate constructor in the same class.",
                    DuplicateDefaultExport: "Only one default export allowed per module.",
                    DuplicateExport: ({ exportName: e1 })=>`\`${e1}\` has already been exported. Exported identifiers must be unique.`,
                    DuplicateProto: "Redefinition of __proto__ property.",
                    DuplicateRegExpFlags: "Duplicate regular expression flag.",
                    ElementAfterRest: "Rest element must be last element.",
                    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
                    ExportBindingIsString: ({ localName: e1, exportName: t })=>`A string literal cannot be used as an exported binding without \`from\`.\n- Did you mean \`export { '${e1}' as '${t}' } from 'some-module'\`?`,
                    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
                    ForInOfLoopInitializer: ({ type: e1 })=>`'${"ForInStatement" === e1 ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
                    ForInUsing: "For-in loop may not start with 'using' declaration.",
                    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
                    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
                    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
                    IllegalBreakContinue: ({ type: e1 })=>`Unsyntactic ${"BreakStatement" === e1 ? "break" : "continue"}.`,
                    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
                    IllegalReturn: "'return' outside of function.",
                    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
                    ImportBindingIsString: ({ importName: e1 })=>`A string literal cannot be used as an imported binding.\n- Did you mean \`import { "${e1}" as foo }\`?`,
                    ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
                    ImportCallArity: ({ maxArgumentCount: e1 })=>`\`import()\` requires exactly ${1 === e1 ? "one argument" : "one or two arguments"}.`,
                    ImportCallNotNewExpression: "Cannot use new with import(...).",
                    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
                    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
                    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
                    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
                    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
                    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
                    InvalidCodePoint: "Code point out of bounds.",
                    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
                    InvalidDecimal: "Invalid decimal.",
                    InvalidDigit: ({ radix: e1 })=>`Expected number in radix ${e1}.`,
                    InvalidEscapeSequence: "Bad character escape sequence.",
                    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
                    InvalidEscapedReservedWord: ({ reservedWord: e1 })=>`Escape sequence in keyword ${e1}.`,
                    InvalidIdentifier: ({ identifierName: e1 })=>`Invalid identifier ${e1}.`,
                    InvalidLhs: ({ ancestor: e1 })=>`Invalid left-hand side in ${c(e1)}.`,
                    InvalidLhsBinding: ({ ancestor: e1 })=>`Binding invalid left-hand side in ${c(e1)}.`,
                    InvalidNumber: "Invalid number.",
                    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
                    InvalidOrUnexpectedToken: ({ unexpected: e1 })=>`Unexpected character '${e1}'.`,
                    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
                    InvalidPrivateFieldResolution: ({ identifierName: e1 })=>`Private name #${e1} is not defined.`,
                    InvalidPropertyBindingPattern: "Binding member expression.",
                    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
                    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
                    LabelRedeclaration: ({ labelName: e1 })=>`Label '${e1}' is already declared.`,
                    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
                    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
                    MalformedRegExpFlags: "Invalid regular expression flag.",
                    MissingClassName: "A class name is required.",
                    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
                    MissingSemicolon: "Missing semicolon.",
                    MissingPlugin: ({ missingPlugin: e1 })=>`This experimental syntax requires enabling the parser plugin: ${e1.map((e1)=>JSON.stringify(e1)).join(", ")}.`,
                    MissingOneOfPlugins: ({ missingPlugin: e1 })=>`This experimental syntax requires enabling one of the following parser plugin(s): ${e1.map((e1)=>JSON.stringify(e1)).join(", ")}.`,
                    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
                    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
                    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
                    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
                    ModuleAttributesWithDuplicateKeys: ({ key: e1 })=>`Duplicate key "${e1}" is not allowed in module attributes.`,
                    ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: e1 })=>`An export name cannot include a lone surrogate, found '\\u${e1.toString(16)}'.`,
                    ModuleExportUndefined: ({ localName: e1 })=>`Export '${e1}' is not defined.`,
                    MultipleDefaultsInSwitch: "Multiple default clauses.",
                    NewlineAfterThrow: "Illegal newline after throw.",
                    NoCatchOrFinally: "Missing catch or finally clause.",
                    NumberIdentifier: "Identifier directly after number.",
                    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
                    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
                    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
                    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
                    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
                    ParamDupe: "Argument name clash.",
                    PatternHasAccessor: "Object pattern can't contain getter or setter.",
                    PatternHasMethod: "Object pattern can't contain methods.",
                    PrivateInExpectedIn: ({ identifierName: e1 })=>`Private names are only allowed in property accesses (\`obj.#${e1}\`) or in \`in\` expressions (\`#${e1} in obj\`).`,
                    PrivateNameRedeclaration: ({ identifierName: e1 })=>`Duplicate private name #${e1}.`,
                    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
                    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
                    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
                    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
                    RestTrailingComma: "Unexpected trailing comma after rest element.",
                    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
                    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
                    StaticPrototype: "Classes may not have static property named prototype.",
                    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
                    SuperPrivateField: "Private fields can't be accessed on super.",
                    TrailingDecorator: "Decorators must be attached to a class element.",
                    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
                    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
                    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
                    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
                    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
                    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
                    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
                    UnexpectedKeyword: ({ keyword: e1 })=>`Unexpected keyword '${e1}'.`,
                    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
                    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
                    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
                    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
                    UnexpectedPrivateField: "Unexpected private name.",
                    UnexpectedReservedWord: ({ reservedWord: e1 })=>`Unexpected reserved word '${e1}'.`,
                    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
                    UnexpectedToken: ({ expected: e1, unexpected: t })=>`Unexpected token${t ? ` '${t}'.` : ""}${e1 ? `, expected "${e1}"` : ""}`,
                    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
                    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
                    UnsupportedBind: "Binding should be performed on object property.",
                    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
                    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
                    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
                    UnsupportedMetaProperty: ({ target: e1, onlyValidPropertyName: t })=>`The only valid meta property for ${e1} is ${e1}.${t}.`,
                    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
                    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
                    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
                    UnterminatedComment: "Unterminated comment.",
                    UnterminatedRegExp: "Unterminated regular expression.",
                    UnterminatedString: "Unterminated string constant.",
                    UnterminatedTemplate: "Unterminated template.",
                    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
                    VarRedeclaration: ({ identifierName: e1 })=>`Identifier '${e1}' has already been declared.`,
                    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
                    YieldInParameter: "Yield expression is not allowed in formal parameters.",
                    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
                };
                const p = new Set([
                    "ArrowFunctionExpression",
                    "AssignmentExpression",
                    "ConditionalExpression",
                    "YieldExpression"
                ]);
                var h = {
                    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
                    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
                    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
                    PipeTopicUnconfiguredToken: ({ token: e1 })=>`Invalid topic token ${e1}. In order to use ${e1} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${e1}" }.`,
                    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
                    PipeUnparenthesizedBody: ({ type: e1 })=>`Hack-style pipe body cannot be an unparenthesized ${c({
                            type: e1
                        })}; please wrap it in parentheses.`,
                    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
                    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
                    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
                    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
                    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
                    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
                };
                const d = [
                    "toMessage"
                ], f = [
                    "message"
                ];
                function y(e1, t, n) {
                    Object.defineProperty(e1, t, {
                        enumerable: !1,
                        configurable: !0,
                        value: n
                    });
                }
                function m(e1) {
                    let { toMessage: t } = e1, i = n(e1, d);
                    return function e1({ loc: n, details: s }) {
                        const a = new SyntaxError;
                        return Object.assign(a, i, {
                            loc: n,
                            pos: n.index
                        }), "missingPlugin" in s && Object.assign(a, {
                            missingPlugin: s.missingPlugin
                        }), y(a, "clone", function(t = {}) {
                            var i;
                            const { line: a, column: o, index: l } = null != (i = t.loc) ? i : n;
                            return e1({
                                loc: new r(a, o, l),
                                details: Object.assign({}, s, t.details)
                            });
                        }), y(a, "details", s), Object.defineProperty(a, "message", {
                            configurable: !0,
                            get () {
                                const e1 = `${t(s)} (${n.line}:${n.column})`;
                                return this.message = e1, e1;
                            },
                            set (e1) {
                                Object.defineProperty(this, "message", {
                                    value: e1,
                                    writable: !0
                                });
                            }
                        }), a;
                    };
                }
                function T(e1, t) {
                    if (Array.isArray(e1)) return (t)=>T(t, e1[0]);
                    const r = {};
                    for (const i of Object.keys(e1)){
                        const s = e1[i], a = "string" == typeof s ? {
                            message: ()=>s
                        } : "function" == typeof s ? {
                            message: s
                        } : s, { message: o } = a, l = n(a, f), c = "string" == typeof o ? ()=>o : o;
                        r[i] = m(Object.assign({
                            code: "BABEL_PARSER_SYNTAX_ERROR",
                            reasonCode: i,
                            toMessage: c
                        }, t ? {
                            syntaxPlugin: t
                        } : {}, l));
                    }
                    return r;
                }
                const g = Object.assign({}, T(o), T(u), T({
                    StrictDelete: "Deleting local variable in strict mode.",
                    StrictEvalArguments: ({ referenceName: e1 })=>`Assigning to '${e1}' in strict mode.`,
                    StrictEvalArgumentsBinding: ({ bindingName: e1 })=>`Binding '${e1}' in strict mode.`,
                    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
                    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
                    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
                    StrictWith: "'with' in strict mode."
                }), T`pipelineOperator`(h)), { defineProperty: b } = Object, E = (e1, t)=>b(e1, t, {
                        enumerable: !1,
                        value: e1[t]
                    });
                function S(e1) {
                    return e1.loc.start && E(e1.loc.start, "index"), e1.loc.end && E(e1.loc.end, "index"), e1;
                }
                class P {
                    constructor(e1, t){
                        this.token = void 0, this.preserveSpace = void 0, this.token = e1, this.preserveSpace = !!t;
                    }
                }
                const x = {
                    brace: new P("{"),
                    j_oTag: new P("<tag"),
                    j_cTag: new P("</tag"),
                    j_expr: new P("<tag>...</tag>", !0)
                };
                x.template = new P("`", !0);
                const D = !0, A = !0, v = !0, C = !0, w = !0;
                class O {
                    constructor(e1, t = {}){
                        this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = e1, this.keyword = t.keyword, this.beforeExpr = !!t.beforeExpr, this.startsExpr = !!t.startsExpr, this.rightAssociative = !!t.rightAssociative, this.isLoop = !!t.isLoop, this.isAssign = !!t.isAssign, this.prefix = !!t.prefix, this.postfix = !!t.postfix, this.binop = null != t.binop ? t.binop : null, this.updateContext = null;
                    }
                }
                const I = new Map;
                function N(e1, t = {}) {
                    t.keyword = e1;
                    const n = U(e1, t);
                    return I.set(e1, n), n;
                }
                function F(e1, t) {
                    return U(e1, {
                        beforeExpr: D,
                        binop: t
                    });
                }
                let k = -1;
                const L = [], _ = [], M = [], B = [], j = [], R = [];
                function U(e1, t = {}) {
                    var n, r, i, s;
                    return ++k, _.push(e1), M.push(null != (n = t.binop) ? n : -1), B.push(null != (r = t.beforeExpr) && r), j.push(null != (i = t.startsExpr) && i), R.push(null != (s = t.prefix) && s), L.push(new O(e1, t)), k;
                }
                function V(e1, t = {}) {
                    var n, r, i, s;
                    return ++k, I.set(e1, k), _.push(e1), M.push(null != (n = t.binop) ? n : -1), B.push(null != (r = t.beforeExpr) && r), j.push(null != (i = t.startsExpr) && i), R.push(null != (s = t.prefix) && s), L.push(new O("name", t)), k;
                }
                const K = {
                    bracketL: U("[", {
                        beforeExpr: D,
                        startsExpr: A
                    }),
                    bracketHashL: U("#[", {
                        beforeExpr: D,
                        startsExpr: A
                    }),
                    bracketBarL: U("[|", {
                        beforeExpr: D,
                        startsExpr: A
                    }),
                    bracketR: U("]"),
                    bracketBarR: U("|]"),
                    braceL: U("{", {
                        beforeExpr: D,
                        startsExpr: A
                    }),
                    braceBarL: U("{|", {
                        beforeExpr: D,
                        startsExpr: A
                    }),
                    braceHashL: U("#{", {
                        beforeExpr: D,
                        startsExpr: A
                    }),
                    braceR: U("}"),
                    braceBarR: U("|}"),
                    parenL: U("(", {
                        beforeExpr: D,
                        startsExpr: A
                    }),
                    parenR: U(")"),
                    comma: U(",", {
                        beforeExpr: D
                    }),
                    semi: U(";", {
                        beforeExpr: D
                    }),
                    colon: U(":", {
                        beforeExpr: D
                    }),
                    doubleColon: U("::", {
                        beforeExpr: D
                    }),
                    dot: U("."),
                    question: U("?", {
                        beforeExpr: D
                    }),
                    questionDot: U("?."),
                    arrow: U("=>", {
                        beforeExpr: D
                    }),
                    template: U("template"),
                    ellipsis: U("...", {
                        beforeExpr: D
                    }),
                    backQuote: U("`", {
                        startsExpr: A
                    }),
                    dollarBraceL: U("${", {
                        beforeExpr: D,
                        startsExpr: A
                    }),
                    templateTail: U("...`", {
                        startsExpr: A
                    }),
                    templateNonTail: U("...${", {
                        beforeExpr: D,
                        startsExpr: A
                    }),
                    at: U("@"),
                    hash: U("#", {
                        startsExpr: A
                    }),
                    interpreterDirective: U("#!..."),
                    eq: U("=", {
                        beforeExpr: D,
                        isAssign: C
                    }),
                    assign: U("_=", {
                        beforeExpr: D,
                        isAssign: C
                    }),
                    slashAssign: U("_=", {
                        beforeExpr: D,
                        isAssign: C
                    }),
                    xorAssign: U("_=", {
                        beforeExpr: D,
                        isAssign: C
                    }),
                    moduloAssign: U("_=", {
                        beforeExpr: D,
                        isAssign: C
                    }),
                    incDec: U("++/--", {
                        prefix: w,
                        postfix: !0,
                        startsExpr: A
                    }),
                    bang: U("!", {
                        beforeExpr: D,
                        prefix: w,
                        startsExpr: A
                    }),
                    tilde: U("~", {
                        beforeExpr: D,
                        prefix: w,
                        startsExpr: A
                    }),
                    doubleCaret: U("^^", {
                        startsExpr: A
                    }),
                    doubleAt: U("@@", {
                        startsExpr: A
                    }),
                    pipeline: F("|>", 0),
                    nullishCoalescing: F("??", 1),
                    logicalOR: F("||", 1),
                    logicalAND: F("&&", 2),
                    bitwiseOR: F("|", 3),
                    bitwiseXOR: F("^", 4),
                    bitwiseAND: F("&", 5),
                    equality: F("==/!=/===/!==", 6),
                    lt: F("</>/<=/>=", 7),
                    gt: F("</>/<=/>=", 7),
                    relational: F("</>/<=/>=", 7),
                    bitShift: F("<</>>/>>>", 8),
                    bitShiftL: F("<</>>/>>>", 8),
                    bitShiftR: F("<</>>/>>>", 8),
                    plusMin: U("+/-", {
                        beforeExpr: D,
                        binop: 9,
                        prefix: w,
                        startsExpr: A
                    }),
                    modulo: U("%", {
                        binop: 10,
                        startsExpr: A
                    }),
                    star: U("*", {
                        binop: 10
                    }),
                    slash: F("/", 10),
                    exponent: U("**", {
                        beforeExpr: D,
                        binop: 11,
                        rightAssociative: !0
                    }),
                    _in: N("in", {
                        beforeExpr: D,
                        binop: 7
                    }),
                    _instanceof: N("instanceof", {
                        beforeExpr: D,
                        binop: 7
                    }),
                    _break: N("break"),
                    _case: N("case", {
                        beforeExpr: D
                    }),
                    _catch: N("catch"),
                    _continue: N("continue"),
                    _debugger: N("debugger"),
                    _default: N("default", {
                        beforeExpr: D
                    }),
                    _else: N("else", {
                        beforeExpr: D
                    }),
                    _finally: N("finally"),
                    _function: N("function", {
                        startsExpr: A
                    }),
                    _if: N("if"),
                    _return: N("return", {
                        beforeExpr: D
                    }),
                    _switch: N("switch"),
                    _throw: N("throw", {
                        beforeExpr: D,
                        prefix: w,
                        startsExpr: A
                    }),
                    _try: N("try"),
                    _var: N("var"),
                    _const: N("const"),
                    _with: N("with"),
                    _new: N("new", {
                        beforeExpr: D,
                        startsExpr: A
                    }),
                    _this: N("this", {
                        startsExpr: A
                    }),
                    _super: N("super", {
                        startsExpr: A
                    }),
                    _class: N("class", {
                        startsExpr: A
                    }),
                    _extends: N("extends", {
                        beforeExpr: D
                    }),
                    _export: N("export"),
                    _import: N("import", {
                        startsExpr: A
                    }),
                    _null: N("null", {
                        startsExpr: A
                    }),
                    _true: N("true", {
                        startsExpr: A
                    }),
                    _false: N("false", {
                        startsExpr: A
                    }),
                    _typeof: N("typeof", {
                        beforeExpr: D,
                        prefix: w,
                        startsExpr: A
                    }),
                    _void: N("void", {
                        beforeExpr: D,
                        prefix: w,
                        startsExpr: A
                    }),
                    _delete: N("delete", {
                        beforeExpr: D,
                        prefix: w,
                        startsExpr: A
                    }),
                    _do: N("do", {
                        isLoop: v,
                        beforeExpr: D
                    }),
                    _for: N("for", {
                        isLoop: v
                    }),
                    _while: N("while", {
                        isLoop: v
                    }),
                    _as: V("as", {
                        startsExpr: A
                    }),
                    _assert: V("assert", {
                        startsExpr: A
                    }),
                    _async: V("async", {
                        startsExpr: A
                    }),
                    _await: V("await", {
                        startsExpr: A
                    }),
                    _from: V("from", {
                        startsExpr: A
                    }),
                    _get: V("get", {
                        startsExpr: A
                    }),
                    _let: V("let", {
                        startsExpr: A
                    }),
                    _meta: V("meta", {
                        startsExpr: A
                    }),
                    _of: V("of", {
                        startsExpr: A
                    }),
                    _sent: V("sent", {
                        startsExpr: A
                    }),
                    _set: V("set", {
                        startsExpr: A
                    }),
                    _static: V("static", {
                        startsExpr: A
                    }),
                    _using: V("using", {
                        startsExpr: A
                    }),
                    _yield: V("yield", {
                        startsExpr: A
                    }),
                    _asserts: V("asserts", {
                        startsExpr: A
                    }),
                    _checks: V("checks", {
                        startsExpr: A
                    }),
                    _exports: V("exports", {
                        startsExpr: A
                    }),
                    _global: V("global", {
                        startsExpr: A
                    }),
                    _implements: V("implements", {
                        startsExpr: A
                    }),
                    _intrinsic: V("intrinsic", {
                        startsExpr: A
                    }),
                    _infer: V("infer", {
                        startsExpr: A
                    }),
                    _is: V("is", {
                        startsExpr: A
                    }),
                    _mixins: V("mixins", {
                        startsExpr: A
                    }),
                    _proto: V("proto", {
                        startsExpr: A
                    }),
                    _require: V("require", {
                        startsExpr: A
                    }),
                    _satisfies: V("satisfies", {
                        startsExpr: A
                    }),
                    _keyof: V("keyof", {
                        startsExpr: A
                    }),
                    _readonly: V("readonly", {
                        startsExpr: A
                    }),
                    _unique: V("unique", {
                        startsExpr: A
                    }),
                    _abstract: V("abstract", {
                        startsExpr: A
                    }),
                    _declare: V("declare", {
                        startsExpr: A
                    }),
                    _enum: V("enum", {
                        startsExpr: A
                    }),
                    _module: V("module", {
                        startsExpr: A
                    }),
                    _namespace: V("namespace", {
                        startsExpr: A
                    }),
                    _interface: V("interface", {
                        startsExpr: A
                    }),
                    _type: V("type", {
                        startsExpr: A
                    }),
                    _opaque: V("opaque", {
                        startsExpr: A
                    }),
                    name: U("name", {
                        startsExpr: A
                    }),
                    string: U("string", {
                        startsExpr: A
                    }),
                    num: U("num", {
                        startsExpr: A
                    }),
                    bigint: U("bigint", {
                        startsExpr: A
                    }),
                    decimal: U("decimal", {
                        startsExpr: A
                    }),
                    regexp: U("regexp", {
                        startsExpr: A
                    }),
                    privateName: U("#name", {
                        startsExpr: A
                    }),
                    eof: U("eof"),
                    jsxName: U("jsxName"),
                    jsxText: U("jsxText", {
                        beforeExpr: !0
                    }),
                    jsxTagStart: U("jsxTagStart", {
                        startsExpr: !0
                    }),
                    jsxTagEnd: U("jsxTagEnd"),
                    placeholder: U("%%", {
                        startsExpr: !0
                    })
                };
                function W(e1) {
                    return e1 >= 93 && e1 <= 130;
                }
                function X(e1) {
                    return e1 >= 58 && e1 <= 130;
                }
                function Y(e1) {
                    return e1 >= 58 && e1 <= 134;
                }
                function q(e1) {
                    return j[e1];
                }
                function H(e1) {
                    return e1 >= 127 && e1 <= 129;
                }
                function J(e1) {
                    return e1 >= 58 && e1 <= 92;
                }
                function $(e1) {
                    return _[e1];
                }
                function G(e1) {
                    return M[e1];
                }
                function z(e1) {
                    return e1 >= 24 && e1 <= 25;
                }
                function Q(e1) {
                    return L[e1];
                }
                L[8].updateContext = (e1)=>{
                    e1.pop();
                }, L[5].updateContext = L[7].updateContext = L[23].updateContext = (e1)=>{
                    e1.push(x.brace);
                }, L[22].updateContext = (e1)=>{
                    e1[e1.length - 1] === x.template ? e1.pop() : e1.push(x.template);
                }, L[140].updateContext = (e1)=>{
                    e1.push(x.j_expr, x.j_oTag);
                };
                let Z = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", ee = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
                const te = new RegExp("[" + Z + "]"), ne = new RegExp("[" + Z + ee + "]");
                Z = ee = null;
                const re = [
                    0,
                    11,
                    2,
                    25,
                    2,
                    18,
                    2,
                    1,
                    2,
                    14,
                    3,
                    13,
                    35,
                    122,
                    70,
                    52,
                    268,
                    28,
                    4,
                    48,
                    48,
                    31,
                    14,
                    29,
                    6,
                    37,
                    11,
                    29,
                    3,
                    35,
                    5,
                    7,
                    2,
                    4,
                    43,
                    157,
                    19,
                    35,
                    5,
                    35,
                    5,
                    39,
                    9,
                    51,
                    13,
                    10,
                    2,
                    14,
                    2,
                    6,
                    2,
                    1,
                    2,
                    10,
                    2,
                    14,
                    2,
                    6,
                    2,
                    1,
                    68,
                    310,
                    10,
                    21,
                    11,
                    7,
                    25,
                    5,
                    2,
                    41,
                    2,
                    8,
                    70,
                    5,
                    3,
                    0,
                    2,
                    43,
                    2,
                    1,
                    4,
                    0,
                    3,
                    22,
                    11,
                    22,
                    10,
                    30,
                    66,
                    18,
                    2,
                    1,
                    11,
                    21,
                    11,
                    25,
                    71,
                    55,
                    7,
                    1,
                    65,
                    0,
                    16,
                    3,
                    2,
                    2,
                    2,
                    28,
                    43,
                    28,
                    4,
                    28,
                    36,
                    7,
                    2,
                    27,
                    28,
                    53,
                    11,
                    21,
                    11,
                    18,
                    14,
                    17,
                    111,
                    72,
                    56,
                    50,
                    14,
                    50,
                    14,
                    35,
                    349,
                    41,
                    7,
                    1,
                    79,
                    28,
                    11,
                    0,
                    9,
                    21,
                    43,
                    17,
                    47,
                    20,
                    28,
                    22,
                    13,
                    52,
                    58,
                    1,
                    3,
                    0,
                    14,
                    44,
                    33,
                    24,
                    27,
                    35,
                    30,
                    0,
                    3,
                    0,
                    9,
                    34,
                    4,
                    0,
                    13,
                    47,
                    15,
                    3,
                    22,
                    0,
                    2,
                    0,
                    36,
                    17,
                    2,
                    24,
                    20,
                    1,
                    64,
                    6,
                    2,
                    0,
                    2,
                    3,
                    2,
                    14,
                    2,
                    9,
                    8,
                    46,
                    39,
                    7,
                    3,
                    1,
                    3,
                    21,
                    2,
                    6,
                    2,
                    1,
                    2,
                    4,
                    4,
                    0,
                    19,
                    0,
                    13,
                    4,
                    159,
                    52,
                    19,
                    3,
                    21,
                    2,
                    31,
                    47,
                    21,
                    1,
                    2,
                    0,
                    185,
                    46,
                    42,
                    3,
                    37,
                    47,
                    21,
                    0,
                    60,
                    42,
                    14,
                    0,
                    72,
                    26,
                    38,
                    6,
                    186,
                    43,
                    117,
                    63,
                    32,
                    7,
                    3,
                    0,
                    3,
                    7,
                    2,
                    1,
                    2,
                    23,
                    16,
                    0,
                    2,
                    0,
                    95,
                    7,
                    3,
                    38,
                    17,
                    0,
                    2,
                    0,
                    29,
                    0,
                    11,
                    39,
                    8,
                    0,
                    22,
                    0,
                    12,
                    45,
                    20,
                    0,
                    19,
                    72,
                    264,
                    8,
                    2,
                    36,
                    18,
                    0,
                    50,
                    29,
                    113,
                    6,
                    2,
                    1,
                    2,
                    37,
                    22,
                    0,
                    26,
                    5,
                    2,
                    1,
                    2,
                    31,
                    15,
                    0,
                    328,
                    18,
                    16,
                    0,
                    2,
                    12,
                    2,
                    33,
                    125,
                    0,
                    80,
                    921,
                    103,
                    110,
                    18,
                    195,
                    2637,
                    96,
                    16,
                    1071,
                    18,
                    5,
                    4026,
                    582,
                    8634,
                    568,
                    8,
                    30,
                    18,
                    78,
                    18,
                    29,
                    19,
                    47,
                    17,
                    3,
                    32,
                    20,
                    6,
                    18,
                    689,
                    63,
                    129,
                    74,
                    6,
                    0,
                    67,
                    12,
                    65,
                    1,
                    2,
                    0,
                    29,
                    6135,
                    9,
                    1237,
                    43,
                    8,
                    8936,
                    3,
                    2,
                    6,
                    2,
                    1,
                    2,
                    290,
                    16,
                    0,
                    30,
                    2,
                    3,
                    0,
                    15,
                    3,
                    9,
                    395,
                    2309,
                    106,
                    6,
                    12,
                    4,
                    8,
                    8,
                    9,
                    5991,
                    84,
                    2,
                    70,
                    2,
                    1,
                    3,
                    0,
                    3,
                    1,
                    3,
                    3,
                    2,
                    11,
                    2,
                    0,
                    2,
                    6,
                    2,
                    64,
                    2,
                    3,
                    3,
                    7,
                    2,
                    6,
                    2,
                    27,
                    2,
                    3,
                    2,
                    4,
                    2,
                    0,
                    4,
                    6,
                    2,
                    339,
                    3,
                    24,
                    2,
                    24,
                    2,
                    30,
                    2,
                    24,
                    2,
                    30,
                    2,
                    24,
                    2,
                    30,
                    2,
                    24,
                    2,
                    30,
                    2,
                    24,
                    2,
                    7,
                    1845,
                    30,
                    7,
                    5,
                    262,
                    61,
                    147,
                    44,
                    11,
                    6,
                    17,
                    0,
                    322,
                    29,
                    19,
                    43,
                    485,
                    27,
                    757,
                    6,
                    2,
                    3,
                    2,
                    1,
                    2,
                    14,
                    2,
                    196,
                    60,
                    67,
                    8,
                    0,
                    1205,
                    3,
                    2,
                    26,
                    2,
                    1,
                    2,
                    0,
                    3,
                    0,
                    2,
                    9,
                    2,
                    3,
                    2,
                    0,
                    2,
                    0,
                    7,
                    0,
                    5,
                    0,
                    2,
                    0,
                    2,
                    0,
                    2,
                    2,
                    2,
                    1,
                    2,
                    0,
                    3,
                    0,
                    2,
                    0,
                    2,
                    0,
                    2,
                    0,
                    2,
                    0,
                    2,
                    1,
                    2,
                    0,
                    3,
                    3,
                    2,
                    6,
                    2,
                    3,
                    2,
                    3,
                    2,
                    0,
                    2,
                    9,
                    2,
                    16,
                    6,
                    2,
                    2,
                    4,
                    2,
                    16,
                    4421,
                    42719,
                    33,
                    4153,
                    7,
                    221,
                    3,
                    5761,
                    15,
                    7472,
                    3104,
                    541,
                    1507,
                    4938,
                    6,
                    4191
                ], ie = [
                    509,
                    0,
                    227,
                    0,
                    150,
                    4,
                    294,
                    9,
                    1368,
                    2,
                    2,
                    1,
                    6,
                    3,
                    41,
                    2,
                    5,
                    0,
                    166,
                    1,
                    574,
                    3,
                    9,
                    9,
                    370,
                    1,
                    81,
                    2,
                    71,
                    10,
                    50,
                    3,
                    123,
                    2,
                    54,
                    14,
                    32,
                    10,
                    3,
                    1,
                    11,
                    3,
                    46,
                    10,
                    8,
                    0,
                    46,
                    9,
                    7,
                    2,
                    37,
                    13,
                    2,
                    9,
                    6,
                    1,
                    45,
                    0,
                    13,
                    2,
                    49,
                    13,
                    9,
                    3,
                    2,
                    11,
                    83,
                    11,
                    7,
                    0,
                    3,
                    0,
                    158,
                    11,
                    6,
                    9,
                    7,
                    3,
                    56,
                    1,
                    2,
                    6,
                    3,
                    1,
                    3,
                    2,
                    10,
                    0,
                    11,
                    1,
                    3,
                    6,
                    4,
                    4,
                    193,
                    17,
                    10,
                    9,
                    5,
                    0,
                    82,
                    19,
                    13,
                    9,
                    214,
                    6,
                    3,
                    8,
                    28,
                    1,
                    83,
                    16,
                    16,
                    9,
                    82,
                    12,
                    9,
                    9,
                    84,
                    14,
                    5,
                    9,
                    243,
                    14,
                    166,
                    9,
                    71,
                    5,
                    2,
                    1,
                    3,
                    3,
                    2,
                    0,
                    2,
                    1,
                    13,
                    9,
                    120,
                    6,
                    3,
                    6,
                    4,
                    0,
                    29,
                    9,
                    41,
                    6,
                    2,
                    3,
                    9,
                    0,
                    10,
                    10,
                    47,
                    15,
                    406,
                    7,
                    2,
                    7,
                    17,
                    9,
                    57,
                    21,
                    2,
                    13,
                    123,
                    5,
                    4,
                    0,
                    2,
                    1,
                    2,
                    6,
                    2,
                    0,
                    9,
                    9,
                    49,
                    4,
                    2,
                    1,
                    2,
                    4,
                    9,
                    9,
                    330,
                    3,
                    10,
                    1,
                    2,
                    0,
                    49,
                    6,
                    4,
                    4,
                    14,
                    9,
                    5351,
                    0,
                    7,
                    14,
                    13835,
                    9,
                    87,
                    9,
                    39,
                    4,
                    60,
                    6,
                    26,
                    9,
                    1014,
                    0,
                    2,
                    54,
                    8,
                    3,
                    82,
                    0,
                    12,
                    1,
                    19628,
                    1,
                    4706,
                    45,
                    3,
                    22,
                    543,
                    4,
                    4,
                    5,
                    9,
                    7,
                    3,
                    6,
                    31,
                    3,
                    149,
                    2,
                    1418,
                    49,
                    513,
                    54,
                    5,
                    49,
                    9,
                    0,
                    15,
                    0,
                    23,
                    4,
                    2,
                    14,
                    1361,
                    6,
                    2,
                    16,
                    3,
                    6,
                    2,
                    1,
                    2,
                    4,
                    101,
                    0,
                    161,
                    6,
                    10,
                    9,
                    357,
                    0,
                    62,
                    13,
                    499,
                    13,
                    983,
                    6,
                    110,
                    6,
                    6,
                    9,
                    4759,
                    9,
                    787719,
                    239
                ];
                function se(e1, t) {
                    let n = 65536;
                    for(let r = 0, i = t.length; r < i; r += 2){
                        if (n += t[r], n > e1) return !1;
                        if (n += t[r + 1], n >= e1) return !0;
                    }
                    return !1;
                }
                function ae(e1) {
                    return e1 < 65 ? 36 === e1 : e1 <= 90 || (e1 < 97 ? 95 === e1 : e1 <= 122 || (e1 <= 65535 ? e1 >= 170 && te.test(String.fromCharCode(e1)) : se(e1, re)));
                }
                function oe(e1) {
                    return e1 < 48 ? 36 === e1 : e1 < 58 || !(e1 < 65) && (e1 <= 90 || (e1 < 97 ? 95 === e1 : e1 <= 122 || (e1 <= 65535 ? e1 >= 170 && ne.test(String.fromCharCode(e1)) : se(e1, re) || se(e1, ie))));
                }
                const le = new Set([
                    "break",
                    "case",
                    "catch",
                    "continue",
                    "debugger",
                    "default",
                    "do",
                    "else",
                    "finally",
                    "for",
                    "function",
                    "if",
                    "return",
                    "switch",
                    "throw",
                    "try",
                    "var",
                    "const",
                    "while",
                    "with",
                    "new",
                    "this",
                    "super",
                    "class",
                    "extends",
                    "export",
                    "import",
                    "null",
                    "true",
                    "false",
                    "in",
                    "instanceof",
                    "typeof",
                    "void",
                    "delete"
                ]), ce = new Set([
                    "implements",
                    "interface",
                    "let",
                    "package",
                    "private",
                    "protected",
                    "public",
                    "static",
                    "yield"
                ]), ue = new Set([
                    "eval",
                    "arguments"
                ]);
                function pe(e1, t) {
                    return t && "await" === e1 || "enum" === e1;
                }
                function he(e1, t) {
                    return pe(e1, t) || ce.has(e1);
                }
                function de(e1) {
                    return ue.has(e1);
                }
                function fe(e1, t) {
                    return he(e1, t) || de(e1);
                }
                const ye = new Set([
                    "break",
                    "case",
                    "catch",
                    "continue",
                    "debugger",
                    "default",
                    "do",
                    "else",
                    "finally",
                    "for",
                    "function",
                    "if",
                    "return",
                    "switch",
                    "throw",
                    "try",
                    "var",
                    "const",
                    "while",
                    "with",
                    "new",
                    "this",
                    "super",
                    "class",
                    "extends",
                    "export",
                    "import",
                    "null",
                    "true",
                    "false",
                    "in",
                    "instanceof",
                    "typeof",
                    "void",
                    "delete",
                    "implements",
                    "interface",
                    "let",
                    "package",
                    "private",
                    "protected",
                    "public",
                    "static",
                    "yield",
                    "eval",
                    "arguments",
                    "enum",
                    "await"
                ]);
                class me {
                    constructor(e1){
                        this.var = new Set, this.lexical = new Set, this.functions = new Set, this.flags = e1;
                    }
                }
                class Te {
                    constructor(e1, t){
                        this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = new Map, this.parser = e1, this.inModule = t;
                    }
                    get inTopLevel() {
                        return (1 & this.currentScope().flags) > 0;
                    }
                    get inFunction() {
                        return (2 & this.currentVarScopeFlags()) > 0;
                    }
                    get allowSuper() {
                        return (16 & this.currentThisScopeFlags()) > 0;
                    }
                    get allowDirectSuper() {
                        return (32 & this.currentThisScopeFlags()) > 0;
                    }
                    get inClass() {
                        return (64 & this.currentThisScopeFlags()) > 0;
                    }
                    get inClassAndNotInNonArrowFunction() {
                        const e1 = this.currentThisScopeFlags();
                        return (64 & e1) > 0 && 0 == (2 & e1);
                    }
                    get inStaticBlock() {
                        for(let e1 = this.scopeStack.length - 1;; e1--){
                            const { flags: t } = this.scopeStack[e1];
                            if (128 & t) return !0;
                            if (451 & t) return !1;
                        }
                    }
                    get inNonArrowFunction() {
                        return (2 & this.currentThisScopeFlags()) > 0;
                    }
                    get treatFunctionsAsVar() {
                        return this.treatFunctionsAsVarInScope(this.currentScope());
                    }
                    createScope(e1) {
                        return new me(e1);
                    }
                    enter(e1) {
                        this.scopeStack.push(this.createScope(e1));
                    }
                    exit() {
                        return this.scopeStack.pop().flags;
                    }
                    treatFunctionsAsVarInScope(e1) {
                        return !!(130 & e1.flags || !this.parser.inModule && 1 & e1.flags);
                    }
                    declareName(e1, t, n) {
                        let r = this.currentScope();
                        if (8 & t || 16 & t) this.checkRedeclarationInScope(r, e1, t, n), 16 & t ? r.functions.add(e1) : r.lexical.add(e1), 8 & t && this.maybeExportDefined(r, e1);
                        else if (4 & t) for(let i = this.scopeStack.length - 1; i >= 0 && (r = this.scopeStack[i], this.checkRedeclarationInScope(r, e1, t, n), r.var.add(e1), this.maybeExportDefined(r, e1), !(387 & r.flags)); --i);
                        this.parser.inModule && 1 & r.flags && this.undefinedExports.delete(e1);
                    }
                    maybeExportDefined(e1, t) {
                        this.parser.inModule && 1 & e1.flags && this.undefinedExports.delete(t);
                    }
                    checkRedeclarationInScope(e1, t, n, r) {
                        this.isRedeclaredInScope(e1, t, n) && this.parser.raise(g.VarRedeclaration, {
                            at: r,
                            identifierName: t
                        });
                    }
                    isRedeclaredInScope(e1, t, n) {
                        return !!(1 & n) && (8 & n ? e1.lexical.has(t) || e1.functions.has(t) || e1.var.has(t) : 16 & n ? e1.lexical.has(t) || !this.treatFunctionsAsVarInScope(e1) && e1.var.has(t) : e1.lexical.has(t) && !(8 & e1.flags && e1.lexical.values().next().value === t) || !this.treatFunctionsAsVarInScope(e1) && e1.functions.has(t));
                    }
                    checkLocalExport(e1) {
                        const { name: t } = e1, n = this.scopeStack[0];
                        n.lexical.has(t) || n.var.has(t) || n.functions.has(t) || this.undefinedExports.set(t, e1.loc.start);
                    }
                    currentScope() {
                        return this.scopeStack[this.scopeStack.length - 1];
                    }
                    currentVarScopeFlags() {
                        for(let e1 = this.scopeStack.length - 1;; e1--){
                            const { flags: t } = this.scopeStack[e1];
                            if (387 & t) return t;
                        }
                    }
                    currentThisScopeFlags() {
                        for(let e1 = this.scopeStack.length - 1;; e1--){
                            const { flags: t } = this.scopeStack[e1];
                            if (451 & t && !(4 & t)) return t;
                        }
                    }
                }
                class ge extends me {
                    constructor(...e1){
                        super(...e1), this.declareFunctions = new Set;
                    }
                }
                class be extends Te {
                    createScope(e1) {
                        return new ge(e1);
                    }
                    declareName(e1, t, n) {
                        const r = this.currentScope();
                        if (2048 & t) return this.checkRedeclarationInScope(r, e1, t, n), this.maybeExportDefined(r, e1), void r.declareFunctions.add(e1);
                        super.declareName(e1, t, n);
                    }
                    isRedeclaredInScope(e1, t, n) {
                        return !!super.isRedeclaredInScope(e1, t, n) || !!(2048 & n) && !e1.declareFunctions.has(t) && (e1.lexical.has(t) || e1.functions.has(t));
                    }
                    checkLocalExport(e1) {
                        this.scopeStack[0].declareFunctions.has(e1.name) || super.checkLocalExport(e1);
                    }
                }
                class Ee {
                    constructor(){
                        this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
                    }
                    hasPlugin(e1) {
                        if ("string" == typeof e1) return this.plugins.has(e1);
                        {
                            const [t, n] = e1;
                            if (!this.hasPlugin(t)) return !1;
                            const r = this.plugins.get(t);
                            for (const e1 of Object.keys(n))if ((null == r ? void 0 : r[e1]) !== n[e1]) return !1;
                            return !0;
                        }
                    }
                    getPluginOption(e1, t) {
                        var n;
                        return null == (n = this.plugins.get(e1)) ? void 0 : n[t];
                    }
                }
                function Se(e1, t) {
                    void 0 === e1.trailingComments ? e1.trailingComments = t : e1.trailingComments.unshift(...t);
                }
                function Pe(e1, t) {
                    void 0 === e1.innerComments ? e1.innerComments = t : e1.innerComments.unshift(...t);
                }
                function xe(e1, t, n) {
                    let r = null, i = t.length;
                    for(; null === r && i > 0;)r = t[--i];
                    null === r || r.start > n.start ? Pe(e1, n.comments) : Se(r, n.comments);
                }
                class De extends Ee {
                    addComment(e1) {
                        this.filename && (e1.loc.filename = this.filename), this.state.comments.push(e1);
                    }
                    processComment(e1) {
                        const { commentStack: t } = this.state, n = t.length;
                        if (0 === n) return;
                        let r = n - 1;
                        const i = t[r];
                        i.start === e1.end && (i.leadingNode = e1, r--);
                        const { start: s } = e1;
                        for(; r >= 0; r--){
                            const n = t[r], i = n.end;
                            if (!(i > s)) {
                                i === s && (n.trailingNode = e1);
                                break;
                            }
                            n.containingNode = e1, this.finalizeComment(n), t.splice(r, 1);
                        }
                    }
                    finalizeComment(e1) {
                        const { comments: t } = e1;
                        if (null !== e1.leadingNode || null !== e1.trailingNode) null !== e1.leadingNode && Se(e1.leadingNode, t), null !== e1.trailingNode && function(e1, t) {
                            void 0 === e1.leadingComments ? e1.leadingComments = t : e1.leadingComments.unshift(...t);
                        }(e1.trailingNode, t);
                        else {
                            const { containingNode: n, start: r } = e1;
                            if (44 === this.input.charCodeAt(r - 1)) switch(n.type){
                                case "ObjectExpression":
                                case "ObjectPattern":
                                case "RecordExpression":
                                    xe(n, n.properties, e1);
                                    break;
                                case "CallExpression":
                                case "OptionalCallExpression":
                                    xe(n, n.arguments, e1);
                                    break;
                                case "FunctionDeclaration":
                                case "FunctionExpression":
                                case "ArrowFunctionExpression":
                                case "ObjectMethod":
                                case "ClassMethod":
                                case "ClassPrivateMethod":
                                    xe(n, n.params, e1);
                                    break;
                                case "ArrayExpression":
                                case "ArrayPattern":
                                case "TupleExpression":
                                    xe(n, n.elements, e1);
                                    break;
                                case "ExportNamedDeclaration":
                                case "ImportDeclaration":
                                    xe(n, n.specifiers, e1);
                                    break;
                                default:
                                    Pe(n, t);
                            }
                            else Pe(n, t);
                        }
                    }
                    finalizeRemainingComments() {
                        const { commentStack: e1 } = this.state;
                        for(let t = e1.length - 1; t >= 0; t--)this.finalizeComment(e1[t]);
                        this.state.commentStack = [];
                    }
                    resetPreviousNodeTrailingComments(e1) {
                        const { commentStack: t } = this.state, { length: n } = t;
                        if (0 === n) return;
                        const r = t[n - 1];
                        r.leadingNode === e1 && (r.leadingNode = null);
                    }
                    resetPreviousIdentifierLeadingComments(e1) {
                        const { commentStack: t } = this.state, { length: n } = t;
                        0 !== n && (t[n - 1].trailingNode === e1 ? t[n - 1].trailingNode = null : n >= 2 && t[n - 2].trailingNode === e1 && (t[n - 2].trailingNode = null));
                    }
                    takeSurroundingComments(e1, t, n) {
                        const { commentStack: r } = this.state, i = r.length;
                        if (0 === i) return;
                        let s = i - 1;
                        for(; s >= 0; s--){
                            const i = r[s], a = i.end;
                            if (i.start === n) i.leadingNode = e1;
                            else if (a === t) i.trailingNode = e1;
                            else if (a < t) break;
                        }
                    }
                }
                const Ae = /\r\n?|[\n\u2028\u2029]/, ve = new RegExp(Ae.source, "g");
                function Ce(e1) {
                    switch(e1){
                        case 10:
                        case 13:
                        case 8232:
                        case 8233:
                            return !0;
                        default:
                            return !1;
                    }
                }
                const we = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Oe = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, Ie = new RegExp("(?=(" + Oe.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
                function Ne(e1) {
                    switch(e1){
                        case 9:
                        case 11:
                        case 12:
                        case 32:
                        case 160:
                        case 5760:
                        case 8192:
                        case 8193:
                        case 8194:
                        case 8195:
                        case 8196:
                        case 8197:
                        case 8198:
                        case 8199:
                        case 8200:
                        case 8201:
                        case 8202:
                        case 8239:
                        case 8287:
                        case 12288:
                        case 65279:
                            return !0;
                        default:
                            return !1;
                    }
                }
                class Fe {
                    constructor(){
                        this.strict = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = !1, this.inType = !1, this.noAnonFunctionType = !1, this.hasFlowComment = !1, this.isAmbientContext = !1, this.inAbstractClass = !1, this.inDisallowConditionalTypesContext = !1, this.topicContext = {
                            maxNumOfResolvableTopics: 0,
                            maxTopicIndex: null
                        }, this.soloAwait = !1, this.inFSharpPipelineDirectBody = !1, this.labels = [], this.comments = [], this.commentStack = [], this.pos = 0, this.type = 137, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.context = [
                            x.brace
                        ], this.canStartJSXElement = !0, this.containsEsc = !1, this.firstInvalidTemplateEscapePos = null, this.strictErrors = new Map, this.tokensLength = 0;
                    }
                    init({ strictMode: e1, sourceType: t, startLine: n, startColumn: i }) {
                        this.strict = !1 !== e1 && (!0 === e1 || "module" === t), this.curLine = n, this.lineStart = -i, this.startLoc = this.endLoc = new r(n, i, 0);
                    }
                    curPosition() {
                        return new r(this.curLine, this.pos - this.lineStart, this.pos);
                    }
                    clone(e1) {
                        const t = new Fe, n = Object.keys(this);
                        for(let r = 0, i = n.length; r < i; r++){
                            const i = n[r];
                            let s = this[i];
                            !e1 && Array.isArray(s) && (s = s.slice()), t[i] = s;
                        }
                        return t;
                    }
                }
                var ke = function(e1) {
                    return e1 >= 48 && e1 <= 57;
                };
                const Le = {
                    decBinOct: new Set([
                        46,
                        66,
                        69,
                        79,
                        95,
                        98,
                        101,
                        111
                    ]),
                    hex: new Set([
                        46,
                        88,
                        95,
                        120
                    ])
                }, _e = {
                    bin: (e1)=>48 === e1 || 49 === e1,
                    oct: (e1)=>e1 >= 48 && e1 <= 55,
                    dec: (e1)=>e1 >= 48 && e1 <= 57,
                    hex: (e1)=>e1 >= 48 && e1 <= 57 || e1 >= 65 && e1 <= 70 || e1 >= 97 && e1 <= 102
                };
                function Me(e1, t, n, r, i, s) {
                    const a = n, o = r, l = i;
                    let c = "", u = null, p = n;
                    const { length: h } = t;
                    for(;;){
                        if (n >= h) {
                            s.unterminated(a, o, l), c += t.slice(p, n);
                            break;
                        }
                        const d = t.charCodeAt(n);
                        if (Be(e1, d, t, n)) {
                            c += t.slice(p, n);
                            break;
                        }
                        if (92 === d) {
                            c += t.slice(p, n);
                            const a = je(t, n, r, i, "template" === e1, s);
                            null !== a.ch || u ? c += a.ch : u = {
                                pos: n,
                                lineStart: r,
                                curLine: i
                            }, ({ pos: n, lineStart: r, curLine: i } = a), p = n;
                        } else 8232 === d || 8233 === d ? (++i, r = ++n) : 10 === d || 13 === d ? "template" === e1 ? (c += t.slice(p, n) + "\n", ++n, 13 === d && 10 === t.charCodeAt(n) && ++n, ++i, p = r = n) : s.unterminated(a, o, l) : ++n;
                    }
                    return {
                        pos: n,
                        str: c,
                        firstInvalidLoc: u,
                        lineStart: r,
                        curLine: i,
                        containsInvalid: !!u
                    };
                }
                function Be(e1, t, n, r) {
                    return "template" === e1 ? 96 === t || 36 === t && 123 === n.charCodeAt(r + 1) : t === ("double" === e1 ? 34 : 39);
                }
                function je(e1, t, n, r, i, s) {
                    const a = !i;
                    t++;
                    const o = (e1)=>({
                            pos: t,
                            ch: e1,
                            lineStart: n,
                            curLine: r
                        }), l = e1.charCodeAt(t++);
                    switch(l){
                        case 110:
                            return o("\n");
                        case 114:
                            return o("\r");
                        case 120:
                            {
                                let i;
                                return { code: i, pos: t } = Re(e1, t, n, r, 2, !1, a, s), o(null === i ? null : String.fromCharCode(i));
                            }
                        case 117:
                            {
                                let i;
                                return { code: i, pos: t } = Ve(e1, t, n, r, a, s), o(null === i ? null : String.fromCodePoint(i));
                            }
                        case 116:
                            return o("\t");
                        case 98:
                            return o("\b");
                        case 118:
                            return o("\v");
                        case 102:
                            return o("\f");
                        case 13:
                            10 === e1.charCodeAt(t) && ++t;
                        case 10:
                            n = t, ++r;
                        case 8232:
                        case 8233:
                            return o("");
                        case 56:
                        case 57:
                            if (i) return o(null);
                            s.strictNumericEscape(t - 1, n, r);
                        default:
                            if (l >= 48 && l <= 55) {
                                const a = t - 1;
                                let l = e1.slice(a, t + 2).match(/^[0-7]+/)[0], c = parseInt(l, 8);
                                c > 255 && (l = l.slice(0, -1), c = parseInt(l, 8)), t += l.length - 1;
                                const u = e1.charCodeAt(t);
                                if ("0" !== l || 56 === u || 57 === u) {
                                    if (i) return o(null);
                                    s.strictNumericEscape(a, n, r);
                                }
                                return o(String.fromCharCode(c));
                            }
                            return o(String.fromCharCode(l));
                    }
                }
                function Re(e1, t, n, r, i, s, a, o) {
                    const l = t;
                    let c;
                    return { n: c, pos: t } = Ue(e1, t, n, r, 16, i, s, !1, o, !a), null === c && (a ? o.invalidEscapeSequence(l, n, r) : t = l - 1), {
                        code: c,
                        pos: t
                    };
                }
                function Ue(e1, t, n, r, i, s, a, o, l, c) {
                    const u = t, p = 16 === i ? Le.hex : Le.decBinOct, h = 16 === i ? _e.hex : 10 === i ? _e.dec : 8 === i ? _e.oct : _e.bin;
                    let d = !1, f = 0;
                    for(let u = 0, y = null == s ? 1 / 0 : s; u < y; ++u){
                        const s = e1.charCodeAt(t);
                        let u;
                        if (95 !== s || "bail" === o) {
                            if (u = s >= 97 ? s - 97 + 10 : s >= 65 ? s - 65 + 10 : ke(s) ? s - 48 : 1 / 0, u >= i) {
                                if (u <= 9 && c) return {
                                    n: null,
                                    pos: t
                                };
                                if (u <= 9 && l.invalidDigit(t, n, r, i)) u = 0;
                                else {
                                    if (!a) break;
                                    u = 0, d = !0;
                                }
                            }
                            ++t, f = f * i + u;
                        } else {
                            const i = e1.charCodeAt(t - 1), s = e1.charCodeAt(t + 1);
                            if (o) {
                                if (Number.isNaN(s) || !h(s) || p.has(i) || p.has(s)) {
                                    if (c) return {
                                        n: null,
                                        pos: t
                                    };
                                    l.unexpectedNumericSeparator(t, n, r);
                                }
                            } else {
                                if (c) return {
                                    n: null,
                                    pos: t
                                };
                                l.numericSeparatorInEscapeSequence(t, n, r);
                            }
                            ++t;
                        }
                    }
                    return t === u || null != s && t - u !== s || d ? {
                        n: null,
                        pos: t
                    } : {
                        n: f,
                        pos: t
                    };
                }
                function Ve(e1, t, n, r, i, s) {
                    let a;
                    if (123 === e1.charCodeAt(t)) {
                        if (++t, { code: a, pos: t } = Re(e1, t, n, r, e1.indexOf("}", t) - t, !0, i, s), ++t, null !== a && a > 1114111) {
                            if (!i) return {
                                code: null,
                                pos: t
                            };
                            s.invalidCodePoint(t, n, r);
                        }
                    } else ({ code: a, pos: t } = Re(e1, t, n, r, 4, !1, i, s));
                    return {
                        code: a,
                        pos: t
                    };
                }
                const Ke = [
                    "at"
                ], We = [
                    "at"
                ];
                function Xe(e1, t, n) {
                    return new r(n, e1 - t, e1);
                }
                const Ye = new Set([
                    103,
                    109,
                    115,
                    105,
                    121,
                    117,
                    100,
                    118
                ]);
                class qe {
                    constructor(e1){
                        this.type = e1.type, this.value = e1.value, this.start = e1.start, this.end = e1.end, this.loc = new i(e1.startLoc, e1.endLoc);
                    }
                }
                class He extends De {
                    constructor(e1, t){
                        super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
                            invalidDigit: (e1, t, n, r)=>!!this.options.errorRecovery && (this.raise(g.InvalidDigit, {
                                    at: Xe(e1, t, n),
                                    radix: r
                                }), !0),
                            numericSeparatorInEscapeSequence: this.errorBuilder(g.NumericSeparatorInEscapeSequence),
                            unexpectedNumericSeparator: this.errorBuilder(g.UnexpectedNumericSeparator)
                        }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
                            invalidEscapeSequence: this.errorBuilder(g.InvalidEscapeSequence),
                            invalidCodePoint: this.errorBuilder(g.InvalidCodePoint)
                        }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
                            strictNumericEscape: (e1, t, n)=>{
                                this.recordStrictModeErrors(g.StrictNumericEscape, {
                                    at: Xe(e1, t, n)
                                });
                            },
                            unterminated: (e1, t, n)=>{
                                throw this.raise(g.UnterminatedString, {
                                    at: Xe(e1 - 1, t, n)
                                });
                            }
                        }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
                            strictNumericEscape: this.errorBuilder(g.StrictNumericEscape),
                            unterminated: (e1, t, n)=>{
                                throw this.raise(g.UnterminatedTemplate, {
                                    at: Xe(e1, t, n)
                                });
                            }
                        }), this.state = new Fe, this.state.init(e1), this.input = t, this.length = t.length, this.isLookahead = !1;
                    }
                    pushToken(e1) {
                        this.tokens.length = this.state.tokensLength, this.tokens.push(e1), ++this.state.tokensLength;
                    }
                    next() {
                        this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new qe(this.state)), this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
                    }
                    eat(e1) {
                        return !!this.match(e1) && (this.next(), !0);
                    }
                    match(e1) {
                        return this.state.type === e1;
                    }
                    createLookaheadState(e1) {
                        return {
                            pos: e1.pos,
                            value: null,
                            type: e1.type,
                            start: e1.start,
                            end: e1.end,
                            context: [
                                this.curContext()
                            ],
                            inType: e1.inType,
                            startLoc: e1.startLoc,
                            lastTokEndLoc: e1.lastTokEndLoc,
                            curLine: e1.curLine,
                            lineStart: e1.lineStart,
                            curPosition: e1.curPosition
                        };
                    }
                    lookahead() {
                        const e1 = this.state;
                        this.state = this.createLookaheadState(e1), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
                        const t = this.state;
                        return this.state = e1, t;
                    }
                    nextTokenStart() {
                        return this.nextTokenStartSince(this.state.pos);
                    }
                    nextTokenStartSince(e1) {
                        return we.lastIndex = e1, we.test(this.input) ? we.lastIndex : e1;
                    }
                    lookaheadCharCode() {
                        return this.input.charCodeAt(this.nextTokenStart());
                    }
                    nextTokenInLineStart() {
                        return this.nextTokenInLineStartSince(this.state.pos);
                    }
                    nextTokenInLineStartSince(e1) {
                        return Oe.lastIndex = e1, Oe.test(this.input) ? Oe.lastIndex : e1;
                    }
                    lookaheadInLineCharCode() {
                        return this.input.charCodeAt(this.nextTokenInLineStart());
                    }
                    codePointAtPos(e1) {
                        let t = this.input.charCodeAt(e1);
                        if (55296 == (64512 & t) && ++e1 < this.input.length) {
                            const n = this.input.charCodeAt(e1);
                            56320 == (64512 & n) && (t = 65536 + ((1023 & t) << 10) + (1023 & n));
                        }
                        return t;
                    }
                    setStrict(e1) {
                        this.state.strict = e1, e1 && (this.state.strictErrors.forEach(([e1, t])=>this.raise(e1, {
                                at: t
                            })), this.state.strictErrors.clear());
                    }
                    curContext() {
                        return this.state.context[this.state.context.length - 1];
                    }
                    nextToken() {
                        this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length ? this.finishToken(137) : this.getTokenFromCode(this.codePointAtPos(this.state.pos));
                    }
                    skipBlockComment(e1) {
                        let t;
                        this.isLookahead || (t = this.state.curPosition());
                        const n = this.state.pos, r = this.input.indexOf(e1, n + 2);
                        if (-1 === r) throw this.raise(g.UnterminatedComment, {
                            at: this.state.curPosition()
                        });
                        for(this.state.pos = r + e1.length, ve.lastIndex = n + 2; ve.test(this.input) && ve.lastIndex <= r;)++this.state.curLine, this.state.lineStart = ve.lastIndex;
                        if (this.isLookahead) return;
                        const s = {
                            type: "CommentBlock",
                            value: this.input.slice(n + 2, r),
                            start: n,
                            end: r + e1.length,
                            loc: new i(t, this.state.curPosition())
                        };
                        return this.options.tokens && this.pushToken(s), s;
                    }
                    skipLineComment(e1) {
                        const t = this.state.pos;
                        let n;
                        this.isLookahead || (n = this.state.curPosition());
                        let r = this.input.charCodeAt(this.state.pos += e1);
                        if (this.state.pos < this.length) for(; !Ce(r) && ++this.state.pos < this.length;)r = this.input.charCodeAt(this.state.pos);
                        if (this.isLookahead) return;
                        const s = this.state.pos, a = {
                            type: "CommentLine",
                            value: this.input.slice(t + e1, s),
                            start: t,
                            end: s,
                            loc: new i(n, this.state.curPosition())
                        };
                        return this.options.tokens && this.pushToken(a), a;
                    }
                    skipSpace() {
                        const e1 = this.state.pos, t = [];
                        e: for(; this.state.pos < this.length;){
                            const n = this.input.charCodeAt(this.state.pos);
                            switch(n){
                                case 32:
                                case 160:
                                case 9:
                                    ++this.state.pos;
                                    break;
                                case 13:
                                    10 === this.input.charCodeAt(this.state.pos + 1) && ++this.state.pos;
                                case 10:
                                case 8232:
                                case 8233:
                                    ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                                    break;
                                case 47:
                                    switch(this.input.charCodeAt(this.state.pos + 1)){
                                        case 42:
                                            {
                                                const e1 = this.skipBlockComment("*/");
                                                void 0 !== e1 && (this.addComment(e1), this.options.attachComment && t.push(e1));
                                                break;
                                            }
                                        case 47:
                                            {
                                                const e1 = this.skipLineComment(2);
                                                void 0 !== e1 && (this.addComment(e1), this.options.attachComment && t.push(e1));
                                                break;
                                            }
                                        default:
                                            break e;
                                    }
                                    break;
                                default:
                                    if (Ne(n)) ++this.state.pos;
                                    else if (45 === n && !this.inModule && this.options.annexB) {
                                        const n = this.state.pos;
                                        if (45 !== this.input.charCodeAt(n + 1) || 62 !== this.input.charCodeAt(n + 2) || !(0 === e1 || this.state.lineStart > e1)) break e;
                                        {
                                            const e1 = this.skipLineComment(3);
                                            void 0 !== e1 && (this.addComment(e1), this.options.attachComment && t.push(e1));
                                        }
                                    } else {
                                        if (60 !== n || this.inModule || !this.options.annexB) break e;
                                        {
                                            const e1 = this.state.pos;
                                            if (33 !== this.input.charCodeAt(e1 + 1) || 45 !== this.input.charCodeAt(e1 + 2) || 45 !== this.input.charCodeAt(e1 + 3)) break e;
                                            {
                                                const e1 = this.skipLineComment(4);
                                                void 0 !== e1 && (this.addComment(e1), this.options.attachComment && t.push(e1));
                                            }
                                        }
                                    }
                            }
                        }
                        if (t.length > 0) {
                            const n = {
                                start: e1,
                                end: this.state.pos,
                                comments: t,
                                leadingNode: null,
                                trailingNode: null,
                                containingNode: null
                            };
                            this.state.commentStack.push(n);
                        }
                    }
                    finishToken(e1, t) {
                        this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
                        const n = this.state.type;
                        this.state.type = e1, this.state.value = t, this.isLookahead || this.updateContext(n);
                    }
                    replaceToken(e1) {
                        this.state.type = e1, this.updateContext();
                    }
                    readToken_numberSign() {
                        if (0 === this.state.pos && this.readToken_interpreter()) return;
                        const e1 = this.state.pos + 1, t = this.codePointAtPos(e1);
                        if (t >= 48 && t <= 57) throw this.raise(g.UnexpectedDigitAfterHash, {
                            at: this.state.curPosition()
                        });
                        if (123 === t || 91 === t && this.hasPlugin("recordAndTuple")) {
                            if (this.expectPlugin("recordAndTuple"), "bar" === this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(123 === t ? g.RecordExpressionHashIncorrectStartSyntaxType : g.TupleExpressionHashIncorrectStartSyntaxType, {
                                at: this.state.curPosition()
                            });
                            this.state.pos += 2, 123 === t ? this.finishToken(7) : this.finishToken(1);
                        } else ae(t) ? (++this.state.pos, this.finishToken(136, this.readWord1(t))) : 92 === t ? (++this.state.pos, this.finishToken(136, this.readWord1())) : this.finishOp(27, 1);
                    }
                    readToken_dot() {
                        const e1 = this.input.charCodeAt(this.state.pos + 1);
                        e1 >= 48 && e1 <= 57 ? this.readNumber(!0) : 46 === e1 && 46 === this.input.charCodeAt(this.state.pos + 2) ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
                    }
                    readToken_slash() {
                        61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(31, 2) : this.finishOp(56, 1);
                    }
                    readToken_interpreter() {
                        if (0 !== this.state.pos || this.length < 2) return !1;
                        let e1 = this.input.charCodeAt(this.state.pos + 1);
                        if (33 !== e1) return !1;
                        const t = this.state.pos;
                        for(this.state.pos += 1; !Ce(e1) && ++this.state.pos < this.length;)e1 = this.input.charCodeAt(this.state.pos);
                        const n = this.input.slice(t + 2, this.state.pos);
                        return this.finishToken(28, n), !0;
                    }
                    readToken_mult_modulo(e1) {
                        let t = 42 === e1 ? 55 : 54, n = 1, r = this.input.charCodeAt(this.state.pos + 1);
                        42 === e1 && 42 === r && (n++, r = this.input.charCodeAt(this.state.pos + 2), t = 57), 61 !== r || this.state.inType || (n++, t = 37 === e1 ? 33 : 30), this.finishOp(t, n);
                    }
                    readToken_pipe_amp(e1) {
                        const t = this.input.charCodeAt(this.state.pos + 1);
                        if (t !== e1) {
                            if (124 === e1) {
                                if (62 === t) return void this.finishOp(39, 2);
                                if (this.hasPlugin("recordAndTuple") && 125 === t) {
                                    if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(g.RecordExpressionBarIncorrectEndSyntaxType, {
                                        at: this.state.curPosition()
                                    });
                                    return this.state.pos += 2, void this.finishToken(9);
                                }
                                if (this.hasPlugin("recordAndTuple") && 93 === t) {
                                    if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(g.TupleExpressionBarIncorrectEndSyntaxType, {
                                        at: this.state.curPosition()
                                    });
                                    return this.state.pos += 2, void this.finishToken(4);
                                }
                            }
                            61 !== t ? this.finishOp(124 === e1 ? 43 : 45, 1) : this.finishOp(30, 2);
                        } else 61 === this.input.charCodeAt(this.state.pos + 2) ? this.finishOp(30, 3) : this.finishOp(124 === e1 ? 41 : 42, 2);
                    }
                    readToken_caret() {
                        const e1 = this.input.charCodeAt(this.state.pos + 1);
                        61 !== e1 || this.state.inType ? 94 === e1 && this.hasPlugin([
                            "pipelineOperator",
                            {
                                proposal: "hack",
                                topicToken: "^^"
                            }
                        ]) ? (this.finishOp(37, 2), 94 === this.input.codePointAt(this.state.pos) && this.unexpected()) : this.finishOp(44, 1) : this.finishOp(32, 2);
                    }
                    readToken_atSign() {
                        64 === this.input.charCodeAt(this.state.pos + 1) && this.hasPlugin([
                            "pipelineOperator",
                            {
                                proposal: "hack",
                                topicToken: "@@"
                            }
                        ]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
                    }
                    readToken_plus_min(e1) {
                        const t = this.input.charCodeAt(this.state.pos + 1);
                        t !== e1 ? 61 === t ? this.finishOp(30, 2) : this.finishOp(53, 1) : this.finishOp(34, 2);
                    }
                    readToken_lt() {
                        const { pos: e1 } = this.state, t = this.input.charCodeAt(e1 + 1);
                        if (60 === t) return 61 === this.input.charCodeAt(e1 + 2) ? void this.finishOp(30, 3) : void this.finishOp(51, 2);
                        61 !== t ? this.finishOp(47, 1) : this.finishOp(49, 2);
                    }
                    readToken_gt() {
                        const { pos: e1 } = this.state, t = this.input.charCodeAt(e1 + 1);
                        if (62 === t) {
                            const t = 62 === this.input.charCodeAt(e1 + 2) ? 3 : 2;
                            return 61 === this.input.charCodeAt(e1 + t) ? void this.finishOp(30, t + 1) : void this.finishOp(52, t);
                        }
                        61 !== t ? this.finishOp(48, 1) : this.finishOp(49, 2);
                    }
                    readToken_eq_excl(e1) {
                        const t = this.input.charCodeAt(this.state.pos + 1);
                        if (61 !== t) return 61 === e1 && 62 === t ? (this.state.pos += 2, void this.finishToken(19)) : void this.finishOp(61 === e1 ? 29 : 35, 1);
                        this.finishOp(46, 61 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2);
                    }
                    readToken_question() {
                        const e1 = this.input.charCodeAt(this.state.pos + 1), t = this.input.charCodeAt(this.state.pos + 2);
                        63 === e1 ? 61 === t ? this.finishOp(30, 3) : this.finishOp(40, 2) : 46 !== e1 || t >= 48 && t <= 57 ? (++this.state.pos, this.finishToken(17)) : (this.state.pos += 2, this.finishToken(18));
                    }
                    getTokenFromCode(e1) {
                        switch(e1){
                            case 46:
                                return void this.readToken_dot();
                            case 40:
                                return ++this.state.pos, void this.finishToken(10);
                            case 41:
                                return ++this.state.pos, void this.finishToken(11);
                            case 59:
                                return ++this.state.pos, void this.finishToken(13);
                            case 44:
                                return ++this.state.pos, void this.finishToken(12);
                            case 91:
                                if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
                                    if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(g.TupleExpressionBarIncorrectStartSyntaxType, {
                                        at: this.state.curPosition()
                                    });
                                    this.state.pos += 2, this.finishToken(2);
                                } else ++this.state.pos, this.finishToken(0);
                                return;
                            case 93:
                                return ++this.state.pos, void this.finishToken(3);
                            case 123:
                                if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
                                    if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(g.RecordExpressionBarIncorrectStartSyntaxType, {
                                        at: this.state.curPosition()
                                    });
                                    this.state.pos += 2, this.finishToken(6);
                                } else ++this.state.pos, this.finishToken(5);
                                return;
                            case 125:
                                return ++this.state.pos, void this.finishToken(8);
                            case 58:
                                return void (this.hasPlugin("functionBind") && 58 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14)));
                            case 63:
                                return void this.readToken_question();
                            case 96:
                                return void this.readTemplateToken();
                            case 48:
                                {
                                    const e1 = this.input.charCodeAt(this.state.pos + 1);
                                    if (120 === e1 || 88 === e1) return void this.readRadixNumber(16);
                                    if (111 === e1 || 79 === e1) return void this.readRadixNumber(8);
                                    if (98 === e1 || 66 === e1) return void this.readRadixNumber(2);
                                }
                            case 49:
                            case 50:
                            case 51:
                            case 52:
                            case 53:
                            case 54:
                            case 55:
                            case 56:
                            case 57:
                                return void this.readNumber(!1);
                            case 34:
                            case 39:
                                return void this.readString(e1);
                            case 47:
                                return void this.readToken_slash();
                            case 37:
                            case 42:
                                return void this.readToken_mult_modulo(e1);
                            case 124:
                            case 38:
                                return void this.readToken_pipe_amp(e1);
                            case 94:
                                return void this.readToken_caret();
                            case 43:
                            case 45:
                                return void this.readToken_plus_min(e1);
                            case 60:
                                return void this.readToken_lt();
                            case 62:
                                return void this.readToken_gt();
                            case 61:
                            case 33:
                                return void this.readToken_eq_excl(e1);
                            case 126:
                                return void this.finishOp(36, 1);
                            case 64:
                                return void this.readToken_atSign();
                            case 35:
                                return void this.readToken_numberSign();
                            case 92:
                                return void this.readWord();
                            default:
                                if (ae(e1)) return void this.readWord(e1);
                        }
                        throw this.raise(g.InvalidOrUnexpectedToken, {
                            at: this.state.curPosition(),
                            unexpected: String.fromCodePoint(e1)
                        });
                    }
                    finishOp(e1, t) {
                        const n = this.input.slice(this.state.pos, this.state.pos + t);
                        this.state.pos += t, this.finishToken(e1, n);
                    }
                    readRegexp() {
                        const e1 = this.state.startLoc, t = this.state.start + 1;
                        let n, r, { pos: i } = this.state;
                        for(;; ++i){
                            if (i >= this.length) throw this.raise(g.UnterminatedRegExp, {
                                at: s(e1, 1)
                            });
                            const t = this.input.charCodeAt(i);
                            if (Ce(t)) throw this.raise(g.UnterminatedRegExp, {
                                at: s(e1, 1)
                            });
                            if (n) n = !1;
                            else {
                                if (91 === t) r = !0;
                                else if (93 === t && r) r = !1;
                                else if (47 === t && !r) break;
                                n = 92 === t;
                            }
                        }
                        const a = this.input.slice(t, i);
                        ++i;
                        let o = "";
                        const l = ()=>s(e1, i + 2 - t);
                        for(; i < this.length;){
                            const e1 = this.codePointAtPos(i), t = String.fromCharCode(e1);
                            if (Ye.has(e1)) 118 === e1 ? o.includes("u") && this.raise(g.IncompatibleRegExpUVFlags, {
                                at: l()
                            }) : 117 === e1 && o.includes("v") && this.raise(g.IncompatibleRegExpUVFlags, {
                                at: l()
                            }), o.includes(t) && this.raise(g.DuplicateRegExpFlags, {
                                at: l()
                            });
                            else {
                                if (!oe(e1) && 92 !== e1) break;
                                this.raise(g.MalformedRegExpFlags, {
                                    at: l()
                                });
                            }
                            ++i, o += t;
                        }
                        this.state.pos = i, this.finishToken(135, {
                            pattern: a,
                            flags: o
                        });
                    }
                    readInt(e1, t, n = !1, r = !0) {
                        const { n: i, pos: s } = Ue(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e1, t, n, r, this.errorHandlers_readInt, !1);
                        return this.state.pos = s, i;
                    }
                    readRadixNumber(e1) {
                        const t = this.state.curPosition();
                        let n = !1;
                        this.state.pos += 2;
                        const r = this.readInt(e1);
                        null == r && this.raise(g.InvalidDigit, {
                            at: s(t, 2),
                            radix: e1
                        });
                        const i = this.input.charCodeAt(this.state.pos);
                        if (110 === i) ++this.state.pos, n = !0;
                        else if (109 === i) throw this.raise(g.InvalidDecimal, {
                            at: t
                        });
                        if (ae(this.codePointAtPos(this.state.pos))) throw this.raise(g.NumberIdentifier, {
                            at: this.state.curPosition()
                        });
                        if (n) {
                            const e1 = this.input.slice(t.index, this.state.pos).replace(/[_n]/g, "");
                            this.finishToken(133, e1);
                        } else this.finishToken(132, r);
                    }
                    readNumber(e1) {
                        const t = this.state.pos, n = this.state.curPosition();
                        let r = !1, i = !1, a = !1, o = !1, l = !1;
                        e1 || null !== this.readInt(10) || this.raise(g.InvalidNumber, {
                            at: this.state.curPosition()
                        });
                        const c = this.state.pos - t >= 2 && 48 === this.input.charCodeAt(t);
                        if (c) {
                            const e1 = this.input.slice(t, this.state.pos);
                            if (this.recordStrictModeErrors(g.StrictOctalLiteral, {
                                at: n
                            }), !this.state.strict) {
                                const t = e1.indexOf("_");
                                t > 0 && this.raise(g.ZeroDigitNumericSeparator, {
                                    at: s(n, t)
                                });
                            }
                            l = c && !/[89]/.test(e1);
                        }
                        let u = this.input.charCodeAt(this.state.pos);
                        if (46 !== u || l || (++this.state.pos, this.readInt(10), r = !0, u = this.input.charCodeAt(this.state.pos)), 69 !== u && 101 !== u || l || (u = this.input.charCodeAt(++this.state.pos), 43 !== u && 45 !== u || ++this.state.pos, null === this.readInt(10) && this.raise(g.InvalidOrMissingExponent, {
                            at: n
                        }), r = !0, o = !0, u = this.input.charCodeAt(this.state.pos)), 110 === u && ((r || c) && this.raise(g.InvalidBigIntLiteral, {
                            at: n
                        }), ++this.state.pos, i = !0), 109 === u && (this.expectPlugin("decimal", this.state.curPosition()), (o || c) && this.raise(g.InvalidDecimal, {
                            at: n
                        }), ++this.state.pos, a = !0), ae(this.codePointAtPos(this.state.pos))) throw this.raise(g.NumberIdentifier, {
                            at: this.state.curPosition()
                        });
                        const p = this.input.slice(t, this.state.pos).replace(/[_mn]/g, "");
                        if (i) return void this.finishToken(133, p);
                        if (a) return void this.finishToken(134, p);
                        const h = l ? parseInt(p, 8) : parseFloat(p);
                        this.finishToken(132, h);
                    }
                    readCodePoint(e1) {
                        const { code: t, pos: n } = Ve(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e1, this.errorHandlers_readCodePoint);
                        return this.state.pos = n, t;
                    }
                    readString(e1) {
                        const { str: t, pos: n, curLine: r, lineStart: i } = Me(34 === e1 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
                        this.state.pos = n + 1, this.state.lineStart = i, this.state.curLine = r, this.finishToken(131, t);
                    }
                    readTemplateContinuation() {
                        this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
                    }
                    readTemplateToken() {
                        const e1 = this.input[this.state.pos], { str: t, firstInvalidLoc: n, pos: i, curLine: s, lineStart: a } = Me("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
                        this.state.pos = i + 1, this.state.lineStart = a, this.state.curLine = s, n && (this.state.firstInvalidTemplateEscapePos = new r(n.curLine, n.pos - n.lineStart, n.pos)), 96 === this.input.codePointAt(i) ? this.finishToken(24, n ? null : e1 + t + "`") : (this.state.pos++, this.finishToken(25, n ? null : e1 + t + "${"));
                    }
                    recordStrictModeErrors(e1, { at: t }) {
                        const n = t.index;
                        this.state.strict && !this.state.strictErrors.has(n) ? this.raise(e1, {
                            at: t
                        }) : this.state.strictErrors.set(n, [
                            e1,
                            t
                        ]);
                    }
                    readWord1(e1) {
                        this.state.containsEsc = !1;
                        let t = "";
                        const n = this.state.pos;
                        let r = this.state.pos;
                        for(void 0 !== e1 && (this.state.pos += e1 <= 65535 ? 1 : 2); this.state.pos < this.length;){
                            const e1 = this.codePointAtPos(this.state.pos);
                            if (oe(e1)) this.state.pos += e1 <= 65535 ? 1 : 2;
                            else {
                                if (92 !== e1) break;
                                {
                                    this.state.containsEsc = !0, t += this.input.slice(r, this.state.pos);
                                    const e1 = this.state.curPosition(), i = this.state.pos === n ? ae : oe;
                                    if (117 !== this.input.charCodeAt(++this.state.pos)) {
                                        this.raise(g.MissingUnicodeEscape, {
                                            at: this.state.curPosition()
                                        }), r = this.state.pos - 1;
                                        continue;
                                    }
                                    ++this.state.pos;
                                    const s = this.readCodePoint(!0);
                                    null !== s && (i(s) || this.raise(g.EscapedCharNotAnIdentifier, {
                                        at: e1
                                    }), t += String.fromCodePoint(s)), r = this.state.pos;
                                }
                            }
                        }
                        return t + this.input.slice(r, this.state.pos);
                    }
                    readWord(e1) {
                        const t = this.readWord1(e1), n = I.get(t);
                        void 0 !== n ? this.finishToken(n, $(n)) : this.finishToken(130, t);
                    }
                    checkKeywordEscapes() {
                        const { type: e1 } = this.state;
                        J(e1) && this.state.containsEsc && this.raise(g.InvalidEscapedReservedWord, {
                            at: this.state.startLoc,
                            reservedWord: $(e1)
                        });
                    }
                    raise(e1, t) {
                        const { at: i } = t, s = n(t, Ke), a = e1({
                            loc: i instanceof r ? i : i.loc.start,
                            details: s
                        });
                        if (!this.options.errorRecovery) throw a;
                        return this.isLookahead || this.state.errors.push(a), a;
                    }
                    raiseOverwrite(e1, t) {
                        const { at: i } = t, s = n(t, We), a = i instanceof r ? i : i.loc.start, o = a.index, l = this.state.errors;
                        for(let t = l.length - 1; t >= 0; t--){
                            const n = l[t];
                            if (n.loc.index === o) return l[t] = e1({
                                loc: a,
                                details: s
                            });
                            if (n.loc.index < o) break;
                        }
                        return this.raise(e1, t);
                    }
                    updateContext(e1) {}
                    unexpected(e1, t) {
                        throw this.raise(g.UnexpectedToken, {
                            expected: t ? $(t) : null,
                            at: null != e1 ? e1 : this.state.startLoc
                        });
                    }
                    expectPlugin(e1, t) {
                        if (this.hasPlugin(e1)) return !0;
                        throw this.raise(g.MissingPlugin, {
                            at: null != t ? t : this.state.startLoc,
                            missingPlugin: [
                                e1
                            ]
                        });
                    }
                    expectOnePlugin(e1) {
                        if (!e1.some((e1)=>this.hasPlugin(e1))) throw this.raise(g.MissingOneOfPlugins, {
                            at: this.state.startLoc,
                            missingPlugin: e1
                        });
                    }
                    errorBuilder(e1) {
                        return (t, n, r)=>{
                            this.raise(e1, {
                                at: Xe(t, n, r)
                            });
                        };
                    }
                }
                class Je {
                    constructor(){
                        this.privateNames = new Set, this.loneAccessors = new Map, this.undefinedPrivateNames = new Map;
                    }
                }
                class $e {
                    constructor(e1){
                        this.parser = void 0, this.stack = [], this.undefinedPrivateNames = new Map, this.parser = e1;
                    }
                    current() {
                        return this.stack[this.stack.length - 1];
                    }
                    enter() {
                        this.stack.push(new Je);
                    }
                    exit() {
                        const e1 = this.stack.pop(), t = this.current();
                        for (const [n, r] of Array.from(e1.undefinedPrivateNames))t ? t.undefinedPrivateNames.has(n) || t.undefinedPrivateNames.set(n, r) : this.parser.raise(g.InvalidPrivateFieldResolution, {
                            at: r,
                            identifierName: n
                        });
                    }
                    declarePrivateName(e1, t, n) {
                        const { privateNames: r, loneAccessors: i, undefinedPrivateNames: s } = this.current();
                        let a = r.has(e1);
                        if (3 & t) {
                            const n = a && i.get(e1);
                            n ? (a = (3 & n) == (3 & t) || (4 & n) != (4 & t), a || i.delete(e1)) : a || i.set(e1, t);
                        }
                        a && this.parser.raise(g.PrivateNameRedeclaration, {
                            at: n,
                            identifierName: e1
                        }), r.add(e1), s.delete(e1);
                    }
                    usePrivateName(e1, t) {
                        let n;
                        for (n of this.stack)if (n.privateNames.has(e1)) return;
                        n ? n.undefinedPrivateNames.set(e1, t) : this.parser.raise(g.InvalidPrivateFieldResolution, {
                            at: t,
                            identifierName: e1
                        });
                    }
                }
                class Ge {
                    constructor(e1 = 0){
                        this.type = e1;
                    }
                    canBeArrowParameterDeclaration() {
                        return 2 === this.type || 1 === this.type;
                    }
                    isCertainlyParameterDeclaration() {
                        return 3 === this.type;
                    }
                }
                class ze extends Ge {
                    constructor(e1){
                        super(e1), this.declarationErrors = new Map;
                    }
                    recordDeclarationError(e1, { at: t }) {
                        const n = t.index;
                        this.declarationErrors.set(n, [
                            e1,
                            t
                        ]);
                    }
                    clearDeclarationError(e1) {
                        this.declarationErrors.delete(e1);
                    }
                    iterateErrors(e1) {
                        this.declarationErrors.forEach(e1);
                    }
                }
                class Qe {
                    constructor(e1){
                        this.parser = void 0, this.stack = [
                            new Ge
                        ], this.parser = e1;
                    }
                    enter(e1) {
                        this.stack.push(e1);
                    }
                    exit() {
                        this.stack.pop();
                    }
                    recordParameterInitializerError(e1, { at: t }) {
                        const n = {
                            at: t.loc.start
                        }, { stack: r } = this;
                        let i = r.length - 1, s = r[i];
                        for(; !s.isCertainlyParameterDeclaration();){
                            if (!s.canBeArrowParameterDeclaration()) return;
                            s.recordDeclarationError(e1, n), s = r[--i];
                        }
                        this.parser.raise(e1, n);
                    }
                    recordArrowParameterBindingError(e1, { at: t }) {
                        const { stack: n } = this, r = n[n.length - 1], i = {
                            at: t.loc.start
                        };
                        if (r.isCertainlyParameterDeclaration()) this.parser.raise(e1, i);
                        else {
                            if (!r.canBeArrowParameterDeclaration()) return;
                            r.recordDeclarationError(e1, i);
                        }
                    }
                    recordAsyncArrowParametersError({ at: e1 }) {
                        const { stack: t } = this;
                        let n = t.length - 1, r = t[n];
                        for(; r.canBeArrowParameterDeclaration();)2 === r.type && r.recordDeclarationError(g.AwaitBindingIdentifier, {
                            at: e1
                        }), r = t[--n];
                    }
                    validateAsPattern() {
                        const { stack: e1 } = this, t = e1[e1.length - 1];
                        t.canBeArrowParameterDeclaration() && t.iterateErrors(([t, n])=>{
                            this.parser.raise(t, {
                                at: n
                            });
                            let r = e1.length - 2, i = e1[r];
                            for(; i.canBeArrowParameterDeclaration();)i.clearDeclarationError(n.index), i = e1[--r];
                        });
                    }
                }
                function Ze() {
                    return new Ge;
                }
                class et {
                    constructor(){
                        this.stacks = [];
                    }
                    enter(e1) {
                        this.stacks.push(e1);
                    }
                    exit() {
                        this.stacks.pop();
                    }
                    currentFlags() {
                        return this.stacks[this.stacks.length - 1];
                    }
                    get hasAwait() {
                        return (2 & this.currentFlags()) > 0;
                    }
                    get hasYield() {
                        return (1 & this.currentFlags()) > 0;
                    }
                    get hasReturn() {
                        return (4 & this.currentFlags()) > 0;
                    }
                    get hasIn() {
                        return (8 & this.currentFlags()) > 0;
                    }
                }
                function tt(e1, t) {
                    return (e1 ? 2 : 0) | (t ? 1 : 0);
                }
                class nt extends He {
                    addExtra(e1, t, n, r = !0) {
                        if (!e1) return;
                        const i = e1.extra = e1.extra || {};
                        r ? i[t] = n : Object.defineProperty(i, t, {
                            enumerable: r,
                            value: n
                        });
                    }
                    isContextual(e1) {
                        return this.state.type === e1 && !this.state.containsEsc;
                    }
                    isUnparsedContextual(e1, t) {
                        const n = e1 + t.length;
                        if (this.input.slice(e1, n) === t) {
                            const e1 = this.input.charCodeAt(n);
                            return !(oe(e1) || 55296 == (64512 & e1));
                        }
                        return !1;
                    }
                    isLookaheadContextual(e1) {
                        const t = this.nextTokenStart();
                        return this.isUnparsedContextual(t, e1);
                    }
                    eatContextual(e1) {
                        return !!this.isContextual(e1) && (this.next(), !0);
                    }
                    expectContextual(e1, t) {
                        if (!this.eatContextual(e1)) {
                            if (null != t) throw this.raise(t, {
                                at: this.state.startLoc
                            });
                            this.unexpected(null, e1);
                        }
                    }
                    canInsertSemicolon() {
                        return this.match(137) || this.match(8) || this.hasPrecedingLineBreak();
                    }
                    hasPrecedingLineBreak() {
                        return Ae.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
                    }
                    hasFollowingLineBreak() {
                        return Ie.lastIndex = this.state.end, Ie.test(this.input);
                    }
                    isLineTerminator() {
                        return this.eat(13) || this.canInsertSemicolon();
                    }
                    semicolon(e1 = !0) {
                        (e1 ? this.isLineTerminator() : this.eat(13)) || this.raise(g.MissingSemicolon, {
                            at: this.state.lastTokEndLoc
                        });
                    }
                    expect(e1, t) {
                        this.eat(e1) || this.unexpected(t, e1);
                    }
                    tryParse(e1, t = this.state.clone()) {
                        const n = {
                            node: null
                        };
                        try {
                            const r = e1((e1 = null)=>{
                                throw n.node = e1, n;
                            });
                            if (this.state.errors.length > t.errors.length) {
                                const e1 = this.state;
                                return this.state = t, this.state.tokensLength = e1.tokensLength, {
                                    node: r,
                                    error: e1.errors[t.errors.length],
                                    thrown: !1,
                                    aborted: !1,
                                    failState: e1
                                };
                            }
                            return {
                                node: r,
                                error: null,
                                thrown: !1,
                                aborted: !1,
                                failState: null
                            };
                        } catch (e1) {
                            const r = this.state;
                            if (this.state = t, e1 instanceof SyntaxError) return {
                                node: null,
                                error: e1,
                                thrown: !0,
                                aborted: !1,
                                failState: r
                            };
                            if (e1 === n) return {
                                node: n.node,
                                error: null,
                                thrown: !1,
                                aborted: !0,
                                failState: r
                            };
                            throw e1;
                        }
                    }
                    checkExpressionErrors(e1, t) {
                        if (!e1) return !1;
                        const { shorthandAssignLoc: n, doubleProtoLoc: r, privateKeyLoc: i, optionalParametersLoc: s } = e1;
                        if (!t) return !!(n || r || s || i);
                        null != n && this.raise(g.InvalidCoverInitializedName, {
                            at: n
                        }), null != r && this.raise(g.DuplicateProto, {
                            at: r
                        }), null != i && this.raise(g.UnexpectedPrivateField, {
                            at: i
                        }), null != s && this.unexpected(s);
                    }
                    isLiteralPropertyName() {
                        return Y(this.state.type);
                    }
                    isPrivateName(e1) {
                        return "PrivateName" === e1.type;
                    }
                    getPrivateNameSV(e1) {
                        return e1.id.name;
                    }
                    hasPropertyAsPrivateName(e1) {
                        return ("MemberExpression" === e1.type || "OptionalMemberExpression" === e1.type) && this.isPrivateName(e1.property);
                    }
                    isObjectProperty(e1) {
                        return "ObjectProperty" === e1.type;
                    }
                    isObjectMethod(e1) {
                        return "ObjectMethod" === e1.type;
                    }
                    initializeScopes(e1 = "module" === this.options.sourceType) {
                        const t = this.state.labels;
                        this.state.labels = [];
                        const n = this.exportedIdentifiers;
                        this.exportedIdentifiers = new Set;
                        const r = this.inModule;
                        this.inModule = e1;
                        const i = this.scope, s = this.getScopeHandler();
                        this.scope = new s(this, e1);
                        const a = this.prodParam;
                        this.prodParam = new et;
                        const o = this.classScope;
                        this.classScope = new $e(this);
                        const l = this.expressionScope;
                        return this.expressionScope = new Qe(this), ()=>{
                            this.state.labels = t, this.exportedIdentifiers = n, this.inModule = r, this.scope = i, this.prodParam = a, this.classScope = o, this.expressionScope = l;
                        };
                    }
                    enterInitialScopes() {
                        let e1 = 0;
                        this.inModule && (e1 |= 2), this.scope.enter(1), this.prodParam.enter(e1);
                    }
                    checkDestructuringPrivate(e1) {
                        const { privateKeyLoc: t } = e1;
                        null !== t && this.expectPlugin("destructuringPrivate", t);
                    }
                }
                class rt {
                    constructor(){
                        this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
                    }
                }
                class it {
                    constructor(e1, t, n){
                        this.type = "", this.start = t, this.end = 0, this.loc = new i(n), null != e1 && e1.options.ranges && (this.range = [
                            t,
                            0
                        ]), null != e1 && e1.filename && (this.loc.filename = e1.filename);
                    }
                }
                const st = it.prototype;
                function at(e1) {
                    const { type: t, start: n, end: r, loc: i, range: s, extra: a, name: o } = e1, l = Object.create(st);
                    return l.type = t, l.start = n, l.end = r, l.loc = i, l.range = s, l.extra = a, l.name = o, "Placeholder" === t && (l.expectedNode = e1.expectedNode), l;
                }
                st.__clone = function() {
                    const e1 = new it(void 0, this.start, this.loc.start), t = Object.keys(this);
                    for(let n = 0, r = t.length; n < r; n++){
                        const r = t[n];
                        "leadingComments" !== r && "trailingComments" !== r && "innerComments" !== r && (e1[r] = this[r]);
                    }
                    return e1;
                };
                class ot extends nt {
                    startNode() {
                        return new it(this, this.state.start, this.state.startLoc);
                    }
                    startNodeAt(e1) {
                        return new it(this, e1.index, e1);
                    }
                    startNodeAtNode(e1) {
                        return this.startNodeAt(e1.loc.start);
                    }
                    finishNode(e1, t) {
                        return this.finishNodeAt(e1, t, this.state.lastTokEndLoc);
                    }
                    finishNodeAt(e1, t, n) {
                        return e1.type = t, e1.end = n.index, e1.loc.end = n, this.options.ranges && (e1.range[1] = n.index), this.options.attachComment && this.processComment(e1), e1;
                    }
                    resetStartLocation(e1, t) {
                        e1.start = t.index, e1.loc.start = t, this.options.ranges && (e1.range[0] = t.index);
                    }
                    resetEndLocation(e1, t = this.state.lastTokEndLoc) {
                        e1.end = t.index, e1.loc.end = t, this.options.ranges && (e1.range[1] = t.index);
                    }
                    resetStartLocationFromNode(e1, t) {
                        this.resetStartLocation(e1, t.loc.start);
                    }
                }
                const lt = new Set([
                    "_",
                    "any",
                    "bool",
                    "boolean",
                    "empty",
                    "extends",
                    "false",
                    "interface",
                    "mixed",
                    "null",
                    "number",
                    "static",
                    "string",
                    "true",
                    "typeof",
                    "void"
                ]), ct = T`flow`({
                    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
                    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
                    AssignReservedType: ({ reservedType: e1 })=>`Cannot overwrite reserved type ${e1}.`,
                    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
                    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
                    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
                    EnumBooleanMemberNotInitialized: ({ memberName: e1, enumName: t })=>`Boolean enum members need to be initialized. Use either \`${e1} = true,\` or \`${e1} = false,\` in enum \`${t}\`.`,
                    EnumDuplicateMemberName: ({ memberName: e1, enumName: t })=>`Enum member names need to be unique, but the name \`${e1}\` has already been used before in enum \`${t}\`.`,
                    EnumInconsistentMemberValues: ({ enumName: e1 })=>`Enum \`${e1}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
                    EnumInvalidExplicitType: ({ invalidEnumType: e1, enumName: t })=>`Enum type \`${e1}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`,
                    EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: e1 })=>`Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e1}\`.`,
                    EnumInvalidMemberInitializerPrimaryType: ({ enumName: e1, memberName: t, explicitType: n })=>`Enum \`${e1}\` has type \`${n}\`, so the initializer of \`${t}\` needs to be a ${n} literal.`,
                    EnumInvalidMemberInitializerSymbolType: ({ enumName: e1, memberName: t })=>`Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${e1}\`.`,
                    EnumInvalidMemberInitializerUnknownType: ({ enumName: e1, memberName: t })=>`The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${e1}\`.`,
                    EnumInvalidMemberName: ({ enumName: e1, memberName: t, suggestion: n })=>`Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${n}\`, in enum \`${e1}\`.`,
                    EnumNumberMemberNotInitialized: ({ enumName: e1, memberName: t })=>`Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${e1}\`.`,
                    EnumStringMemberInconsistentlyInitialized: ({ enumName: e1 })=>`String enum members need to consistently either all use initializers, or use no initializers, in enum \`${e1}\`.`,
                    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
                    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
                    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
                    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
                    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
                    InexactVariance: "Explicit inexact syntax cannot have variance.",
                    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
                    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
                    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
                    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
                    PatternIsOptional: Object.assign({
                        message: "A binding pattern parameter cannot be optional in an implementation signature."
                    }, {
                        reasonCode: "OptionalBindingPattern"
                    }),
                    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
                    SpreadVariance: "Spread properties cannot have variance.",
                    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
                    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
                    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
                    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
                    ThisParamNoDefault: "The `this` parameter may not have a default value.",
                    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
                    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
                    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
                    UnexpectedReservedType: ({ reservedType: e1 })=>`Unexpected reserved type ${e1}.`,
                    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
                    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
                    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
                    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
                    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
                    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
                    UnsupportedDeclareExportKind: ({ unsupportedExportKind: e1, suggestion: t })=>`\`declare export ${e1}\` is not supported. Use \`${t}\` instead.`,
                    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
                    UnterminatedFlowComment: "Unterminated flow-comment."
                });
                function ut(e1) {
                    return "type" === e1.importKind || "typeof" === e1.importKind;
                }
                const pt = {
                    const: "declare export var",
                    let: "declare export var",
                    type: "export type",
                    interface: "export interface"
                }, ht = /\*?\s*@((?:no)?flow)\b/, dt = {
                    __proto__: null,
                    quot: '"',
                    amp: "&",
                    apos: "'",
                    lt: "<",
                    gt: ">",
                    nbsp: " ",
                    iexcl: "¡",
                    cent: "¢",
                    pound: "£",
                    curren: "¤",
                    yen: "¥",
                    brvbar: "¦",
                    sect: "§",
                    uml: "¨",
                    copy: "©",
                    ordf: "ª",
                    laquo: "«",
                    not: "¬",
                    shy: "­",
                    reg: "®",
                    macr: "¯",
                    deg: "°",
                    plusmn: "±",
                    sup2: "²",
                    sup3: "³",
                    acute: "´",
                    micro: "µ",
                    para: "¶",
                    middot: "·",
                    cedil: "¸",
                    sup1: "¹",
                    ordm: "º",
                    raquo: "»",
                    frac14: "¼",
                    frac12: "½",
                    frac34: "¾",
                    iquest: "¿",
                    Agrave: "À",
                    Aacute: "Á",
                    Acirc: "Â",
                    Atilde: "Ã",
                    Auml: "Ä",
                    Aring: "Å",
                    AElig: "Æ",
                    Ccedil: "Ç",
                    Egrave: "È",
                    Eacute: "É",
                    Ecirc: "Ê",
                    Euml: "Ë",
                    Igrave: "Ì",
                    Iacute: "Í",
                    Icirc: "Î",
                    Iuml: "Ï",
                    ETH: "Ð",
                    Ntilde: "Ñ",
                    Ograve: "Ò",
                    Oacute: "Ó",
                    Ocirc: "Ô",
                    Otilde: "Õ",
                    Ouml: "Ö",
                    times: "×",
                    Oslash: "Ø",
                    Ugrave: "Ù",
                    Uacute: "Ú",
                    Ucirc: "Û",
                    Uuml: "Ü",
                    Yacute: "Ý",
                    THORN: "Þ",
                    szlig: "ß",
                    agrave: "à",
                    aacute: "á",
                    acirc: "â",
                    atilde: "ã",
                    auml: "ä",
                    aring: "å",
                    aelig: "æ",
                    ccedil: "ç",
                    egrave: "è",
                    eacute: "é",
                    ecirc: "ê",
                    euml: "ë",
                    igrave: "ì",
                    iacute: "í",
                    icirc: "î",
                    iuml: "ï",
                    eth: "ð",
                    ntilde: "ñ",
                    ograve: "ò",
                    oacute: "ó",
                    ocirc: "ô",
                    otilde: "õ",
                    ouml: "ö",
                    divide: "÷",
                    oslash: "ø",
                    ugrave: "ù",
                    uacute: "ú",
                    ucirc: "û",
                    uuml: "ü",
                    yacute: "ý",
                    thorn: "þ",
                    yuml: "ÿ",
                    OElig: "Œ",
                    oelig: "œ",
                    Scaron: "Š",
                    scaron: "š",
                    Yuml: "Ÿ",
                    fnof: "ƒ",
                    circ: "ˆ",
                    tilde: "˜",
                    Alpha: "Α",
                    Beta: "Β",
                    Gamma: "Γ",
                    Delta: "Δ",
                    Epsilon: "Ε",
                    Zeta: "Ζ",
                    Eta: "Η",
                    Theta: "Θ",
                    Iota: "Ι",
                    Kappa: "Κ",
                    Lambda: "Λ",
                    Mu: "Μ",
                    Nu: "Ν",
                    Xi: "Ξ",
                    Omicron: "Ο",
                    Pi: "Π",
                    Rho: "Ρ",
                    Sigma: "Σ",
                    Tau: "Τ",
                    Upsilon: "Υ",
                    Phi: "Φ",
                    Chi: "Χ",
                    Psi: "Ψ",
                    Omega: "Ω",
                    alpha: "α",
                    beta: "β",
                    gamma: "γ",
                    delta: "δ",
                    epsilon: "ε",
                    zeta: "ζ",
                    eta: "η",
                    theta: "θ",
                    iota: "ι",
                    kappa: "κ",
                    lambda: "λ",
                    mu: "μ",
                    nu: "ν",
                    xi: "ξ",
                    omicron: "ο",
                    pi: "π",
                    rho: "ρ",
                    sigmaf: "ς",
                    sigma: "σ",
                    tau: "τ",
                    upsilon: "υ",
                    phi: "φ",
                    chi: "χ",
                    psi: "ψ",
                    omega: "ω",
                    thetasym: "ϑ",
                    upsih: "ϒ",
                    piv: "ϖ",
                    ensp: " ",
                    emsp: " ",
                    thinsp: " ",
                    zwnj: "‌",
                    zwj: "‍",
                    lrm: "‎",
                    rlm: "‏",
                    ndash: "–",
                    mdash: "—",
                    lsquo: "‘",
                    rsquo: "’",
                    sbquo: "‚",
                    ldquo: "“",
                    rdquo: "”",
                    bdquo: "„",
                    dagger: "†",
                    Dagger: "‡",
                    bull: "•",
                    hellip: "…",
                    permil: "‰",
                    prime: "′",
                    Prime: "″",
                    lsaquo: "‹",
                    rsaquo: "›",
                    oline: "‾",
                    frasl: "⁄",
                    euro: "€",
                    image: "ℑ",
                    weierp: "℘",
                    real: "ℜ",
                    trade: "™",
                    alefsym: "ℵ",
                    larr: "←",
                    uarr: "↑",
                    rarr: "→",
                    darr: "↓",
                    harr: "↔",
                    crarr: "↵",
                    lArr: "⇐",
                    uArr: "⇑",
                    rArr: "⇒",
                    dArr: "⇓",
                    hArr: "⇔",
                    forall: "∀",
                    part: "∂",
                    exist: "∃",
                    empty: "∅",
                    nabla: "∇",
                    isin: "∈",
                    notin: "∉",
                    ni: "∋",
                    prod: "∏",
                    sum: "∑",
                    minus: "−",
                    lowast: "∗",
                    radic: "√",
                    prop: "∝",
                    infin: "∞",
                    ang: "∠",
                    and: "∧",
                    or: "∨",
                    cap: "∩",
                    cup: "∪",
                    int: "∫",
                    there4: "∴",
                    sim: "∼",
                    cong: "≅",
                    asymp: "≈",
                    ne: "≠",
                    equiv: "≡",
                    le: "≤",
                    ge: "≥",
                    sub: "⊂",
                    sup: "⊃",
                    nsub: "⊄",
                    sube: "⊆",
                    supe: "⊇",
                    oplus: "⊕",
                    otimes: "⊗",
                    perp: "⊥",
                    sdot: "⋅",
                    lceil: "⌈",
                    rceil: "⌉",
                    lfloor: "⌊",
                    rfloor: "⌋",
                    lang: "〈",
                    rang: "〉",
                    loz: "◊",
                    spades: "♠",
                    clubs: "♣",
                    hearts: "♥",
                    diams: "♦"
                }, ft = T`jsx`({
                    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
                    MissingClosingTagElement: ({ openingTagName: e1 })=>`Expected corresponding JSX closing tag for <${e1}>.`,
                    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
                    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
                    UnexpectedToken: ({ unexpected: e1, HTMLEntity: t })=>`Unexpected token \`${e1}\`. Did you mean \`${t}\` or \`{'${e1}'}\`?`,
                    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
                    UnterminatedJsxContent: "Unterminated JSX contents.",
                    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
                });
                function yt(e1) {
                    return !!e1 && ("JSXOpeningFragment" === e1.type || "JSXClosingFragment" === e1.type);
                }
                function mt(e1) {
                    if ("JSXIdentifier" === e1.type) return e1.name;
                    if ("JSXNamespacedName" === e1.type) return e1.namespace.name + ":" + e1.name.name;
                    if ("JSXMemberExpression" === e1.type) return mt(e1.object) + "." + mt(e1.property);
                    throw new Error("Node had unexpected type: " + e1.type);
                }
                class Tt extends me {
                    constructor(...e1){
                        super(...e1), this.types = new Set, this.enums = new Set, this.constEnums = new Set, this.classes = new Set, this.exportOnlyBindings = new Set;
                    }
                }
                class gt extends Te {
                    constructor(...e1){
                        super(...e1), this.importsStack = [];
                    }
                    createScope(e1) {
                        return this.importsStack.push(new Set), new Tt(e1);
                    }
                    enter(e1) {
                        256 == e1 && this.importsStack.push(new Set), super.enter(e1);
                    }
                    exit() {
                        const e1 = super.exit();
                        return 256 == e1 && this.importsStack.pop(), e1;
                    }
                    hasImport(e1, t) {
                        const n = this.importsStack.length;
                        if (this.importsStack[n - 1].has(e1)) return !0;
                        if (!t && n > 1) {
                            for(let t = 0; t < n - 1; t++)if (this.importsStack[t].has(e1)) return !0;
                        }
                        return !1;
                    }
                    declareName(e1, t, n) {
                        if (4096 & t) return this.hasImport(e1, !0) && this.parser.raise(g.VarRedeclaration, {
                            at: n,
                            identifierName: e1
                        }), void this.importsStack[this.importsStack.length - 1].add(e1);
                        const r = this.currentScope();
                        if (1024 & t) return this.maybeExportDefined(r, e1), void r.exportOnlyBindings.add(e1);
                        super.declareName(e1, t, n), 2 & t && (1 & t || (this.checkRedeclarationInScope(r, e1, t, n), this.maybeExportDefined(r, e1)), r.types.add(e1)), 256 & t && r.enums.add(e1), 512 & t && r.constEnums.add(e1), 128 & t && r.classes.add(e1);
                    }
                    isRedeclaredInScope(e1, t, n) {
                        return e1.enums.has(t) ? !(256 & n) || !!(512 & n) !== e1.constEnums.has(t) : 128 & n && e1.classes.has(t) ? !!e1.lexical.has(t) && !!(1 & n) : !!(2 & n && e1.types.has(t)) || super.isRedeclaredInScope(e1, t, n);
                    }
                    checkLocalExport(e1) {
                        const { name: t } = e1;
                        if (!this.hasImport(t)) {
                            for(let e1 = this.scopeStack.length - 1; e1 >= 0; e1--){
                                const n = this.scopeStack[e1];
                                if (n.types.has(t) || n.exportOnlyBindings.has(t)) return;
                            }
                            super.checkLocalExport(e1);
                        }
                    }
                }
                const bt = (e1)=>"ParenthesizedExpression" === e1.type ? bt(e1.expression) : e1;
                class Et extends ot {
                    toAssignable(e1, t = !1) {
                        var n, r;
                        let i;
                        switch(("ParenthesizedExpression" === e1.type || null != (n = e1.extra) && n.parenthesized) && (i = bt(e1), t ? "Identifier" === i.type ? this.expressionScope.recordArrowParameterBindingError(g.InvalidParenthesizedAssignment, {
                            at: e1
                        }) : "MemberExpression" !== i.type && this.raise(g.InvalidParenthesizedAssignment, {
                            at: e1
                        }) : this.raise(g.InvalidParenthesizedAssignment, {
                            at: e1
                        })), e1.type){
                            case "Identifier":
                            case "ObjectPattern":
                            case "ArrayPattern":
                            case "AssignmentPattern":
                            case "RestElement":
                                break;
                            case "ObjectExpression":
                                e1.type = "ObjectPattern";
                                for(let n = 0, r = e1.properties.length, i = r - 1; n < r; n++){
                                    var s;
                                    const r = e1.properties[n], a = n === i;
                                    this.toAssignableObjectExpressionProp(r, a, t), a && "RestElement" === r.type && null != (s = e1.extra) && s.trailingCommaLoc && this.raise(g.RestTrailingComma, {
                                        at: e1.extra.trailingCommaLoc
                                    });
                                }
                                break;
                            case "ObjectProperty":
                                {
                                    const { key: n, value: r } = e1;
                                    this.isPrivateName(n) && this.classScope.usePrivateName(this.getPrivateNameSV(n), n.loc.start), this.toAssignable(r, t);
                                    break;
                                }
                            case "SpreadElement":
                                throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
                            case "ArrayExpression":
                                e1.type = "ArrayPattern", this.toAssignableList(e1.elements, null == (r = e1.extra) ? void 0 : r.trailingCommaLoc, t);
                                break;
                            case "AssignmentExpression":
                                "=" !== e1.operator && this.raise(g.MissingEqInAssignment, {
                                    at: e1.left.loc.end
                                }), e1.type = "AssignmentPattern", delete e1.operator, this.toAssignable(e1.left, t);
                                break;
                            case "ParenthesizedExpression":
                                this.toAssignable(i, t);
                        }
                    }
                    toAssignableObjectExpressionProp(e1, t, n) {
                        if ("ObjectMethod" === e1.type) this.raise("get" === e1.kind || "set" === e1.kind ? g.PatternHasAccessor : g.PatternHasMethod, {
                            at: e1.key
                        });
                        else if ("SpreadElement" === e1.type) {
                            e1.type = "RestElement";
                            const r = e1.argument;
                            this.checkToRestConversion(r, !1), this.toAssignable(r, n), t || this.raise(g.RestTrailingComma, {
                                at: e1
                            });
                        } else this.toAssignable(e1, n);
                    }
                    toAssignableList(e1, t, n) {
                        const r = e1.length - 1;
                        for(let i = 0; i <= r; i++){
                            const s = e1[i];
                            if (s) {
                                if ("SpreadElement" === s.type) {
                                    s.type = "RestElement";
                                    const e1 = s.argument;
                                    this.checkToRestConversion(e1, !0), this.toAssignable(e1, n);
                                } else this.toAssignable(s, n);
                                "RestElement" === s.type && (i < r ? this.raise(g.RestTrailingComma, {
                                    at: s
                                }) : t && this.raise(g.RestTrailingComma, {
                                    at: t
                                }));
                            }
                        }
                    }
                    isAssignable(e1, t) {
                        switch(e1.type){
                            case "Identifier":
                            case "ObjectPattern":
                            case "ArrayPattern":
                            case "AssignmentPattern":
                            case "RestElement":
                                return !0;
                            case "ObjectExpression":
                                {
                                    const t = e1.properties.length - 1;
                                    return e1.properties.every((e1, n)=>"ObjectMethod" !== e1.type && (n === t || "SpreadElement" !== e1.type) && this.isAssignable(e1));
                                }
                            case "ObjectProperty":
                                return this.isAssignable(e1.value);
                            case "SpreadElement":
                                return this.isAssignable(e1.argument);
                            case "ArrayExpression":
                                return e1.elements.every((e1)=>null === e1 || this.isAssignable(e1));
                            case "AssignmentExpression":
                                return "=" === e1.operator;
                            case "ParenthesizedExpression":
                                return this.isAssignable(e1.expression);
                            case "MemberExpression":
                            case "OptionalMemberExpression":
                                return !t;
                            default:
                                return !1;
                        }
                    }
                    toReferencedList(e1, t) {
                        return e1;
                    }
                    toReferencedListDeep(e1, t) {
                        this.toReferencedList(e1, t);
                        for (const t of e1)"ArrayExpression" === (null == t ? void 0 : t.type) && this.toReferencedListDeep(t.elements);
                    }
                    parseSpread(e1) {
                        const t = this.startNode();
                        return this.next(), t.argument = this.parseMaybeAssignAllowIn(e1, void 0), this.finishNode(t, "SpreadElement");
                    }
                    parseRestBinding() {
                        const e1 = this.startNode();
                        return this.next(), e1.argument = this.parseBindingAtom(), this.finishNode(e1, "RestElement");
                    }
                    parseBindingAtom() {
                        switch(this.state.type){
                            case 0:
                                {
                                    const e1 = this.startNode();
                                    return this.next(), e1.elements = this.parseBindingList(3, 93, 1), this.finishNode(e1, "ArrayPattern");
                                }
                            case 5:
                                return this.parseObjectLike(8, !0);
                        }
                        return this.parseIdentifier();
                    }
                    parseBindingList(e1, t, n) {
                        const r = 1 & n, i = [];
                        let s = !0;
                        for(; !this.eat(e1);)if (s ? s = !1 : this.expect(12), r && this.match(12)) i.push(null);
                        else {
                            if (this.eat(e1)) break;
                            if (this.match(21)) {
                                if (i.push(this.parseAssignableListItemTypes(this.parseRestBinding(), n)), !this.checkCommaAfterRest(t)) {
                                    this.expect(e1);
                                    break;
                                }
                            } else {
                                const e1 = [];
                                for(this.match(26) && this.hasPlugin("decorators") && this.raise(g.UnsupportedParameterDecorator, {
                                    at: this.state.startLoc
                                }); this.match(26);)e1.push(this.parseDecorator());
                                i.push(this.parseAssignableListItem(n, e1));
                            }
                        }
                        return i;
                    }
                    parseBindingRestProperty(e1) {
                        return this.next(), e1.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(e1, "RestElement");
                    }
                    parseBindingProperty() {
                        const e1 = this.startNode(), { type: t, startLoc: n } = this.state;
                        return 21 === t ? this.parseBindingRestProperty(e1) : (136 === t ? (this.expectPlugin("destructuringPrivate", n), this.classScope.usePrivateName(this.state.value, n), e1.key = this.parsePrivateName()) : this.parsePropertyName(e1), e1.method = !1, this.parseObjPropValue(e1, n, !1, !1, !0, !1));
                    }
                    parseAssignableListItem(e1, t) {
                        const n = this.parseMaybeDefault();
                        this.parseAssignableListItemTypes(n, e1);
                        const r = this.parseMaybeDefault(n.loc.start, n);
                        return t.length && (n.decorators = t), r;
                    }
                    parseAssignableListItemTypes(e1, t) {
                        return e1;
                    }
                    parseMaybeDefault(e1, t) {
                        var n;
                        if (null != e1 || (e1 = this.state.startLoc), t = null != (n = t) ? n : this.parseBindingAtom(), !this.eat(29)) return t;
                        const r = this.startNodeAt(e1);
                        return r.left = t, r.right = this.parseMaybeAssignAllowIn(), this.finishNode(r, "AssignmentPattern");
                    }
                    isValidLVal(e1, t, n) {
                        return r = {
                            AssignmentPattern: "left",
                            RestElement: "argument",
                            ObjectProperty: "value",
                            ParenthesizedExpression: "expression",
                            ArrayPattern: "elements",
                            ObjectPattern: "properties"
                        }, i = e1, Object.hasOwnProperty.call(r, i) && r[i];
                        "TURBOPACK unreachable";
                        var r, i;
                    }
                    checkLVal(e1, { in: t, binding: n = 64, checkClashes: r = !1, strictModeChanged: i = !1, hasParenthesizedAncestor: s = !1 }) {
                        var a;
                        const o = e1.type;
                        if (this.isObjectMethod(e1)) return;
                        if ("MemberExpression" === o) return void (64 !== n && this.raise(g.InvalidPropertyBindingPattern, {
                            at: e1
                        }));
                        if ("Identifier" === o) {
                            this.checkIdentifier(e1, n, i);
                            const { name: t } = e1;
                            return void (r && (r.has(t) ? this.raise(g.ParamDupe, {
                                at: e1
                            }) : r.add(t)));
                        }
                        const l = this.isValidLVal(o, !(s || null != (a = e1.extra) && a.parenthesized) && "AssignmentExpression" === t.type, n);
                        if (!0 === l) return;
                        if (!1 === l) {
                            const r = 64 === n ? g.InvalidLhs : g.InvalidLhsBinding;
                            return void this.raise(r, {
                                at: e1,
                                ancestor: t
                            });
                        }
                        const [c, u] = Array.isArray(l) ? l : [
                            l,
                            "ParenthesizedExpression" === o
                        ], p = "ArrayPattern" === o || "ObjectPattern" === o || "ParenthesizedExpression" === o ? {
                            type: o
                        } : t;
                        for (const t of [].concat(e1[c]))t && this.checkLVal(t, {
                            in: p,
                            binding: n,
                            checkClashes: r,
                            strictModeChanged: i,
                            hasParenthesizedAncestor: u
                        });
                    }
                    checkIdentifier(e1, t, n = !1) {
                        this.state.strict && (n ? fe(e1.name, this.inModule) : de(e1.name)) && (64 === t ? this.raise(g.StrictEvalArguments, {
                            at: e1,
                            referenceName: e1.name
                        }) : this.raise(g.StrictEvalArgumentsBinding, {
                            at: e1,
                            bindingName: e1.name
                        })), 8192 & t && "let" === e1.name && this.raise(g.LetInLexicalBinding, {
                            at: e1
                        }), 64 & t || this.declareNameFromIdentifier(e1, t);
                    }
                    declareNameFromIdentifier(e1, t) {
                        this.scope.declareName(e1.name, t, e1.loc.start);
                    }
                    checkToRestConversion(e1, t) {
                        switch(e1.type){
                            case "ParenthesizedExpression":
                                this.checkToRestConversion(e1.expression, t);
                                break;
                            case "Identifier":
                            case "MemberExpression":
                                break;
                            case "ArrayExpression":
                            case "ObjectExpression":
                                if (t) break;
                            default:
                                this.raise(g.InvalidRestAssignmentPattern, {
                                    at: e1
                                });
                        }
                    }
                    checkCommaAfterRest(e1) {
                        return !!this.match(12) && (this.raise(this.lookaheadCharCode() === e1 ? g.RestTrailingComma : g.ElementAfterRest, {
                            at: this.state.startLoc
                        }), !0);
                    }
                }
                function St(e1) {
                    if (!e1) throw new Error("Assert fail");
                }
                const Pt = T`typescript`({
                    AbstractMethodHasImplementation: ({ methodName: e1 })=>`Method '${e1}' cannot have an implementation because it is marked abstract.`,
                    AbstractPropertyHasInitializer: ({ propertyName: e1 })=>`Property '${e1}' cannot have an initializer because it is marked abstract.`,
                    AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
                    AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
                    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
                    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
                    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
                    ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
                    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
                    DeclareAccessor: ({ kind: e1 })=>`'declare' is not allowed in ${e1}ters.`,
                    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
                    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
                    DuplicateAccessibilityModifier: ({ modifier: e1 })=>"Accessibility modifier already seen.",
                    DuplicateModifier: ({ modifier: e1 })=>`Duplicate modifier: '${e1}'.`,
                    EmptyHeritageClauseType: ({ token: e1 })=>`'${e1}' list cannot be empty.`,
                    EmptyTypeArguments: "Type argument list cannot be empty.",
                    EmptyTypeParameters: "Type parameter list cannot be empty.",
                    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
                    ImportAliasHasImportType: "An import alias can not use 'import type'.",
                    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
                    IncompatibleModifiers: ({ modifiers: e1 })=>`'${e1[0]}' modifier cannot be used with '${e1[1]}' modifier.`,
                    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
                    IndexSignatureHasAccessibility: ({ modifier: e1 })=>`Index signatures cannot have an accessibility modifier ('${e1}').`,
                    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
                    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
                    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
                    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
                    InvalidModifierOnTypeMember: ({ modifier: e1 })=>`'${e1}' modifier cannot appear on a type member.`,
                    InvalidModifierOnTypeParameter: ({ modifier: e1 })=>`'${e1}' modifier cannot appear on a type parameter.`,
                    InvalidModifierOnTypeParameterPositions: ({ modifier: e1 })=>`'${e1}' modifier can only appear on a type parameter of a class, interface or type alias.`,
                    InvalidModifiersOrder: ({ orderedModifiers: e1 })=>`'${e1[0]}' modifier must precede '${e1[1]}' modifier.`,
                    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
                    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
                    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
                    MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
                    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
                    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
                    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
                    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
                    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
                    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
                    PrivateElementHasAccessibility: ({ modifier: e1 })=>`Private elements cannot have an accessibility modifier ('${e1}').`,
                    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
                    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
                    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
                    SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
                    SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
                    SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
                    SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: e1 })=>`Single type parameter ${e1} should have a trailing comma. Example usage: <${e1},>.`,
                    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
                    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
                    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
                    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
                    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
                    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
                    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
                    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
                    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
                    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
                    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
                    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
                    UnsupportedSignatureParameterKind: ({ type: e1 })=>`Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e1}.`
                });
                function xt(e1) {
                    return "private" === e1 || "public" === e1 || "protected" === e1;
                }
                function Dt(e1) {
                    return "in" === e1 || "out" === e1;
                }
                function At(e1) {
                    if ("MemberExpression" !== e1.type) return !1;
                    const { computed: t, property: n } = e1;
                    return (!t || "StringLiteral" === n.type || !("TemplateLiteral" !== n.type || n.expressions.length > 0)) && wt(e1.object);
                }
                function vt(e1, t) {
                    var n;
                    const { type: r } = e1;
                    if (null != (n = e1.extra) && n.parenthesized) return !1;
                    if (t) {
                        if ("Literal" === r) {
                            const { value: t } = e1;
                            if ("string" == typeof t || "boolean" == typeof t) return !0;
                        }
                    } else if ("StringLiteral" === r || "BooleanLiteral" === r) return !0;
                    return !(!Ct(e1, t) && !function(e1, t) {
                        if ("UnaryExpression" === e1.type) {
                            const { operator: n, argument: r } = e1;
                            if ("-" === n && Ct(r, t)) return !0;
                        }
                        return !1;
                    }(e1, t)) || "TemplateLiteral" === r && 0 === e1.expressions.length || !!At(e1);
                }
                function Ct(e1, t) {
                    return t ? "Literal" === e1.type && ("number" == typeof e1.value || "bigint" in e1) : "NumericLiteral" === e1.type || "BigIntLiteral" === e1.type;
                }
                function wt(e1) {
                    return "Identifier" === e1.type || "MemberExpression" === e1.type && !e1.computed && wt(e1.object);
                }
                const Ot = T`placeholders`({
                    ClassNameIsRequired: "A class name is required.",
                    UnexpectedSpace: "Unexpected space in placeholder."
                });
                function It(e1, t) {
                    const [n, r] = "string" == typeof t ? [
                        t,
                        {}
                    ] : t, i = Object.keys(r), s = 0 === i.length;
                    return e1.some((e1)=>{
                        if ("string" == typeof e1) return s && e1 === n;
                        {
                            const [t, s] = e1;
                            if (t !== n) return !1;
                            for (const e1 of i)if (s[e1] !== r[e1]) return !1;
                            return !0;
                        }
                    });
                }
                function Nt(e1, t, n) {
                    const r = e1.find((e1)=>Array.isArray(e1) ? e1[0] === t : e1 === t);
                    return r && Array.isArray(r) && r.length > 1 ? r[1][n] : null;
                }
                const Ft = [
                    "minimal",
                    "fsharp",
                    "hack",
                    "smart"
                ], kt = [
                    "^^",
                    "@@",
                    "^",
                    "%",
                    "#"
                ], Lt = [
                    "hash",
                    "bar"
                ], _t = {
                    estree: (e1)=>class extends e1 {
                            parse() {
                                const e1 = S(super.parse());
                                return this.options.tokens && (e1.tokens = e1.tokens.map(S)), e1;
                            }
                            parseRegExpLiteral({ pattern: e1, flags: t }) {
                                let n = null;
                                try {
                                    n = new RegExp(e1, t);
                                } catch (e1) {}
                                const r = this.estreeParseLiteral(n);
                                return r.regex = {
                                    pattern: e1,
                                    flags: t
                                }, r;
                            }
                            parseBigIntLiteral(e1) {
                                let t;
                                try {
                                    t = BigInt(e1);
                                } catch (e1) {
                                    t = null;
                                }
                                const n = this.estreeParseLiteral(t);
                                return n.bigint = String(n.value || e1), n;
                            }
                            parseDecimalLiteral(e1) {
                                const t = this.estreeParseLiteral(null);
                                return t.decimal = String(t.value || e1), t;
                            }
                            estreeParseLiteral(e1) {
                                return this.parseLiteral(e1, "Literal");
                            }
                            parseStringLiteral(e1) {
                                return this.estreeParseLiteral(e1);
                            }
                            parseNumericLiteral(e1) {
                                return this.estreeParseLiteral(e1);
                            }
                            parseNullLiteral() {
                                return this.estreeParseLiteral(null);
                            }
                            parseBooleanLiteral(e1) {
                                return this.estreeParseLiteral(e1);
                            }
                            directiveToStmt(e1) {
                                const t = e1.value;
                                delete e1.value, t.type = "Literal", t.raw = t.extra.raw, t.value = t.extra.expressionValue;
                                const n = e1;
                                return n.type = "ExpressionStatement", n.expression = t, n.directive = t.extra.rawValue, delete t.extra, n;
                            }
                            initFunction(e1, t) {
                                super.initFunction(e1, t), e1.expression = !1;
                            }
                            checkDeclaration(e1) {
                                null != e1 && this.isObjectProperty(e1) ? this.checkDeclaration(e1.value) : super.checkDeclaration(e1);
                            }
                            getObjectOrClassMethodParams(e1) {
                                return e1.value.params;
                            }
                            isValidDirective(e1) {
                                var t;
                                return "ExpressionStatement" === e1.type && "Literal" === e1.expression.type && "string" == typeof e1.expression.value && !(null != (t = e1.expression.extra) && t.parenthesized);
                            }
                            parseBlockBody(e1, t, n, r, i) {
                                super.parseBlockBody(e1, t, n, r, i);
                                const s = e1.directives.map((e1)=>this.directiveToStmt(e1));
                                e1.body = s.concat(e1.body), delete e1.directives;
                            }
                            pushClassMethod(e1, t, n, r, i, s) {
                                this.parseMethod(t, n, r, i, s, "ClassMethod", !0), t.typeParameters && (t.value.typeParameters = t.typeParameters, delete t.typeParameters), e1.body.push(t);
                            }
                            parsePrivateName() {
                                const e1 = super.parsePrivateName();
                                return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(e1) : e1;
                            }
                            convertPrivateNameToPrivateIdentifier(e1) {
                                const t = super.getPrivateNameSV(e1);
                                return delete e1.id, e1.name = t, e1.type = "PrivateIdentifier", e1;
                            }
                            isPrivateName(e1) {
                                return this.getPluginOption("estree", "classFeatures") ? "PrivateIdentifier" === e1.type : super.isPrivateName(e1);
                            }
                            getPrivateNameSV(e1) {
                                return this.getPluginOption("estree", "classFeatures") ? e1.name : super.getPrivateNameSV(e1);
                            }
                            parseLiteral(e1, t) {
                                const n = super.parseLiteral(e1, t);
                                return n.raw = n.extra.raw, delete n.extra, n;
                            }
                            parseFunctionBody(e1, t, n = !1) {
                                super.parseFunctionBody(e1, t, n), e1.expression = "BlockStatement" !== e1.body.type;
                            }
                            parseMethod(e1, t, n, r, i, s, a = !1) {
                                let o = this.startNode();
                                return o.kind = e1.kind, o = super.parseMethod(o, t, n, r, i, s, a), o.type = "FunctionExpression", delete o.kind, e1.value = o, "ClassPrivateMethod" === s && (e1.computed = !1), this.finishNode(e1, "MethodDefinition");
                            }
                            parseClassProperty(...e1) {
                                const t = super.parseClassProperty(...e1);
                                return this.getPluginOption("estree", "classFeatures") ? (t.type = "PropertyDefinition", t) : t;
                            }
                            parseClassPrivateProperty(...e1) {
                                const t = super.parseClassPrivateProperty(...e1);
                                return this.getPluginOption("estree", "classFeatures") ? (t.type = "PropertyDefinition", t.computed = !1, t) : t;
                            }
                            parseObjectMethod(e1, t, n, r, i) {
                                const s = super.parseObjectMethod(e1, t, n, r, i);
                                return s && (s.type = "Property", "method" === s.kind && (s.kind = "init"), s.shorthand = !1), s;
                            }
                            parseObjectProperty(e1, t, n, r) {
                                const i = super.parseObjectProperty(e1, t, n, r);
                                return i && (i.kind = "init", i.type = "Property"), i;
                            }
                            isValidLVal(e1, t, n) {
                                return "Property" === e1 ? "value" : super.isValidLVal(e1, t, n);
                            }
                            isAssignable(e1, t) {
                                return null != e1 && this.isObjectProperty(e1) ? this.isAssignable(e1.value, t) : super.isAssignable(e1, t);
                            }
                            toAssignable(e1, t = !1) {
                                if (null != e1 && this.isObjectProperty(e1)) {
                                    const { key: n, value: r } = e1;
                                    this.isPrivateName(n) && this.classScope.usePrivateName(this.getPrivateNameSV(n), n.loc.start), this.toAssignable(r, t);
                                } else super.toAssignable(e1, t);
                            }
                            toAssignableObjectExpressionProp(e1, t, n) {
                                "get" === e1.kind || "set" === e1.kind ? this.raise(g.PatternHasAccessor, {
                                    at: e1.key
                                }) : e1.method ? this.raise(g.PatternHasMethod, {
                                    at: e1.key
                                }) : super.toAssignableObjectExpressionProp(e1, t, n);
                            }
                            finishCallExpression(e1, t) {
                                const n = super.finishCallExpression(e1, t);
                                var r;
                                "Import" === n.callee.type && (n.type = "ImportExpression", n.source = n.arguments[0], (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (n.attributes = null != (r = n.arguments[1]) ? r : null), delete n.arguments, delete n.callee);
                                return n;
                            }
                            toReferencedArguments(e1) {
                                "ImportExpression" !== e1.type && super.toReferencedArguments(e1);
                            }
                            parseExport(e1, t) {
                                const n = this.state.lastTokStartLoc, r = super.parseExport(e1, t);
                                switch(r.type){
                                    case "ExportAllDeclaration":
                                        r.exported = null;
                                        break;
                                    case "ExportNamedDeclaration":
                                        1 === r.specifiers.length && "ExportNamespaceSpecifier" === r.specifiers[0].type && (r.type = "ExportAllDeclaration", r.exported = r.specifiers[0].exported, delete r.specifiers);
                                    case "ExportDefaultDeclaration":
                                        {
                                            var i;
                                            const { declaration: e1 } = r;
                                            "ClassDeclaration" === (null == e1 ? void 0 : e1.type) && (null == (i = e1.decorators) ? void 0 : i.length) > 0 && e1.start === r.start && this.resetStartLocation(r, n);
                                        }
                                }
                                return r;
                            }
                            parseSubscript(e1, t, n, r) {
                                const i = super.parseSubscript(e1, t, n, r);
                                if (r.optionalChainMember) {
                                    if ("OptionalMemberExpression" !== i.type && "OptionalCallExpression" !== i.type || (i.type = i.type.substring(8)), r.stop) {
                                        const e1 = this.startNodeAtNode(i);
                                        return e1.expression = i, this.finishNode(e1, "ChainExpression");
                                    }
                                } else "MemberExpression" !== i.type && "CallExpression" !== i.type || (i.optional = !1);
                                return i;
                            }
                            hasPropertyAsPrivateName(e1) {
                                return "ChainExpression" === e1.type && (e1 = e1.expression), super.hasPropertyAsPrivateName(e1);
                            }
                            isObjectProperty(e1) {
                                return "Property" === e1.type && "init" === e1.kind && !e1.method;
                            }
                            isObjectMethod(e1) {
                                return e1.method || "get" === e1.kind || "set" === e1.kind;
                            }
                            finishNodeAt(e1, t, n) {
                                return S(super.finishNodeAt(e1, t, n));
                            }
                            resetStartLocation(e1, t) {
                                super.resetStartLocation(e1, t), S(e1);
                            }
                            resetEndLocation(e1, t = this.state.lastTokEndLoc) {
                                super.resetEndLocation(e1, t), S(e1);
                            }
                        },
                    jsx: (e1)=>class extends e1 {
                            jsxReadToken() {
                                let e1 = "", t = this.state.pos;
                                for(;;){
                                    if (this.state.pos >= this.length) throw this.raise(ft.UnterminatedJsxContent, {
                                        at: this.state.startLoc
                                    });
                                    const n = this.input.charCodeAt(this.state.pos);
                                    switch(n){
                                        case 60:
                                        case 123:
                                            return this.state.pos === this.state.start ? void (60 === n && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(140)) : super.getTokenFromCode(n)) : (e1 += this.input.slice(t, this.state.pos), void this.finishToken(139, e1));
                                        case 38:
                                            e1 += this.input.slice(t, this.state.pos), e1 += this.jsxReadEntity(), t = this.state.pos;
                                            break;
                                        default:
                                            Ce(n) ? (e1 += this.input.slice(t, this.state.pos), e1 += this.jsxReadNewLine(!0), t = this.state.pos) : ++this.state.pos;
                                    }
                                }
                            }
                            jsxReadNewLine(e1) {
                                const t = this.input.charCodeAt(this.state.pos);
                                let n;
                                return ++this.state.pos, 13 === t && 10 === this.input.charCodeAt(this.state.pos) ? (++this.state.pos, n = e1 ? "\n" : "\r\n") : n = String.fromCharCode(t), ++this.state.curLine, this.state.lineStart = this.state.pos, n;
                            }
                            jsxReadString(e1) {
                                let t = "", n = ++this.state.pos;
                                for(;;){
                                    if (this.state.pos >= this.length) throw this.raise(g.UnterminatedString, {
                                        at: this.state.startLoc
                                    });
                                    const r = this.input.charCodeAt(this.state.pos);
                                    if (r === e1) break;
                                    38 === r ? (t += this.input.slice(n, this.state.pos), t += this.jsxReadEntity(), n = this.state.pos) : Ce(r) ? (t += this.input.slice(n, this.state.pos), t += this.jsxReadNewLine(!1), n = this.state.pos) : ++this.state.pos;
                                }
                                t += this.input.slice(n, this.state.pos++), this.finishToken(131, t);
                            }
                            jsxReadEntity() {
                                const e1 = ++this.state.pos;
                                if (35 === this.codePointAtPos(this.state.pos)) {
                                    ++this.state.pos;
                                    let e1 = 10;
                                    120 === this.codePointAtPos(this.state.pos) && (e1 = 16, ++this.state.pos);
                                    const t = this.readInt(e1, void 0, !1, "bail");
                                    if (null !== t && 59 === this.codePointAtPos(this.state.pos)) return ++this.state.pos, String.fromCodePoint(t);
                                } else {
                                    let t = 0, n = !1;
                                    for(; t++ < 10 && this.state.pos < this.length && !(n = 59 == this.codePointAtPos(this.state.pos));)++this.state.pos;
                                    if (n) {
                                        const t = this.input.slice(e1, this.state.pos), n = dt[t];
                                        if (++this.state.pos, n) return n;
                                    }
                                }
                                return this.state.pos = e1, "&";
                            }
                            jsxReadWord() {
                                let e1;
                                const t = this.state.pos;
                                do {
                                    e1 = this.input.charCodeAt(++this.state.pos);
                                }while (oe(e1) || 45 === e1)
                                this.finishToken(138, this.input.slice(t, this.state.pos));
                            }
                            jsxParseIdentifier() {
                                const e1 = this.startNode();
                                return this.match(138) ? e1.name = this.state.value : J(this.state.type) ? e1.name = $(this.state.type) : this.unexpected(), this.next(), this.finishNode(e1, "JSXIdentifier");
                            }
                            jsxParseNamespacedName() {
                                const e1 = this.state.startLoc, t = this.jsxParseIdentifier();
                                if (!this.eat(14)) return t;
                                const n = this.startNodeAt(e1);
                                return n.namespace = t, n.name = this.jsxParseIdentifier(), this.finishNode(n, "JSXNamespacedName");
                            }
                            jsxParseElementName() {
                                const e1 = this.state.startLoc;
                                let t = this.jsxParseNamespacedName();
                                if ("JSXNamespacedName" === t.type) return t;
                                for(; this.eat(16);){
                                    const n = this.startNodeAt(e1);
                                    n.object = t, n.property = this.jsxParseIdentifier(), t = this.finishNode(n, "JSXMemberExpression");
                                }
                                return t;
                            }
                            jsxParseAttributeValue() {
                                let e1;
                                switch(this.state.type){
                                    case 5:
                                        return e1 = this.startNode(), this.setContext(x.brace), this.next(), e1 = this.jsxParseExpressionContainer(e1, x.j_oTag), "JSXEmptyExpression" === e1.expression.type && this.raise(ft.AttributeIsEmpty, {
                                            at: e1
                                        }), e1;
                                    case 140:
                                    case 131:
                                        return this.parseExprAtom();
                                    default:
                                        throw this.raise(ft.UnsupportedJsxValue, {
                                            at: this.state.startLoc
                                        });
                                }
                            }
                            jsxParseEmptyExpression() {
                                const e1 = this.startNodeAt(this.state.lastTokEndLoc);
                                return this.finishNodeAt(e1, "JSXEmptyExpression", this.state.startLoc);
                            }
                            jsxParseSpreadChild(e1) {
                                return this.next(), e1.expression = this.parseExpression(), this.setContext(x.j_expr), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(e1, "JSXSpreadChild");
                            }
                            jsxParseExpressionContainer(e1, t) {
                                if (this.match(8)) e1.expression = this.jsxParseEmptyExpression();
                                else {
                                    const t = this.parseExpression();
                                    e1.expression = t;
                                }
                                return this.setContext(t), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(e1, "JSXExpressionContainer");
                            }
                            jsxParseAttribute() {
                                const e1 = this.startNode();
                                return this.match(5) ? (this.setContext(x.brace), this.next(), this.expect(21), e1.argument = this.parseMaybeAssignAllowIn(), this.setContext(x.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(e1, "JSXSpreadAttribute")) : (e1.name = this.jsxParseNamespacedName(), e1.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(e1, "JSXAttribute"));
                            }
                            jsxParseOpeningElementAt(e1) {
                                const t = this.startNodeAt(e1);
                                return this.eat(141) ? this.finishNode(t, "JSXOpeningFragment") : (t.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(t));
                            }
                            jsxParseOpeningElementAfterName(e1) {
                                const t = [];
                                for(; !this.match(56) && !this.match(141);)t.push(this.jsxParseAttribute());
                                return e1.attributes = t, e1.selfClosing = this.eat(56), this.expect(141), this.finishNode(e1, "JSXOpeningElement");
                            }
                            jsxParseClosingElementAt(e1) {
                                const t = this.startNodeAt(e1);
                                return this.eat(141) ? this.finishNode(t, "JSXClosingFragment") : (t.name = this.jsxParseElementName(), this.expect(141), this.finishNode(t, "JSXClosingElement"));
                            }
                            jsxParseElementAt(e1) {
                                const t = this.startNodeAt(e1), n = [], r = this.jsxParseOpeningElementAt(e1);
                                let i = null;
                                if (!r.selfClosing) {
                                    e: for(;;)switch(this.state.type){
                                        case 140:
                                            if (e1 = this.state.startLoc, this.next(), this.eat(56)) {
                                                i = this.jsxParseClosingElementAt(e1);
                                                break e;
                                            }
                                            n.push(this.jsxParseElementAt(e1));
                                            break;
                                        case 139:
                                            n.push(this.parseExprAtom());
                                            break;
                                        case 5:
                                            {
                                                const e1 = this.startNode();
                                                this.setContext(x.brace), this.next(), this.match(21) ? n.push(this.jsxParseSpreadChild(e1)) : n.push(this.jsxParseExpressionContainer(e1, x.j_expr));
                                                break;
                                            }
                                        default:
                                            this.unexpected();
                                    }
                                    yt(r) && !yt(i) && null !== i ? this.raise(ft.MissingClosingTagFragment, {
                                        at: i
                                    }) : !yt(r) && yt(i) ? this.raise(ft.MissingClosingTagElement, {
                                        at: i,
                                        openingTagName: mt(r.name)
                                    }) : yt(r) || yt(i) || mt(i.name) !== mt(r.name) && this.raise(ft.MissingClosingTagElement, {
                                        at: i,
                                        openingTagName: mt(r.name)
                                    });
                                }
                                if (yt(r) ? (t.openingFragment = r, t.closingFragment = i) : (t.openingElement = r, t.closingElement = i), t.children = n, this.match(47)) throw this.raise(ft.UnwrappedAdjacentJSXElements, {
                                    at: this.state.startLoc
                                });
                                return yt(r) ? this.finishNode(t, "JSXFragment") : this.finishNode(t, "JSXElement");
                            }
                            jsxParseElement() {
                                const e1 = this.state.startLoc;
                                return this.next(), this.jsxParseElementAt(e1);
                            }
                            setContext(e1) {
                                const { context: t } = this.state;
                                t[t.length - 1] = e1;
                            }
                            parseExprAtom(e1) {
                                return this.match(139) ? this.parseLiteral(this.state.value, "JSXText") : this.match(140) ? this.jsxParseElement() : this.match(47) && 33 !== this.input.charCodeAt(this.state.pos) ? (this.replaceToken(140), this.jsxParseElement()) : super.parseExprAtom(e1);
                            }
                            skipSpace() {
                                this.curContext().preserveSpace || super.skipSpace();
                            }
                            getTokenFromCode(e1) {
                                const t = this.curContext();
                                if (t !== x.j_expr) {
                                    if (t === x.j_oTag || t === x.j_cTag) {
                                        if (ae(e1)) return void this.jsxReadWord();
                                        if (62 === e1) return ++this.state.pos, void this.finishToken(141);
                                        if ((34 === e1 || 39 === e1) && t === x.j_oTag) return void this.jsxReadString(e1);
                                    }
                                    if (60 === e1 && this.state.canStartJSXElement && 33 !== this.input.charCodeAt(this.state.pos + 1)) return ++this.state.pos, void this.finishToken(140);
                                    super.getTokenFromCode(e1);
                                } else this.jsxReadToken();
                            }
                            updateContext(e1) {
                                const { context: t, type: n } = this.state;
                                if (56 === n && 140 === e1) t.splice(-2, 2, x.j_cTag), this.state.canStartJSXElement = !1;
                                else if (140 === n) t.push(x.j_oTag);
                                else if (141 === n) {
                                    const n = t[t.length - 1];
                                    n === x.j_oTag && 56 === e1 || n === x.j_cTag ? (t.pop(), this.state.canStartJSXElement = t[t.length - 1] === x.j_expr) : (this.setContext(x.j_expr), this.state.canStartJSXElement = !0);
                                } else this.state.canStartJSXElement = B[n];
                            }
                        },
                    flow: (e1)=>class extends e1 {
                            constructor(...e1){
                                super(...e1), this.flowPragma = void 0;
                            }
                            getScopeHandler() {
                                return be;
                            }
                            shouldParseTypes() {
                                return this.getPluginOption("flow", "all") || "flow" === this.flowPragma;
                            }
                            shouldParseEnums() {
                                return !!this.getPluginOption("flow", "enums");
                            }
                            finishToken(e1, t) {
                                131 !== e1 && 13 !== e1 && 28 !== e1 && void 0 === this.flowPragma && (this.flowPragma = null), super.finishToken(e1, t);
                            }
                            addComment(e1) {
                                if (void 0 === this.flowPragma) {
                                    const t = ht.exec(e1.value);
                                    if (t) if ("flow" === t[1]) this.flowPragma = "flow";
                                    else {
                                        if ("noflow" !== t[1]) throw new Error("Unexpected flow pragma");
                                        this.flowPragma = "noflow";
                                    }
                                }
                                super.addComment(e1);
                            }
                            flowParseTypeInitialiser(e1) {
                                const t = this.state.inType;
                                this.state.inType = !0, this.expect(e1 || 14);
                                const n = this.flowParseType();
                                return this.state.inType = t, n;
                            }
                            flowParsePredicate() {
                                const e1 = this.startNode(), t = this.state.startLoc;
                                return this.next(), this.expectContextual(108), this.state.lastTokStart > t.index + 1 && this.raise(ct.UnexpectedSpaceBetweenModuloChecks, {
                                    at: t
                                }), this.eat(10) ? (e1.value = super.parseExpression(), this.expect(11), this.finishNode(e1, "DeclaredPredicate")) : this.finishNode(e1, "InferredPredicate");
                            }
                            flowParseTypeAndPredicateInitialiser() {
                                const e1 = this.state.inType;
                                this.state.inType = !0, this.expect(14);
                                let t = null, n = null;
                                return this.match(54) ? (this.state.inType = e1, n = this.flowParsePredicate()) : (t = this.flowParseType(), this.state.inType = e1, this.match(54) && (n = this.flowParsePredicate())), [
                                    t,
                                    n
                                ];
                            }
                            flowParseDeclareClass(e1) {
                                return this.next(), this.flowParseInterfaceish(e1, !0), this.finishNode(e1, "DeclareClass");
                            }
                            flowParseDeclareFunction(e1) {
                                this.next();
                                const t = e1.id = this.parseIdentifier(), n = this.startNode(), r = this.startNode();
                                this.match(47) ? n.typeParameters = this.flowParseTypeParameterDeclaration() : n.typeParameters = null, this.expect(10);
                                const i = this.flowParseFunctionTypeParams();
                                return n.params = i.params, n.rest = i.rest, n.this = i._this, this.expect(11), [n.returnType, e1.predicate] = this.flowParseTypeAndPredicateInitialiser(), r.typeAnnotation = this.finishNode(n, "FunctionTypeAnnotation"), t.typeAnnotation = this.finishNode(r, "TypeAnnotation"), this.resetEndLocation(t), this.semicolon(), this.scope.declareName(e1.id.name, 2048, e1.id.loc.start), this.finishNode(e1, "DeclareFunction");
                            }
                            flowParseDeclare(e1, t) {
                                return this.match(80) ? this.flowParseDeclareClass(e1) : this.match(68) ? this.flowParseDeclareFunction(e1) : this.match(74) ? this.flowParseDeclareVariable(e1) : this.eatContextual(125) ? this.match(16) ? this.flowParseDeclareModuleExports(e1) : (t && this.raise(ct.NestedDeclareModule, {
                                    at: this.state.lastTokStartLoc
                                }), this.flowParseDeclareModule(e1)) : this.isContextual(128) ? this.flowParseDeclareTypeAlias(e1) : this.isContextual(129) ? this.flowParseDeclareOpaqueType(e1) : this.isContextual(127) ? this.flowParseDeclareInterface(e1) : this.match(82) ? this.flowParseDeclareExportDeclaration(e1, t) : void this.unexpected();
                            }
                            flowParseDeclareVariable(e1) {
                                return this.next(), e1.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(e1.id.name, 5, e1.id.loc.start), this.semicolon(), this.finishNode(e1, "DeclareVariable");
                            }
                            flowParseDeclareModule(e1) {
                                this.scope.enter(0), this.match(131) ? e1.id = super.parseExprAtom() : e1.id = this.parseIdentifier();
                                const t = e1.body = this.startNode(), n = t.body = [];
                                for(this.expect(5); !this.match(8);){
                                    let e1 = this.startNode();
                                    this.match(83) ? (this.next(), this.isContextual(128) || this.match(87) || this.raise(ct.InvalidNonTypeImportInDeclareModule, {
                                        at: this.state.lastTokStartLoc
                                    }), super.parseImport(e1)) : (this.expectContextual(123, ct.UnsupportedStatementInDeclareModule), e1 = this.flowParseDeclare(e1, !0)), n.push(e1);
                                }
                                this.scope.exit(), this.expect(8), this.finishNode(t, "BlockStatement");
                                let r = null, i = !1;
                                return n.forEach((e1)=>{
                                    !function(e1) {
                                        return "DeclareExportAllDeclaration" === e1.type || "DeclareExportDeclaration" === e1.type && (!e1.declaration || "TypeAlias" !== e1.declaration.type && "InterfaceDeclaration" !== e1.declaration.type);
                                    }(e1) ? "DeclareModuleExports" === e1.type && (i && this.raise(ct.DuplicateDeclareModuleExports, {
                                        at: e1
                                    }), "ES" === r && this.raise(ct.AmbiguousDeclareModuleKind, {
                                        at: e1
                                    }), r = "CommonJS", i = !0) : ("CommonJS" === r && this.raise(ct.AmbiguousDeclareModuleKind, {
                                        at: e1
                                    }), r = "ES");
                                }), e1.kind = r || "CommonJS", this.finishNode(e1, "DeclareModule");
                            }
                            flowParseDeclareExportDeclaration(e1, t) {
                                if (this.expect(82), this.eat(65)) return this.match(68) || this.match(80) ? e1.declaration = this.flowParseDeclare(this.startNode()) : (e1.declaration = this.flowParseType(), this.semicolon()), e1.default = !0, this.finishNode(e1, "DeclareExportDeclaration");
                                if (this.match(75) || this.isLet() || (this.isContextual(128) || this.isContextual(127)) && !t) {
                                    const e1 = this.state.value;
                                    throw this.raise(ct.UnsupportedDeclareExportKind, {
                                        at: this.state.startLoc,
                                        unsupportedExportKind: e1,
                                        suggestion: pt[e1]
                                    });
                                }
                                return this.match(74) || this.match(68) || this.match(80) || this.isContextual(129) ? (e1.declaration = this.flowParseDeclare(this.startNode()), e1.default = !1, this.finishNode(e1, "DeclareExportDeclaration")) : this.match(55) || this.match(5) || this.isContextual(127) || this.isContextual(128) || this.isContextual(129) ? ("ExportNamedDeclaration" === (e1 = this.parseExport(e1, null)).type && (e1.type = "ExportDeclaration", e1.default = !1, delete e1.exportKind), e1.type = "Declare" + e1.type, e1) : void this.unexpected();
                            }
                            flowParseDeclareModuleExports(e1) {
                                return this.next(), this.expectContextual(109), e1.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e1, "DeclareModuleExports");
                            }
                            flowParseDeclareTypeAlias(e1) {
                                this.next();
                                const t = this.flowParseTypeAlias(e1);
                                return t.type = "DeclareTypeAlias", t;
                            }
                            flowParseDeclareOpaqueType(e1) {
                                this.next();
                                const t = this.flowParseOpaqueType(e1, !0);
                                return t.type = "DeclareOpaqueType", t;
                            }
                            flowParseDeclareInterface(e1) {
                                return this.next(), this.flowParseInterfaceish(e1, !1), this.finishNode(e1, "DeclareInterface");
                            }
                            flowParseInterfaceish(e1, t) {
                                if (e1.id = this.flowParseRestrictedIdentifier(!t, !0), this.scope.declareName(e1.id.name, t ? 17 : 8201, e1.id.loc.start), this.match(47) ? e1.typeParameters = this.flowParseTypeParameterDeclaration() : e1.typeParameters = null, e1.extends = [], this.eat(81)) do {
                                    e1.extends.push(this.flowParseInterfaceExtends());
                                }while (!t && this.eat(12))
                                if (t) {
                                    if (e1.implements = [], e1.mixins = [], this.eatContextual(115)) do {
                                        e1.mixins.push(this.flowParseInterfaceExtends());
                                    }while (this.eat(12))
                                    if (this.eatContextual(111)) do {
                                        e1.implements.push(this.flowParseInterfaceExtends());
                                    }while (this.eat(12))
                                }
                                e1.body = this.flowParseObjectType({
                                    allowStatic: t,
                                    allowExact: !1,
                                    allowSpread: !1,
                                    allowProto: t,
                                    allowInexact: !1
                                });
                            }
                            flowParseInterfaceExtends() {
                                const e1 = this.startNode();
                                return e1.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? e1.typeParameters = this.flowParseTypeParameterInstantiation() : e1.typeParameters = null, this.finishNode(e1, "InterfaceExtends");
                            }
                            flowParseInterface(e1) {
                                return this.flowParseInterfaceish(e1, !1), this.finishNode(e1, "InterfaceDeclaration");
                            }
                            checkNotUnderscore(e1) {
                                "_" === e1 && this.raise(ct.UnexpectedReservedUnderscore, {
                                    at: this.state.startLoc
                                });
                            }
                            checkReservedType(e1, t, n) {
                                lt.has(e1) && this.raise(n ? ct.AssignReservedType : ct.UnexpectedReservedType, {
                                    at: t,
                                    reservedType: e1
                                });
                            }
                            flowParseRestrictedIdentifier(e1, t) {
                                return this.checkReservedType(this.state.value, this.state.startLoc, t), this.parseIdentifier(e1);
                            }
                            flowParseTypeAlias(e1) {
                                return e1.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(e1.id.name, 8201, e1.id.loc.start), this.match(47) ? e1.typeParameters = this.flowParseTypeParameterDeclaration() : e1.typeParameters = null, e1.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(e1, "TypeAlias");
                            }
                            flowParseOpaqueType(e1, t) {
                                return this.expectContextual(128), e1.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(e1.id.name, 8201, e1.id.loc.start), this.match(47) ? e1.typeParameters = this.flowParseTypeParameterDeclaration() : e1.typeParameters = null, e1.supertype = null, this.match(14) && (e1.supertype = this.flowParseTypeInitialiser(14)), e1.impltype = null, t || (e1.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e1, "OpaqueType");
                            }
                            flowParseTypeParameter(e1 = !1) {
                                const t = this.state.startLoc, n = this.startNode(), r = this.flowParseVariance(), i = this.flowParseTypeAnnotatableIdentifier();
                                return n.name = i.name, n.variance = r, n.bound = i.typeAnnotation, this.match(29) ? (this.eat(29), n.default = this.flowParseType()) : e1 && this.raise(ct.MissingTypeParamDefault, {
                                    at: t
                                }), this.finishNode(n, "TypeParameter");
                            }
                            flowParseTypeParameterDeclaration() {
                                const e1 = this.state.inType, t = this.startNode();
                                t.params = [], this.state.inType = !0, this.match(47) || this.match(140) ? this.next() : this.unexpected();
                                let n = !1;
                                do {
                                    const e1 = this.flowParseTypeParameter(n);
                                    t.params.push(e1), e1.default && (n = !0), this.match(48) || this.expect(12);
                                }while (!this.match(48))
                                return this.expect(48), this.state.inType = e1, this.finishNode(t, "TypeParameterDeclaration");
                            }
                            flowParseTypeParameterInstantiation() {
                                const e1 = this.startNode(), t = this.state.inType;
                                e1.params = [], this.state.inType = !0, this.expect(47);
                                const n = this.state.noAnonFunctionType;
                                for(this.state.noAnonFunctionType = !1; !this.match(48);)e1.params.push(this.flowParseType()), this.match(48) || this.expect(12);
                                return this.state.noAnonFunctionType = n, this.expect(48), this.state.inType = t, this.finishNode(e1, "TypeParameterInstantiation");
                            }
                            flowParseTypeParameterInstantiationCallOrNew() {
                                const e1 = this.startNode(), t = this.state.inType;
                                for(e1.params = [], this.state.inType = !0, this.expect(47); !this.match(48);)e1.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
                                return this.expect(48), this.state.inType = t, this.finishNode(e1, "TypeParameterInstantiation");
                            }
                            flowParseInterfaceType() {
                                const e1 = this.startNode();
                                if (this.expectContextual(127), e1.extends = [], this.eat(81)) do {
                                    e1.extends.push(this.flowParseInterfaceExtends());
                                }while (this.eat(12))
                                return e1.body = this.flowParseObjectType({
                                    allowStatic: !1,
                                    allowExact: !1,
                                    allowSpread: !1,
                                    allowProto: !1,
                                    allowInexact: !1
                                }), this.finishNode(e1, "InterfaceTypeAnnotation");
                            }
                            flowParseObjectPropertyKey() {
                                return this.match(132) || this.match(131) ? super.parseExprAtom() : this.parseIdentifier(!0);
                            }
                            flowParseObjectTypeIndexer(e1, t, n) {
                                return e1.static = t, 14 === this.lookahead().type ? (e1.id = this.flowParseObjectPropertyKey(), e1.key = this.flowParseTypeInitialiser()) : (e1.id = null, e1.key = this.flowParseType()), this.expect(3), e1.value = this.flowParseTypeInitialiser(), e1.variance = n, this.finishNode(e1, "ObjectTypeIndexer");
                            }
                            flowParseObjectTypeInternalSlot(e1, t) {
                                return e1.static = t, e1.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (e1.method = !0, e1.optional = !1, e1.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e1.loc.start))) : (e1.method = !1, this.eat(17) && (e1.optional = !0), e1.value = this.flowParseTypeInitialiser()), this.finishNode(e1, "ObjectTypeInternalSlot");
                            }
                            flowParseObjectTypeMethodish(e1) {
                                for(e1.params = [], e1.rest = null, e1.typeParameters = null, e1.this = null, this.match(47) && (e1.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (e1.this = this.flowParseFunctionTypeParam(!0), e1.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21);)e1.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
                                return this.eat(21) && (e1.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), e1.returnType = this.flowParseTypeInitialiser(), this.finishNode(e1, "FunctionTypeAnnotation");
                            }
                            flowParseObjectTypeCallProperty(e1, t) {
                                const n = this.startNode();
                                return e1.static = t, e1.value = this.flowParseObjectTypeMethodish(n), this.finishNode(e1, "ObjectTypeCallProperty");
                            }
                            flowParseObjectType({ allowStatic: e1, allowExact: t, allowSpread: n, allowProto: r, allowInexact: i }) {
                                const s = this.state.inType;
                                this.state.inType = !0;
                                const a = this.startNode();
                                let o, l;
                                a.callProperties = [], a.properties = [], a.indexers = [], a.internalSlots = [];
                                let c = !1;
                                for(t && this.match(6) ? (this.expect(6), o = 9, l = !0) : (this.expect(5), o = 8, l = !1), a.exact = l; !this.match(o);){
                                    let t = !1, s = null, o = null;
                                    const u = this.startNode();
                                    if (r && this.isContextual(116)) {
                                        const t = this.lookahead();
                                        14 !== t.type && 17 !== t.type && (this.next(), s = this.state.startLoc, e1 = !1);
                                    }
                                    if (e1 && this.isContextual(104)) {
                                        const e1 = this.lookahead();
                                        14 !== e1.type && 17 !== e1.type && (this.next(), t = !0);
                                    }
                                    const p = this.flowParseVariance();
                                    if (this.eat(0)) null != s && this.unexpected(s), this.eat(0) ? (p && this.unexpected(p.loc.start), a.internalSlots.push(this.flowParseObjectTypeInternalSlot(u, t))) : a.indexers.push(this.flowParseObjectTypeIndexer(u, t, p));
                                    else if (this.match(10) || this.match(47)) null != s && this.unexpected(s), p && this.unexpected(p.loc.start), a.callProperties.push(this.flowParseObjectTypeCallProperty(u, t));
                                    else {
                                        let e1 = "init";
                                        (this.isContextual(98) || this.isContextual(103)) && Y(this.lookahead().type) && (e1 = this.state.value, this.next());
                                        const r = this.flowParseObjectTypeProperty(u, t, s, p, e1, n, null != i ? i : !l);
                                        null === r ? (c = !0, o = this.state.lastTokStartLoc) : a.properties.push(r);
                                    }
                                    this.flowObjectTypeSemicolon(), !o || this.match(8) || this.match(9) || this.raise(ct.UnexpectedExplicitInexactInObject, {
                                        at: o
                                    });
                                }
                                this.expect(o), n && (a.inexact = c);
                                const u = this.finishNode(a, "ObjectTypeAnnotation");
                                return this.state.inType = s, u;
                            }
                            flowParseObjectTypeProperty(e1, t, n, r, i, s, a) {
                                if (this.eat(21)) return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (s ? a || this.raise(ct.InexactInsideExact, {
                                    at: this.state.lastTokStartLoc
                                }) : this.raise(ct.InexactInsideNonObject, {
                                    at: this.state.lastTokStartLoc
                                }), r && this.raise(ct.InexactVariance, {
                                    at: r
                                }), null) : (s || this.raise(ct.UnexpectedSpreadType, {
                                    at: this.state.lastTokStartLoc
                                }), null != n && this.unexpected(n), r && this.raise(ct.SpreadVariance, {
                                    at: r
                                }), e1.argument = this.flowParseType(), this.finishNode(e1, "ObjectTypeSpreadProperty"));
                                {
                                    e1.key = this.flowParseObjectPropertyKey(), e1.static = t, e1.proto = null != n, e1.kind = i;
                                    let a = !1;
                                    return this.match(47) || this.match(10) ? (e1.method = !0, null != n && this.unexpected(n), r && this.unexpected(r.loc.start), e1.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e1.loc.start)), "get" !== i && "set" !== i || this.flowCheckGetterSetterParams(e1), !s && "constructor" === e1.key.name && e1.value.this && this.raise(ct.ThisParamBannedInConstructor, {
                                        at: e1.value.this
                                    })) : ("init" !== i && this.unexpected(), e1.method = !1, this.eat(17) && (a = !0), e1.value = this.flowParseTypeInitialiser(), e1.variance = r), e1.optional = a, this.finishNode(e1, "ObjectTypeProperty");
                                }
                            }
                            flowCheckGetterSetterParams(e1) {
                                const t = "get" === e1.kind ? 0 : 1, n = e1.value.params.length + (e1.value.rest ? 1 : 0);
                                e1.value.this && this.raise("get" === e1.kind ? ct.GetterMayNotHaveThisParam : ct.SetterMayNotHaveThisParam, {
                                    at: e1.value.this
                                }), n !== t && this.raise("get" === e1.kind ? g.BadGetterArity : g.BadSetterArity, {
                                    at: e1
                                }), "set" === e1.kind && e1.value.rest && this.raise(g.BadSetterRestParameter, {
                                    at: e1
                                });
                            }
                            flowObjectTypeSemicolon() {
                                this.eat(13) || this.eat(12) || this.match(8) || this.match(9) || this.unexpected();
                            }
                            flowParseQualifiedTypeIdentifier(e1, t) {
                                null != e1 || (e1 = this.state.startLoc);
                                let n = t || this.flowParseRestrictedIdentifier(!0);
                                for(; this.eat(16);){
                                    const t = this.startNodeAt(e1);
                                    t.qualification = n, t.id = this.flowParseRestrictedIdentifier(!0), n = this.finishNode(t, "QualifiedTypeIdentifier");
                                }
                                return n;
                            }
                            flowParseGenericType(e1, t) {
                                const n = this.startNodeAt(e1);
                                return n.typeParameters = null, n.id = this.flowParseQualifiedTypeIdentifier(e1, t), this.match(47) && (n.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(n, "GenericTypeAnnotation");
                            }
                            flowParseTypeofType() {
                                const e1 = this.startNode();
                                return this.expect(87), e1.argument = this.flowParsePrimaryType(), this.finishNode(e1, "TypeofTypeAnnotation");
                            }
                            flowParseTupleType() {
                                const e1 = this.startNode();
                                for(e1.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (e1.types.push(this.flowParseType()), !this.match(3));)this.expect(12);
                                return this.expect(3), this.finishNode(e1, "TupleTypeAnnotation");
                            }
                            flowParseFunctionTypeParam(e1) {
                                let t = null, n = !1, r = null;
                                const i = this.startNode(), s = this.lookahead(), a = 78 === this.state.type;
                                return 14 === s.type || 17 === s.type ? (a && !e1 && this.raise(ct.ThisParamMustBeFirst, {
                                    at: i
                                }), t = this.parseIdentifier(a), this.eat(17) && (n = !0, a && this.raise(ct.ThisParamMayNotBeOptional, {
                                    at: i
                                })), r = this.flowParseTypeInitialiser()) : r = this.flowParseType(), i.name = t, i.optional = n, i.typeAnnotation = r, this.finishNode(i, "FunctionTypeParam");
                            }
                            reinterpretTypeAsFunctionTypeParam(e1) {
                                const t = this.startNodeAt(e1.loc.start);
                                return t.name = null, t.optional = !1, t.typeAnnotation = e1, this.finishNode(t, "FunctionTypeParam");
                            }
                            flowParseFunctionTypeParams(e1 = []) {
                                let t = null, n = null;
                                for(this.match(78) && (n = this.flowParseFunctionTypeParam(!0), n.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21);)e1.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
                                return this.eat(21) && (t = this.flowParseFunctionTypeParam(!1)), {
                                    params: e1,
                                    rest: t,
                                    _this: n
                                };
                            }
                            flowIdentToTypeAnnotation(e1, t, n) {
                                switch(n.name){
                                    case "any":
                                        return this.finishNode(t, "AnyTypeAnnotation");
                                    case "bool":
                                    case "boolean":
                                        return this.finishNode(t, "BooleanTypeAnnotation");
                                    case "mixed":
                                        return this.finishNode(t, "MixedTypeAnnotation");
                                    case "empty":
                                        return this.finishNode(t, "EmptyTypeAnnotation");
                                    case "number":
                                        return this.finishNode(t, "NumberTypeAnnotation");
                                    case "string":
                                        return this.finishNode(t, "StringTypeAnnotation");
                                    case "symbol":
                                        return this.finishNode(t, "SymbolTypeAnnotation");
                                    default:
                                        return this.checkNotUnderscore(n.name), this.flowParseGenericType(e1, n);
                                }
                            }
                            flowParsePrimaryType() {
                                const e1 = this.state.startLoc, t = this.startNode();
                                let n, r, i = !1;
                                const s = this.state.noAnonFunctionType;
                                switch(this.state.type){
                                    case 5:
                                        return this.flowParseObjectType({
                                            allowStatic: !1,
                                            allowExact: !1,
                                            allowSpread: !0,
                                            allowProto: !1,
                                            allowInexact: !0
                                        });
                                    case 6:
                                        return this.flowParseObjectType({
                                            allowStatic: !1,
                                            allowExact: !0,
                                            allowSpread: !0,
                                            allowProto: !1,
                                            allowInexact: !1
                                        });
                                    case 0:
                                        return this.state.noAnonFunctionType = !1, r = this.flowParseTupleType(), this.state.noAnonFunctionType = s, r;
                                    case 47:
                                        return t.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), n = this.flowParseFunctionTypeParams(), t.params = n.params, t.rest = n.rest, t.this = n._this, this.expect(11), this.expect(19), t.returnType = this.flowParseType(), this.finishNode(t, "FunctionTypeAnnotation");
                                    case 10:
                                        if (this.next(), !this.match(11) && !this.match(21)) if (W(this.state.type) || this.match(78)) {
                                            const e1 = this.lookahead().type;
                                            i = 17 !== e1 && 14 !== e1;
                                        } else i = !0;
                                        if (i) {
                                            if (this.state.noAnonFunctionType = !1, r = this.flowParseType(), this.state.noAnonFunctionType = s, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && 19 === this.lookahead().type)) return this.expect(11), r;
                                            this.eat(12);
                                        }
                                        return n = r ? this.flowParseFunctionTypeParams([
                                            this.reinterpretTypeAsFunctionTypeParam(r)
                                        ]) : this.flowParseFunctionTypeParams(), t.params = n.params, t.rest = n.rest, t.this = n._this, this.expect(11), this.expect(19), t.returnType = this.flowParseType(), t.typeParameters = null, this.finishNode(t, "FunctionTypeAnnotation");
                                    case 131:
                                        return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
                                    case 85:
                                    case 86:
                                        return t.value = this.match(85), this.next(), this.finishNode(t, "BooleanLiteralTypeAnnotation");
                                    case 53:
                                        if ("-" === this.state.value) {
                                            if (this.next(), this.match(132)) return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", t);
                                            if (this.match(133)) return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", t);
                                            throw this.raise(ct.UnexpectedSubtractionOperand, {
                                                at: this.state.startLoc
                                            });
                                        }
                                        return void this.unexpected();
                                    case 132:
                                        return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
                                    case 133:
                                        return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
                                    case 88:
                                        return this.next(), this.finishNode(t, "VoidTypeAnnotation");
                                    case 84:
                                        return this.next(), this.finishNode(t, "NullLiteralTypeAnnotation");
                                    case 78:
                                        return this.next(), this.finishNode(t, "ThisTypeAnnotation");
                                    case 55:
                                        return this.next(), this.finishNode(t, "ExistsTypeAnnotation");
                                    case 87:
                                        return this.flowParseTypeofType();
                                    default:
                                        if (J(this.state.type)) {
                                            const e1 = $(this.state.type);
                                            return this.next(), super.createIdentifier(t, e1);
                                        }
                                        if (W(this.state.type)) return this.isContextual(127) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e1, t, this.parseIdentifier());
                                }
                                this.unexpected();
                            }
                            flowParsePostfixType() {
                                const e1 = this.state.startLoc;
                                let t = this.flowParsePrimaryType(), n = !1;
                                for(; (this.match(0) || this.match(18)) && !this.canInsertSemicolon();){
                                    const r = this.startNodeAt(e1), i = this.eat(18);
                                    n = n || i, this.expect(0), !i && this.match(3) ? (r.elementType = t, this.next(), t = this.finishNode(r, "ArrayTypeAnnotation")) : (r.objectType = t, r.indexType = this.flowParseType(), this.expect(3), n ? (r.optional = i, t = this.finishNode(r, "OptionalIndexedAccessType")) : t = this.finishNode(r, "IndexedAccessType"));
                                }
                                return t;
                            }
                            flowParsePrefixType() {
                                const e1 = this.startNode();
                                return this.eat(17) ? (e1.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e1, "NullableTypeAnnotation")) : this.flowParsePostfixType();
                            }
                            flowParseAnonFunctionWithoutParens() {
                                const e1 = this.flowParsePrefixType();
                                if (!this.state.noAnonFunctionType && this.eat(19)) {
                                    const t = this.startNodeAt(e1.loc.start);
                                    return t.params = [
                                        this.reinterpretTypeAsFunctionTypeParam(e1)
                                    ], t.rest = null, t.this = null, t.returnType = this.flowParseType(), t.typeParameters = null, this.finishNode(t, "FunctionTypeAnnotation");
                                }
                                return e1;
                            }
                            flowParseIntersectionType() {
                                const e1 = this.startNode();
                                this.eat(45);
                                const t = this.flowParseAnonFunctionWithoutParens();
                                for(e1.types = [
                                    t
                                ]; this.eat(45);)e1.types.push(this.flowParseAnonFunctionWithoutParens());
                                return 1 === e1.types.length ? t : this.finishNode(e1, "IntersectionTypeAnnotation");
                            }
                            flowParseUnionType() {
                                const e1 = this.startNode();
                                this.eat(43);
                                const t = this.flowParseIntersectionType();
                                for(e1.types = [
                                    t
                                ]; this.eat(43);)e1.types.push(this.flowParseIntersectionType());
                                return 1 === e1.types.length ? t : this.finishNode(e1, "UnionTypeAnnotation");
                            }
                            flowParseType() {
                                const e1 = this.state.inType;
                                this.state.inType = !0;
                                const t = this.flowParseUnionType();
                                return this.state.inType = e1, t;
                            }
                            flowParseTypeOrImplicitInstantiation() {
                                if (130 === this.state.type && "_" === this.state.value) {
                                    const e1 = this.state.startLoc, t = this.parseIdentifier();
                                    return this.flowParseGenericType(e1, t);
                                }
                                return this.flowParseType();
                            }
                            flowParseTypeAnnotation() {
                                const e1 = this.startNode();
                                return e1.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e1, "TypeAnnotation");
                            }
                            flowParseTypeAnnotatableIdentifier(e1) {
                                const t = e1 ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
                                return this.match(14) && (t.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(t)), t;
                            }
                            typeCastToParameter(e1) {
                                return e1.expression.typeAnnotation = e1.typeAnnotation, this.resetEndLocation(e1.expression, e1.typeAnnotation.loc.end), e1.expression;
                            }
                            flowParseVariance() {
                                let e1 = null;
                                return this.match(53) ? (e1 = this.startNode(), "+" === this.state.value ? e1.kind = "plus" : e1.kind = "minus", this.next(), this.finishNode(e1, "Variance")) : e1;
                            }
                            parseFunctionBody(e1, t, n = !1) {
                                t ? this.forwardNoArrowParamsConversionAt(e1, ()=>super.parseFunctionBody(e1, !0, n)) : super.parseFunctionBody(e1, !1, n);
                            }
                            parseFunctionBodyAndFinish(e1, t, n = !1) {
                                if (this.match(14)) {
                                    const t = this.startNode();
                                    [t.typeAnnotation, e1.predicate] = this.flowParseTypeAndPredicateInitialiser(), e1.returnType = t.typeAnnotation ? this.finishNode(t, "TypeAnnotation") : null;
                                }
                                return super.parseFunctionBodyAndFinish(e1, t, n);
                            }
                            parseStatementLike(e1) {
                                if (this.state.strict && this.isContextual(127)) {
                                    if (X(this.lookahead().type)) {
                                        const e1 = this.startNode();
                                        return this.next(), this.flowParseInterface(e1);
                                    }
                                } else if (this.shouldParseEnums() && this.isContextual(124)) {
                                    const e1 = this.startNode();
                                    return this.next(), this.flowParseEnumDeclaration(e1);
                                }
                                const t = super.parseStatementLike(e1);
                                return void 0 !== this.flowPragma || this.isValidDirective(t) || (this.flowPragma = null), t;
                            }
                            parseExpressionStatement(e1, t, n) {
                                if ("Identifier" === t.type) {
                                    if ("declare" === t.name) {
                                        if (this.match(80) || W(this.state.type) || this.match(68) || this.match(74) || this.match(82)) return this.flowParseDeclare(e1);
                                    } else if (W(this.state.type)) {
                                        if ("interface" === t.name) return this.flowParseInterface(e1);
                                        if ("type" === t.name) return this.flowParseTypeAlias(e1);
                                        if ("opaque" === t.name) return this.flowParseOpaqueType(e1, !1);
                                    }
                                }
                                return super.parseExpressionStatement(e1, t, n);
                            }
                            shouldParseExportDeclaration() {
                                const { type: e1 } = this.state;
                                return H(e1) || this.shouldParseEnums() && 124 === e1 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
                            }
                            isExportDefaultSpecifier() {
                                const { type: e1 } = this.state;
                                return H(e1) || this.shouldParseEnums() && 124 === e1 ? this.state.containsEsc : super.isExportDefaultSpecifier();
                            }
                            parseExportDefaultExpression() {
                                if (this.shouldParseEnums() && this.isContextual(124)) {
                                    const e1 = this.startNode();
                                    return this.next(), this.flowParseEnumDeclaration(e1);
                                }
                                return super.parseExportDefaultExpression();
                            }
                            parseConditional(e1, t, n) {
                                if (!this.match(17)) return e1;
                                if (this.state.maybeInArrowParameters) {
                                    const t = this.lookaheadCharCode();
                                    if (44 === t || 61 === t || 58 === t || 41 === t) return this.setOptionalParametersError(n), e1;
                                }
                                this.expect(17);
                                const r = this.state.clone(), i = this.state.noArrowAt, s = this.startNodeAt(t);
                                let { consequent: a, failed: o } = this.tryParseConditionalConsequent(), [l, c] = this.getArrowLikeExpressions(a);
                                if (o || c.length > 0) {
                                    const e1 = [
                                        ...i
                                    ];
                                    if (c.length > 0) {
                                        this.state = r, this.state.noArrowAt = e1;
                                        for(let t = 0; t < c.length; t++)e1.push(c[t].start);
                                        ({ consequent: a, failed: o } = this.tryParseConditionalConsequent()), [l, c] = this.getArrowLikeExpressions(a);
                                    }
                                    o && l.length > 1 && this.raise(ct.AmbiguousConditionalArrow, {
                                        at: r.startLoc
                                    }), o && 1 === l.length && (this.state = r, e1.push(l[0].start), this.state.noArrowAt = e1, { consequent: a, failed: o } = this.tryParseConditionalConsequent());
                                }
                                return this.getArrowLikeExpressions(a, !0), this.state.noArrowAt = i, this.expect(14), s.test = e1, s.consequent = a, s.alternate = this.forwardNoArrowParamsConversionAt(s, ()=>this.parseMaybeAssign(void 0, void 0)), this.finishNode(s, "ConditionalExpression");
                            }
                            tryParseConditionalConsequent() {
                                this.state.noArrowParamsConversionAt.push(this.state.start);
                                const e1 = this.parseMaybeAssignAllowIn(), t = !this.match(14);
                                return this.state.noArrowParamsConversionAt.pop(), {
                                    consequent: e1,
                                    failed: t
                                };
                            }
                            getArrowLikeExpressions(e1, t) {
                                const n = [
                                    e1
                                ], r = [];
                                for(; 0 !== n.length;){
                                    const e1 = n.pop();
                                    "ArrowFunctionExpression" === e1.type ? (e1.typeParameters || !e1.returnType ? this.finishArrowValidation(e1) : r.push(e1), n.push(e1.body)) : "ConditionalExpression" === e1.type && (n.push(e1.consequent), n.push(e1.alternate));
                                }
                                return t ? (r.forEach((e1)=>this.finishArrowValidation(e1)), [
                                    r,
                                    []
                                ]) : function(e1, t) {
                                    const n = [], r = [];
                                    for(let i = 0; i < e1.length; i++)(t(e1[i]) ? n : r).push(e1[i]);
                                    return [
                                        n,
                                        r
                                    ];
                                }(r, (e1)=>e1.params.every((e1)=>this.isAssignable(e1, !0)));
                            }
                            finishArrowValidation(e1) {
                                var t;
                                this.toAssignableList(e1.params, null == (t = e1.extra) ? void 0 : t.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(e1, !1, !0), this.scope.exit();
                            }
                            forwardNoArrowParamsConversionAt(e1, t) {
                                let n;
                                return -1 !== this.state.noArrowParamsConversionAt.indexOf(e1.start) ? (this.state.noArrowParamsConversionAt.push(this.state.start), n = t(), this.state.noArrowParamsConversionAt.pop()) : n = t(), n;
                            }
                            parseParenItem(e1, t) {
                                if (e1 = super.parseParenItem(e1, t), this.eat(17) && (e1.optional = !0, this.resetEndLocation(e1)), this.match(14)) {
                                    const n = this.startNodeAt(t);
                                    return n.expression = e1, n.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(n, "TypeCastExpression");
                                }
                                return e1;
                            }
                            assertModuleNodeAllowed(e1) {
                                "ImportDeclaration" === e1.type && ("type" === e1.importKind || "typeof" === e1.importKind) || "ExportNamedDeclaration" === e1.type && "type" === e1.exportKind || "ExportAllDeclaration" === e1.type && "type" === e1.exportKind || super.assertModuleNodeAllowed(e1);
                            }
                            parseExportDeclaration(e1) {
                                if (this.isContextual(128)) {
                                    e1.exportKind = "type";
                                    const t = this.startNode();
                                    return this.next(), this.match(5) ? (e1.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(e1), null) : this.flowParseTypeAlias(t);
                                }
                                if (this.isContextual(129)) {
                                    e1.exportKind = "type";
                                    const t = this.startNode();
                                    return this.next(), this.flowParseOpaqueType(t, !1);
                                }
                                if (this.isContextual(127)) {
                                    e1.exportKind = "type";
                                    const t = this.startNode();
                                    return this.next(), this.flowParseInterface(t);
                                }
                                if (this.shouldParseEnums() && this.isContextual(124)) {
                                    e1.exportKind = "value";
                                    const t = this.startNode();
                                    return this.next(), this.flowParseEnumDeclaration(t);
                                }
                                return super.parseExportDeclaration(e1);
                            }
                            eatExportStar(e1) {
                                return !!super.eatExportStar(e1) || !(!this.isContextual(128) || 55 !== this.lookahead().type) && (e1.exportKind = "type", this.next(), this.next(), !0);
                            }
                            maybeParseExportNamespaceSpecifier(e1) {
                                const { startLoc: t } = this.state, n = super.maybeParseExportNamespaceSpecifier(e1);
                                return n && "type" === e1.exportKind && this.unexpected(t), n;
                            }
                            parseClassId(e1, t, n) {
                                super.parseClassId(e1, t, n), this.match(47) && (e1.typeParameters = this.flowParseTypeParameterDeclaration());
                            }
                            parseClassMember(e1, t, n) {
                                const { startLoc: r } = this.state;
                                if (this.isContextual(123)) {
                                    if (super.parseClassMemberFromModifier(e1, t)) return;
                                    t.declare = !0;
                                }
                                super.parseClassMember(e1, t, n), t.declare && ("ClassProperty" !== t.type && "ClassPrivateProperty" !== t.type && "PropertyDefinition" !== t.type ? this.raise(ct.DeclareClassElement, {
                                    at: r
                                }) : t.value && this.raise(ct.DeclareClassFieldInitializer, {
                                    at: t.value
                                }));
                            }
                            isIterator(e1) {
                                return "iterator" === e1 || "asyncIterator" === e1;
                            }
                            readIterator() {
                                const e1 = super.readWord1(), t = "@@" + e1;
                                this.isIterator(e1) && this.state.inType || this.raise(g.InvalidIdentifier, {
                                    at: this.state.curPosition(),
                                    identifierName: t
                                }), this.finishToken(130, t);
                            }
                            getTokenFromCode(e1) {
                                const t = this.input.charCodeAt(this.state.pos + 1);
                                123 === e1 && 124 === t ? this.finishOp(6, 2) : !this.state.inType || 62 !== e1 && 60 !== e1 ? this.state.inType && 63 === e1 ? 46 === t ? this.finishOp(18, 2) : this.finishOp(17, 1) : function(e1, t, n) {
                                    return 64 === e1 && 64 === t && ae(n);
                                }(e1, t, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(e1) : this.finishOp(62 === e1 ? 48 : 47, 1);
                            }
                            isAssignable(e1, t) {
                                return "TypeCastExpression" === e1.type ? this.isAssignable(e1.expression, t) : super.isAssignable(e1, t);
                            }
                            toAssignable(e1, t = !1) {
                                t || "AssignmentExpression" !== e1.type || "TypeCastExpression" !== e1.left.type || (e1.left = this.typeCastToParameter(e1.left)), super.toAssignable(e1, t);
                            }
                            toAssignableList(e1, t, n) {
                                for(let t = 0; t < e1.length; t++){
                                    const n = e1[t];
                                    "TypeCastExpression" === (null == n ? void 0 : n.type) && (e1[t] = this.typeCastToParameter(n));
                                }
                                super.toAssignableList(e1, t, n);
                            }
                            toReferencedList(e1, t) {
                                for(let r = 0; r < e1.length; r++){
                                    var n;
                                    const i = e1[r];
                                    !i || "TypeCastExpression" !== i.type || null != (n = i.extra) && n.parenthesized || !(e1.length > 1) && t || this.raise(ct.TypeCastInPattern, {
                                        at: i.typeAnnotation
                                    });
                                }
                                return e1;
                            }
                            parseArrayLike(e1, t, n, r) {
                                const i = super.parseArrayLike(e1, t, n, r);
                                return t && !this.state.maybeInArrowParameters && this.toReferencedList(i.elements), i;
                            }
                            isValidLVal(e1, t, n) {
                                return "TypeCastExpression" === e1 || super.isValidLVal(e1, t, n);
                            }
                            parseClassProperty(e1) {
                                return this.match(14) && (e1.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e1);
                            }
                            parseClassPrivateProperty(e1) {
                                return this.match(14) && (e1.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e1);
                            }
                            isClassMethod() {
                                return this.match(47) || super.isClassMethod();
                            }
                            isClassProperty() {
                                return this.match(14) || super.isClassProperty();
                            }
                            isNonstaticConstructor(e1) {
                                return !this.match(14) && super.isNonstaticConstructor(e1);
                            }
                            pushClassMethod(e1, t, n, r, i, s) {
                                if (t.variance && this.unexpected(t.variance.loc.start), delete t.variance, this.match(47) && (t.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e1, t, n, r, i, s), t.params && i) {
                                    const e1 = t.params;
                                    e1.length > 0 && this.isThisParam(e1[0]) && this.raise(ct.ThisParamBannedInConstructor, {
                                        at: t
                                    });
                                } else if ("MethodDefinition" === t.type && i && t.value.params) {
                                    const e1 = t.value.params;
                                    e1.length > 0 && this.isThisParam(e1[0]) && this.raise(ct.ThisParamBannedInConstructor, {
                                        at: t
                                    });
                                }
                            }
                            pushClassPrivateMethod(e1, t, n, r) {
                                t.variance && this.unexpected(t.variance.loc.start), delete t.variance, this.match(47) && (t.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e1, t, n, r);
                            }
                            parseClassSuper(e1) {
                                if (super.parseClassSuper(e1), e1.superClass && this.match(47) && (e1.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(111)) {
                                    this.next();
                                    const t = e1.implements = [];
                                    do {
                                        const e1 = this.startNode();
                                        e1.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? e1.typeParameters = this.flowParseTypeParameterInstantiation() : e1.typeParameters = null, t.push(this.finishNode(e1, "ClassImplements"));
                                    }while (this.eat(12))
                                }
                            }
                            checkGetterSetterParams(e1) {
                                super.checkGetterSetterParams(e1);
                                const t = this.getObjectOrClassMethodParams(e1);
                                if (t.length > 0) {
                                    const n = t[0];
                                    this.isThisParam(n) && "get" === e1.kind ? this.raise(ct.GetterMayNotHaveThisParam, {
                                        at: n
                                    }) : this.isThisParam(n) && this.raise(ct.SetterMayNotHaveThisParam, {
                                        at: n
                                    });
                                }
                            }
                            parsePropertyNamePrefixOperator(e1) {
                                e1.variance = this.flowParseVariance();
                            }
                            parseObjPropValue(e1, t, n, r, i, s, a) {
                                let o;
                                e1.variance && this.unexpected(e1.variance.loc.start), delete e1.variance, this.match(47) && !s && (o = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
                                const l = super.parseObjPropValue(e1, t, n, r, i, s, a);
                                return o && ((l.value || l).typeParameters = o), l;
                            }
                            parseAssignableListItemTypes(e1) {
                                return this.eat(17) && ("Identifier" !== e1.type && this.raise(ct.PatternIsOptional, {
                                    at: e1
                                }), this.isThisParam(e1) && this.raise(ct.ThisParamMayNotBeOptional, {
                                    at: e1
                                }), e1.optional = !0), this.match(14) ? e1.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e1) && this.raise(ct.ThisParamAnnotationRequired, {
                                    at: e1
                                }), this.match(29) && this.isThisParam(e1) && this.raise(ct.ThisParamNoDefault, {
                                    at: e1
                                }), this.resetEndLocation(e1), e1;
                            }
                            parseMaybeDefault(e1, t) {
                                const n = super.parseMaybeDefault(e1, t);
                                return "AssignmentPattern" === n.type && n.typeAnnotation && n.right.start < n.typeAnnotation.start && this.raise(ct.TypeBeforeInitializer, {
                                    at: n.typeAnnotation
                                }), n;
                            }
                            checkImportReflection(e1) {
                                super.checkImportReflection(e1), e1.module && "value" !== e1.importKind && this.raise(ct.ImportReflectionHasImportType, {
                                    at: e1.specifiers[0].loc.start
                                });
                            }
                            parseImportSpecifierLocal(e1, t, n) {
                                t.local = ut(e1) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), e1.specifiers.push(this.finishImportSpecifier(t, n));
                            }
                            isPotentialImportPhase(e1) {
                                if (super.isPotentialImportPhase(e1)) return !0;
                                if (this.isContextual(128)) {
                                    if (!e1) return !0;
                                    const t = this.lookaheadCharCode();
                                    return 123 === t || 42 === t;
                                }
                                return !e1 && this.isContextual(87);
                            }
                            applyImportPhase(e1, t, n, r) {
                                if (super.applyImportPhase(e1, t, n, r), t) {
                                    if (!n && this.match(65)) return;
                                    e1.exportKind = "type" === n ? n : "value";
                                } else "type" === n && this.match(55) && this.unexpected(), e1.importKind = "type" === n || "typeof" === n ? n : "value";
                            }
                            parseImportSpecifier(e1, t, n, r, i) {
                                const s = e1.imported;
                                let a = null;
                                "Identifier" === s.type && ("type" === s.name ? a = "type" : "typeof" === s.name && (a = "typeof"));
                                let o = !1;
                                if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
                                    const t = this.parseIdentifier(!0);
                                    null === a || X(this.state.type) ? (e1.imported = s, e1.importKind = null, e1.local = this.parseIdentifier()) : (e1.imported = t, e1.importKind = a, e1.local = at(t));
                                } else {
                                    if (null !== a && X(this.state.type)) e1.imported = this.parseIdentifier(!0), e1.importKind = a;
                                    else {
                                        if (t) throw this.raise(g.ImportBindingIsString, {
                                            at: e1,
                                            importName: s.value
                                        });
                                        e1.imported = s, e1.importKind = null;
                                    }
                                    this.eatContextual(93) ? e1.local = this.parseIdentifier() : (o = !0, e1.local = at(e1.imported));
                                }
                                const l = ut(e1);
                                return n && l && this.raise(ct.ImportTypeShorthandOnlyInPureImport, {
                                    at: e1
                                }), (n || l) && this.checkReservedType(e1.local.name, e1.local.loc.start, !0), !o || n || l || this.checkReservedWord(e1.local.name, e1.loc.start, !0, !0), this.finishImportSpecifier(e1, "ImportSpecifier");
                            }
                            parseBindingAtom() {
                                return 78 === this.state.type ? this.parseIdentifier(!0) : super.parseBindingAtom();
                            }
                            parseFunctionParams(e1, t) {
                                const n = e1.kind;
                                "get" !== n && "set" !== n && this.match(47) && (e1.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e1, t);
                            }
                            parseVarId(e1, t) {
                                super.parseVarId(e1, t), this.match(14) && (e1.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e1.id));
                            }
                            parseAsyncArrowFromCallExpression(e1, t) {
                                if (this.match(14)) {
                                    const t = this.state.noAnonFunctionType;
                                    this.state.noAnonFunctionType = !0, e1.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = t;
                                }
                                return super.parseAsyncArrowFromCallExpression(e1, t);
                            }
                            shouldParseAsyncArrow() {
                                return this.match(14) || super.shouldParseAsyncArrow();
                            }
                            parseMaybeAssign(e1, t) {
                                var n;
                                let r, i = null;
                                if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
                                    if (i = this.state.clone(), r = this.tryParse(()=>super.parseMaybeAssign(e1, t), i), !r.error) return r.node;
                                    const { context: n } = this.state, s = n[n.length - 1];
                                    s !== x.j_oTag && s !== x.j_expr || n.pop();
                                }
                                if (null != (n = r) && n.error || this.match(47)) {
                                    var s, a;
                                    let n;
                                    i = i || this.state.clone();
                                    const o = this.tryParse((r)=>{
                                        var i;
                                        n = this.flowParseTypeParameterDeclaration();
                                        const s = this.forwardNoArrowParamsConversionAt(n, ()=>{
                                            const r = super.parseMaybeAssign(e1, t);
                                            return this.resetStartLocationFromNode(r, n), r;
                                        });
                                        null != (i = s.extra) && i.parenthesized && r();
                                        const a = this.maybeUnwrapTypeCastExpression(s);
                                        return "ArrowFunctionExpression" !== a.type && r(), a.typeParameters = n, this.resetStartLocationFromNode(a, n), s;
                                    }, i);
                                    let l = null;
                                    if (o.node && "ArrowFunctionExpression" === this.maybeUnwrapTypeCastExpression(o.node).type) {
                                        if (!o.error && !o.aborted) return o.node.async && this.raise(ct.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
                                            at: n
                                        }), o.node;
                                        l = o.node;
                                    }
                                    if (null != (s = r) && s.node) return this.state = r.failState, r.node;
                                    if (l) return this.state = o.failState, l;
                                    if (null != (a = r) && a.thrown) throw r.error;
                                    if (o.thrown) throw o.error;
                                    throw this.raise(ct.UnexpectedTokenAfterTypeParameter, {
                                        at: n
                                    });
                                }
                                return super.parseMaybeAssign(e1, t);
                            }
                            parseArrow(e1) {
                                if (this.match(14)) {
                                    const t = this.tryParse(()=>{
                                        const t = this.state.noAnonFunctionType;
                                        this.state.noAnonFunctionType = !0;
                                        const n = this.startNode();
                                        return [n.typeAnnotation, e1.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = t, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), n;
                                    });
                                    if (t.thrown) return null;
                                    t.error && (this.state = t.failState), e1.returnType = t.node.typeAnnotation ? this.finishNode(t.node, "TypeAnnotation") : null;
                                }
                                return super.parseArrow(e1);
                            }
                            shouldParseArrow(e1) {
                                return this.match(14) || super.shouldParseArrow(e1);
                            }
                            setArrowFunctionParameters(e1, t) {
                                -1 !== this.state.noArrowParamsConversionAt.indexOf(e1.start) ? e1.params = t : super.setArrowFunctionParameters(e1, t);
                            }
                            checkParams(e1, t, n, r = !0) {
                                if (!n || -1 === this.state.noArrowParamsConversionAt.indexOf(e1.start)) {
                                    for(let t = 0; t < e1.params.length; t++)this.isThisParam(e1.params[t]) && t > 0 && this.raise(ct.ThisParamMustBeFirst, {
                                        at: e1.params[t]
                                    });
                                    super.checkParams(e1, t, n, r);
                                }
                            }
                            parseParenAndDistinguishExpression(e1) {
                                return super.parseParenAndDistinguishExpression(e1 && -1 === this.state.noArrowAt.indexOf(this.state.start));
                            }
                            parseSubscripts(e1, t, n) {
                                if ("Identifier" === e1.type && "async" === e1.name && -1 !== this.state.noArrowAt.indexOf(t.index)) {
                                    this.next();
                                    const n = this.startNodeAt(t);
                                    n.callee = e1, n.arguments = super.parseCallExpressionArguments(11, !1), e1 = this.finishNode(n, "CallExpression");
                                } else if ("Identifier" === e1.type && "async" === e1.name && this.match(47)) {
                                    const r = this.state.clone(), i = this.tryParse((e1)=>this.parseAsyncArrowWithTypeParameters(t) || e1(), r);
                                    if (!i.error && !i.aborted) return i.node;
                                    const s = this.tryParse(()=>super.parseSubscripts(e1, t, n), r);
                                    if (s.node && !s.error) return s.node;
                                    if (i.node) return this.state = i.failState, i.node;
                                    if (s.node) return this.state = s.failState, s.node;
                                    throw i.error || s.error;
                                }
                                return super.parseSubscripts(e1, t, n);
                            }
                            parseSubscript(e1, t, n, r) {
                                if (this.match(18) && this.isLookaheadToken_lt()) {
                                    if (r.optionalChainMember = !0, n) return r.stop = !0, e1;
                                    this.next();
                                    const i = this.startNodeAt(t);
                                    return i.callee = e1, i.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), i.arguments = this.parseCallExpressionArguments(11, !1), i.optional = !0, this.finishCallExpression(i, !0);
                                }
                                if (!n && this.shouldParseTypes() && this.match(47)) {
                                    const n = this.startNodeAt(t);
                                    n.callee = e1;
                                    const i = this.tryParse(()=>(n.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), n.arguments = super.parseCallExpressionArguments(11, !1), r.optionalChainMember && (n.optional = !1), this.finishCallExpression(n, r.optionalChainMember)));
                                    if (i.node) return i.error && (this.state = i.failState), i.node;
                                }
                                return super.parseSubscript(e1, t, n, r);
                            }
                            parseNewCallee(e1) {
                                super.parseNewCallee(e1);
                                let t = null;
                                this.shouldParseTypes() && this.match(47) && (t = this.tryParse(()=>this.flowParseTypeParameterInstantiationCallOrNew()).node), e1.typeArguments = t;
                            }
                            parseAsyncArrowWithTypeParameters(e1) {
                                const t = this.startNodeAt(e1);
                                if (this.parseFunctionParams(t, !1), this.parseArrow(t)) return super.parseArrowExpression(t, void 0, !0);
                            }
                            readToken_mult_modulo(e1) {
                                const t = this.input.charCodeAt(this.state.pos + 1);
                                if (42 === e1 && 47 === t && this.state.hasFlowComment) return this.state.hasFlowComment = !1, this.state.pos += 2, void this.nextToken();
                                super.readToken_mult_modulo(e1);
                            }
                            readToken_pipe_amp(e1) {
                                const t = this.input.charCodeAt(this.state.pos + 1);
                                124 !== e1 || 125 !== t ? super.readToken_pipe_amp(e1) : this.finishOp(9, 2);
                            }
                            parseTopLevel(e1, t) {
                                const n = super.parseTopLevel(e1, t);
                                return this.state.hasFlowComment && this.raise(ct.UnterminatedFlowComment, {
                                    at: this.state.curPosition()
                                }), n;
                            }
                            skipBlockComment() {
                                if (!this.hasPlugin("flowComments") || !this.skipFlowComment()) return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
                                {
                                    if (this.state.hasFlowComment) throw this.raise(ct.NestedFlowComment, {
                                        at: this.state.startLoc
                                    });
                                    this.hasFlowCommentCompletion();
                                    const e1 = this.skipFlowComment();
                                    e1 && (this.state.pos += e1, this.state.hasFlowComment = !0);
                                }
                            }
                            skipFlowComment() {
                                const { pos: e1 } = this.state;
                                let t = 2;
                                for(; [
                                    32,
                                    9
                                ].includes(this.input.charCodeAt(e1 + t));)t++;
                                const n = this.input.charCodeAt(t + e1), r = this.input.charCodeAt(t + e1 + 1);
                                return 58 === n && 58 === r ? t + 2 : "flow-include" === this.input.slice(t + e1, t + e1 + 12) ? t + 12 : 58 === n && 58 !== r && t;
                            }
                            hasFlowCommentCompletion() {
                                if (-1 === this.input.indexOf("*/", this.state.pos)) throw this.raise(g.UnterminatedComment, {
                                    at: this.state.curPosition()
                                });
                            }
                            flowEnumErrorBooleanMemberNotInitialized(e1, { enumName: t, memberName: n }) {
                                this.raise(ct.EnumBooleanMemberNotInitialized, {
                                    at: e1,
                                    memberName: n,
                                    enumName: t
                                });
                            }
                            flowEnumErrorInvalidMemberInitializer(e1, t) {
                                return this.raise(t.explicitType ? "symbol" === t.explicitType ? ct.EnumInvalidMemberInitializerSymbolType : ct.EnumInvalidMemberInitializerPrimaryType : ct.EnumInvalidMemberInitializerUnknownType, Object.assign({
                                    at: e1
                                }, t));
                            }
                            flowEnumErrorNumberMemberNotInitialized(e1, { enumName: t, memberName: n }) {
                                this.raise(ct.EnumNumberMemberNotInitialized, {
                                    at: e1,
                                    enumName: t,
                                    memberName: n
                                });
                            }
                            flowEnumErrorStringMemberInconsistentlyInitialized(e1, { enumName: t }) {
                                this.raise(ct.EnumStringMemberInconsistentlyInitialized, {
                                    at: e1,
                                    enumName: t
                                });
                            }
                            flowEnumMemberInit() {
                                const e1 = this.state.startLoc, t = ()=>this.match(12) || this.match(8);
                                switch(this.state.type){
                                    case 132:
                                        {
                                            const n = this.parseNumericLiteral(this.state.value);
                                            return t() ? {
                                                type: "number",
                                                loc: n.loc.start,
                                                value: n
                                            } : {
                                                type: "invalid",
                                                loc: e1
                                            };
                                        }
                                    case 131:
                                        {
                                            const n = this.parseStringLiteral(this.state.value);
                                            return t() ? {
                                                type: "string",
                                                loc: n.loc.start,
                                                value: n
                                            } : {
                                                type: "invalid",
                                                loc: e1
                                            };
                                        }
                                    case 85:
                                    case 86:
                                        {
                                            const n = this.parseBooleanLiteral(this.match(85));
                                            return t() ? {
                                                type: "boolean",
                                                loc: n.loc.start,
                                                value: n
                                            } : {
                                                type: "invalid",
                                                loc: e1
                                            };
                                        }
                                    default:
                                        return {
                                            type: "invalid",
                                            loc: e1
                                        };
                                }
                            }
                            flowEnumMemberRaw() {
                                const e1 = this.state.startLoc;
                                return {
                                    id: this.parseIdentifier(!0),
                                    init: this.eat(29) ? this.flowEnumMemberInit() : {
                                        type: "none",
                                        loc: e1
                                    }
                                };
                            }
                            flowEnumCheckExplicitTypeMismatch(e1, t, n) {
                                const { explicitType: r } = t;
                                null !== r && r !== n && this.flowEnumErrorInvalidMemberInitializer(e1, t);
                            }
                            flowEnumMembers({ enumName: e1, explicitType: t }) {
                                const n = new Set, r = {
                                    booleanMembers: [],
                                    numberMembers: [],
                                    stringMembers: [],
                                    defaultedMembers: []
                                };
                                let i = !1;
                                for(; !this.match(8);){
                                    if (this.eat(21)) {
                                        i = !0;
                                        break;
                                    }
                                    const s = this.startNode(), { id: a, init: o } = this.flowEnumMemberRaw(), l = a.name;
                                    if ("" === l) continue;
                                    /^[a-z]/.test(l) && this.raise(ct.EnumInvalidMemberName, {
                                        at: a,
                                        memberName: l,
                                        suggestion: l[0].toUpperCase() + l.slice(1),
                                        enumName: e1
                                    }), n.has(l) && this.raise(ct.EnumDuplicateMemberName, {
                                        at: a,
                                        memberName: l,
                                        enumName: e1
                                    }), n.add(l);
                                    const c = {
                                        enumName: e1,
                                        explicitType: t,
                                        memberName: l
                                    };
                                    switch(s.id = a, o.type){
                                        case "boolean":
                                            this.flowEnumCheckExplicitTypeMismatch(o.loc, c, "boolean"), s.init = o.value, r.booleanMembers.push(this.finishNode(s, "EnumBooleanMember"));
                                            break;
                                        case "number":
                                            this.flowEnumCheckExplicitTypeMismatch(o.loc, c, "number"), s.init = o.value, r.numberMembers.push(this.finishNode(s, "EnumNumberMember"));
                                            break;
                                        case "string":
                                            this.flowEnumCheckExplicitTypeMismatch(o.loc, c, "string"), s.init = o.value, r.stringMembers.push(this.finishNode(s, "EnumStringMember"));
                                            break;
                                        case "invalid":
                                            throw this.flowEnumErrorInvalidMemberInitializer(o.loc, c);
                                        case "none":
                                            switch(t){
                                                case "boolean":
                                                    this.flowEnumErrorBooleanMemberNotInitialized(o.loc, c);
                                                    break;
                                                case "number":
                                                    this.flowEnumErrorNumberMemberNotInitialized(o.loc, c);
                                                    break;
                                                default:
                                                    r.defaultedMembers.push(this.finishNode(s, "EnumDefaultedMember"));
                                            }
                                    }
                                    this.match(8) || this.expect(12);
                                }
                                return {
                                    members: r,
                                    hasUnknownMembers: i
                                };
                            }
                            flowEnumStringMembers(e1, t, { enumName: n }) {
                                if (0 === e1.length) return t;
                                if (0 === t.length) return e1;
                                if (t.length > e1.length) {
                                    for (const t of e1)this.flowEnumErrorStringMemberInconsistentlyInitialized(t, {
                                        enumName: n
                                    });
                                    return t;
                                }
                                for (const e1 of t)this.flowEnumErrorStringMemberInconsistentlyInitialized(e1, {
                                    enumName: n
                                });
                                return e1;
                            }
                            flowEnumParseExplicitType({ enumName: e1 }) {
                                if (!this.eatContextual(101)) return null;
                                if (!W(this.state.type)) throw this.raise(ct.EnumInvalidExplicitTypeUnknownSupplied, {
                                    at: this.state.startLoc,
                                    enumName: e1
                                });
                                const { value: t } = this.state;
                                return this.next(), "boolean" !== t && "number" !== t && "string" !== t && "symbol" !== t && this.raise(ct.EnumInvalidExplicitType, {
                                    at: this.state.startLoc,
                                    enumName: e1,
                                    invalidEnumType: t
                                }), t;
                            }
                            flowEnumBody(e1, t) {
                                const n = t.name, r = t.loc.start, i = this.flowEnumParseExplicitType({
                                    enumName: n
                                });
                                this.expect(5);
                                const { members: s, hasUnknownMembers: a } = this.flowEnumMembers({
                                    enumName: n,
                                    explicitType: i
                                });
                                switch(e1.hasUnknownMembers = a, i){
                                    case "boolean":
                                        return e1.explicitType = !0, e1.members = s.booleanMembers, this.expect(8), this.finishNode(e1, "EnumBooleanBody");
                                    case "number":
                                        return e1.explicitType = !0, e1.members = s.numberMembers, this.expect(8), this.finishNode(e1, "EnumNumberBody");
                                    case "string":
                                        return e1.explicitType = !0, e1.members = this.flowEnumStringMembers(s.stringMembers, s.defaultedMembers, {
                                            enumName: n
                                        }), this.expect(8), this.finishNode(e1, "EnumStringBody");
                                    case "symbol":
                                        return e1.members = s.defaultedMembers, this.expect(8), this.finishNode(e1, "EnumSymbolBody");
                                    default:
                                        {
                                            const t = ()=>(e1.members = [], this.expect(8), this.finishNode(e1, "EnumStringBody"));
                                            e1.explicitType = !1;
                                            const i = s.booleanMembers.length, a = s.numberMembers.length, o = s.stringMembers.length, l = s.defaultedMembers.length;
                                            if (i || a || o || l) {
                                                if (i || a) {
                                                    if (!a && !o && i >= l) {
                                                        for (const e1 of s.defaultedMembers)this.flowEnumErrorBooleanMemberNotInitialized(e1.loc.start, {
                                                            enumName: n,
                                                            memberName: e1.id.name
                                                        });
                                                        return e1.members = s.booleanMembers, this.expect(8), this.finishNode(e1, "EnumBooleanBody");
                                                    }
                                                    if (!i && !o && a >= l) {
                                                        for (const e1 of s.defaultedMembers)this.flowEnumErrorNumberMemberNotInitialized(e1.loc.start, {
                                                            enumName: n,
                                                            memberName: e1.id.name
                                                        });
                                                        return e1.members = s.numberMembers, this.expect(8), this.finishNode(e1, "EnumNumberBody");
                                                    }
                                                    return this.raise(ct.EnumInconsistentMemberValues, {
                                                        at: r,
                                                        enumName: n
                                                    }), t();
                                                }
                                                return e1.members = this.flowEnumStringMembers(s.stringMembers, s.defaultedMembers, {
                                                    enumName: n
                                                }), this.expect(8), this.finishNode(e1, "EnumStringBody");
                                            }
                                            return t();
                                        }
                                }
                            }
                            flowParseEnumDeclaration(e1) {
                                const t = this.parseIdentifier();
                                return e1.id = t, e1.body = this.flowEnumBody(this.startNode(), t), this.finishNode(e1, "EnumDeclaration");
                            }
                            isLookaheadToken_lt() {
                                const e1 = this.nextTokenStart();
                                if (60 === this.input.charCodeAt(e1)) {
                                    const t = this.input.charCodeAt(e1 + 1);
                                    return 60 !== t && 61 !== t;
                                }
                                return !1;
                            }
                            maybeUnwrapTypeCastExpression(e1) {
                                return "TypeCastExpression" === e1.type ? e1.expression : e1;
                            }
                        },
                    typescript: (e1)=>class extends e1 {
                            constructor(...e1){
                                super(...e1), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
                                    allowedModifiers: [
                                        "in",
                                        "out"
                                    ],
                                    disallowedModifiers: [
                                        "const",
                                        "public",
                                        "private",
                                        "protected",
                                        "readonly",
                                        "declare",
                                        "abstract",
                                        "override"
                                    ],
                                    errorTemplate: Pt.InvalidModifierOnTypeParameter
                                }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
                                    allowedModifiers: [
                                        "const"
                                    ],
                                    disallowedModifiers: [
                                        "in",
                                        "out"
                                    ],
                                    errorTemplate: Pt.InvalidModifierOnTypeParameterPositions
                                }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
                                    allowedModifiers: [
                                        "in",
                                        "out",
                                        "const"
                                    ],
                                    disallowedModifiers: [
                                        "public",
                                        "private",
                                        "protected",
                                        "readonly",
                                        "declare",
                                        "abstract",
                                        "override"
                                    ],
                                    errorTemplate: Pt.InvalidModifierOnTypeParameter
                                });
                            }
                            getScopeHandler() {
                                return gt;
                            }
                            tsIsIdentifier() {
                                return W(this.state.type);
                            }
                            tsTokenCanFollowModifier() {
                                return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(136) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
                            }
                            tsNextTokenCanFollowModifier() {
                                return this.next(), this.tsTokenCanFollowModifier();
                            }
                            tsParseModifier(e1, t) {
                                if (!W(this.state.type) && 58 !== this.state.type && 75 !== this.state.type) return;
                                const n = this.state.value;
                                if (-1 !== e1.indexOf(n)) {
                                    if (t && this.tsIsStartOfStaticBlocks()) return;
                                    if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return n;
                                }
                            }
                            tsParseModifiers({ allowedModifiers: e1, disallowedModifiers: t, stopOnStartOfClassStaticBlock: n, errorTemplate: r = Pt.InvalidModifierOnTypeMember }, i) {
                                const s = (e1, t, n, r)=>{
                                    t === n && i[r] && this.raise(Pt.InvalidModifiersOrder, {
                                        at: e1,
                                        orderedModifiers: [
                                            n,
                                            r
                                        ]
                                    });
                                }, a = (e1, t, n, r)=>{
                                    (i[n] && t === r || i[r] && t === n) && this.raise(Pt.IncompatibleModifiers, {
                                        at: e1,
                                        modifiers: [
                                            n,
                                            r
                                        ]
                                    });
                                };
                                for(;;){
                                    const { startLoc: o } = this.state, l = this.tsParseModifier(e1.concat(null != t ? t : []), n);
                                    if (!l) break;
                                    xt(l) ? i.accessibility ? this.raise(Pt.DuplicateAccessibilityModifier, {
                                        at: o,
                                        modifier: l
                                    }) : (s(o, l, l, "override"), s(o, l, l, "static"), s(o, l, l, "readonly"), i.accessibility = l) : Dt(l) ? (i[l] && this.raise(Pt.DuplicateModifier, {
                                        at: o,
                                        modifier: l
                                    }), i[l] = !0, s(o, l, "in", "out")) : (Object.hasOwnProperty.call(i, l) ? this.raise(Pt.DuplicateModifier, {
                                        at: o,
                                        modifier: l
                                    }) : (s(o, l, "static", "readonly"), s(o, l, "static", "override"), s(o, l, "override", "readonly"), s(o, l, "abstract", "override"), a(o, l, "declare", "override"), a(o, l, "static", "abstract")), i[l] = !0), null != t && t.includes(l) && this.raise(r, {
                                        at: o,
                                        modifier: l
                                    });
                                }
                            }
                            tsIsListTerminator(e1) {
                                switch(e1){
                                    case "EnumMembers":
                                    case "TypeMembers":
                                        return this.match(8);
                                    case "HeritageClauseElement":
                                        return this.match(5);
                                    case "TupleElementTypes":
                                        return this.match(3);
                                    case "TypeParametersOrArguments":
                                        return this.match(48);
                                }
                            }
                            tsParseList(e1, t) {
                                const n = [];
                                for(; !this.tsIsListTerminator(e1);)n.push(t());
                                return n;
                            }
                            tsParseDelimitedList(e1, t, n) {
                                return function(e1) {
                                    if (null == e1) throw new Error(`Unexpected ${e1} value.`);
                                    return e1;
                                }(this.tsParseDelimitedListWorker(e1, t, !0, n));
                            }
                            tsParseDelimitedListWorker(e1, t, n, r) {
                                const i = [];
                                let s = -1;
                                for(; !this.tsIsListTerminator(e1);){
                                    s = -1;
                                    const r = t();
                                    if (null == r) return;
                                    if (i.push(r), !this.eat(12)) {
                                        if (this.tsIsListTerminator(e1)) break;
                                        return void (n && this.expect(12));
                                    }
                                    s = this.state.lastTokStart;
                                }
                                return r && (r.value = s), i;
                            }
                            tsParseBracketedList(e1, t, n, r, i) {
                                r || (n ? this.expect(0) : this.expect(47));
                                const s = this.tsParseDelimitedList(e1, t, i);
                                return n ? this.expect(3) : this.expect(48), s;
                            }
                            tsParseImportType() {
                                const e1 = this.startNode();
                                return this.expect(83), this.expect(10), this.match(131) || this.raise(Pt.UnsupportedImportTypeArgument, {
                                    at: this.state.startLoc
                                }), e1.argument = super.parseExprAtom(), this.expect(11), this.eat(16) && (e1.qualifier = this.tsParseEntityName()), this.match(47) && (e1.typeParameters = this.tsParseTypeArguments()), this.finishNode(e1, "TSImportType");
                            }
                            tsParseEntityName(e1 = !0) {
                                let t = this.parseIdentifier(e1);
                                for(; this.eat(16);){
                                    const n = this.startNodeAtNode(t);
                                    n.left = t, n.right = this.parseIdentifier(e1), t = this.finishNode(n, "TSQualifiedName");
                                }
                                return t;
                            }
                            tsParseTypeReference() {
                                const e1 = this.startNode();
                                return e1.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e1.typeParameters = this.tsParseTypeArguments()), this.finishNode(e1, "TSTypeReference");
                            }
                            tsParseThisTypePredicate(e1) {
                                this.next();
                                const t = this.startNodeAtNode(e1);
                                return t.parameterName = e1, t.typeAnnotation = this.tsParseTypeAnnotation(!1), t.asserts = !1, this.finishNode(t, "TSTypePredicate");
                            }
                            tsParseThisTypeNode() {
                                const e1 = this.startNode();
                                return this.next(), this.finishNode(e1, "TSThisType");
                            }
                            tsParseTypeQuery() {
                                const e1 = this.startNode();
                                return this.expect(87), this.match(83) ? e1.exprName = this.tsParseImportType() : e1.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e1.typeParameters = this.tsParseTypeArguments()), this.finishNode(e1, "TSTypeQuery");
                            }
                            tsParseTypeParameter(e1) {
                                const t = this.startNode();
                                return e1(t), t.name = this.tsParseTypeParameterName(), t.constraint = this.tsEatThenParseType(81), t.default = this.tsEatThenParseType(29), this.finishNode(t, "TSTypeParameter");
                            }
                            tsTryParseTypeParameters(e1) {
                                if (this.match(47)) return this.tsParseTypeParameters(e1);
                            }
                            tsParseTypeParameters(e1) {
                                const t = this.startNode();
                                this.match(47) || this.match(140) ? this.next() : this.unexpected();
                                const n = {
                                    value: -1
                                };
                                return t.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, e1), !1, !0, n), 0 === t.params.length && this.raise(Pt.EmptyTypeParameters, {
                                    at: t
                                }), -1 !== n.value && this.addExtra(t, "trailingComma", n.value), this.finishNode(t, "TSTypeParameterDeclaration");
                            }
                            tsFillSignature(e1, t) {
                                const n = 19 === e1;
                                t.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), t.parameters = this.tsParseBindingListForSignature(), (n || this.match(e1)) && (t.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(e1));
                            }
                            tsParseBindingListForSignature() {
                                const e1 = super.parseBindingList(11, 41, 2);
                                for (const t of e1){
                                    const { type: e1 } = t;
                                    "AssignmentPattern" !== e1 && "TSParameterProperty" !== e1 || this.raise(Pt.UnsupportedSignatureParameterKind, {
                                        at: t,
                                        type: e1
                                    });
                                }
                                return e1;
                            }
                            tsParseTypeMemberSemicolon() {
                                this.eat(12) || this.isLineTerminator() || this.expect(13);
                            }
                            tsParseSignatureMember(e1, t) {
                                return this.tsFillSignature(14, t), this.tsParseTypeMemberSemicolon(), this.finishNode(t, e1);
                            }
                            tsIsUnambiguouslyIndexSignature() {
                                return this.next(), !!W(this.state.type) && (this.next(), this.match(14));
                            }
                            tsTryParseIndexSignature(e1) {
                                if (!this.match(0) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))) return;
                                this.expect(0);
                                const t = this.parseIdentifier();
                                t.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(t), this.expect(3), e1.parameters = [
                                    t
                                ];
                                const n = this.tsTryParseTypeAnnotation();
                                return n && (e1.typeAnnotation = n), this.tsParseTypeMemberSemicolon(), this.finishNode(e1, "TSIndexSignature");
                            }
                            tsParsePropertyOrMethodSignature(e1, t) {
                                this.eat(17) && (e1.optional = !0);
                                const n = e1;
                                if (this.match(10) || this.match(47)) {
                                    t && this.raise(Pt.ReadonlyForMethodSignature, {
                                        at: e1
                                    });
                                    const r = n;
                                    r.kind && this.match(47) && this.raise(Pt.AccesorCannotHaveTypeParameters, {
                                        at: this.state.curPosition()
                                    }), this.tsFillSignature(14, r), this.tsParseTypeMemberSemicolon();
                                    const i = "parameters", s = "typeAnnotation";
                                    if ("get" === r.kind) r[i].length > 0 && (this.raise(g.BadGetterArity, {
                                        at: this.state.curPosition()
                                    }), this.isThisParam(r[i][0]) && this.raise(Pt.AccesorCannotDeclareThisParameter, {
                                        at: this.state.curPosition()
                                    }));
                                    else if ("set" === r.kind) {
                                        if (1 !== r[i].length) this.raise(g.BadSetterArity, {
                                            at: this.state.curPosition()
                                        });
                                        else {
                                            const e1 = r[i][0];
                                            this.isThisParam(e1) && this.raise(Pt.AccesorCannotDeclareThisParameter, {
                                                at: this.state.curPosition()
                                            }), "Identifier" === e1.type && e1.optional && this.raise(Pt.SetAccesorCannotHaveOptionalParameter, {
                                                at: this.state.curPosition()
                                            }), "RestElement" === e1.type && this.raise(Pt.SetAccesorCannotHaveRestParameter, {
                                                at: this.state.curPosition()
                                            });
                                        }
                                        r[s] && this.raise(Pt.SetAccesorCannotHaveReturnType, {
                                            at: r[s]
                                        });
                                    } else r.kind = "method";
                                    return this.finishNode(r, "TSMethodSignature");
                                }
                                {
                                    const e1 = n;
                                    t && (e1.readonly = !0);
                                    const r = this.tsTryParseTypeAnnotation();
                                    return r && (e1.typeAnnotation = r), this.tsParseTypeMemberSemicolon(), this.finishNode(e1, "TSPropertySignature");
                                }
                            }
                            tsParseTypeMember() {
                                const e1 = this.startNode();
                                if (this.match(10) || this.match(47)) return this.tsParseSignatureMember("TSCallSignatureDeclaration", e1);
                                if (this.match(77)) {
                                    const t = this.startNode();
                                    return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e1) : (e1.key = this.createIdentifier(t, "new"), this.tsParsePropertyOrMethodSignature(e1, !1));
                                }
                                this.tsParseModifiers({
                                    allowedModifiers: [
                                        "readonly"
                                    ],
                                    disallowedModifiers: [
                                        "declare",
                                        "abstract",
                                        "private",
                                        "protected",
                                        "public",
                                        "static",
                                        "override"
                                    ]
                                }, e1);
                                return this.tsTryParseIndexSignature(e1) || (super.parsePropertyName(e1), e1.computed || "Identifier" !== e1.key.type || "get" !== e1.key.name && "set" !== e1.key.name || !this.tsTokenCanFollowModifier() || (e1.kind = e1.key.name, super.parsePropertyName(e1)), this.tsParsePropertyOrMethodSignature(e1, !!e1.readonly));
                            }
                            tsParseTypeLiteral() {
                                const e1 = this.startNode();
                                return e1.members = this.tsParseObjectTypeMembers(), this.finishNode(e1, "TSTypeLiteral");
                            }
                            tsParseObjectTypeMembers() {
                                this.expect(5);
                                const e1 = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
                                return this.expect(8), e1;
                            }
                            tsIsStartOfMappedType() {
                                return this.next(), this.eat(53) ? this.isContextual(120) : (this.isContextual(120) && this.next(), !!this.match(0) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(58))));
                            }
                            tsParseMappedTypeParameter() {
                                const e1 = this.startNode();
                                return e1.name = this.tsParseTypeParameterName(), e1.constraint = this.tsExpectThenParseType(58), this.finishNode(e1, "TSTypeParameter");
                            }
                            tsParseMappedType() {
                                const e1 = this.startNode();
                                return this.expect(5), this.match(53) ? (e1.readonly = this.state.value, this.next(), this.expectContextual(120)) : this.eatContextual(120) && (e1.readonly = !0), this.expect(0), e1.typeParameter = this.tsParseMappedTypeParameter(), e1.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (e1.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (e1.optional = !0), e1.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(e1, "TSMappedType");
                            }
                            tsParseTupleType() {
                                const e1 = this.startNode();
                                e1.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
                                let t = !1, n = null;
                                return e1.elementTypes.forEach((e1)=>{
                                    const { type: r } = e1;
                                    !t || "TSRestType" === r || "TSOptionalType" === r || "TSNamedTupleMember" === r && e1.optional || this.raise(Pt.OptionalTypeBeforeRequired, {
                                        at: e1
                                    }), t || (t = "TSNamedTupleMember" === r && e1.optional || "TSOptionalType" === r);
                                    let i = r;
                                    "TSRestType" === r && (i = (e1 = e1.typeAnnotation).type);
                                    const s = "TSNamedTupleMember" === i;
                                    null != n || (n = s), n !== s && this.raise(Pt.MixedLabeledAndUnlabeledElements, {
                                        at: e1
                                    });
                                }), this.finishNode(e1, "TSTupleType");
                            }
                            tsParseTupleElementType() {
                                const { startLoc: e1 } = this.state, t = this.eat(21);
                                let n, r, i, s;
                                const a = X(this.state.type) ? this.lookaheadCharCode() : null;
                                if (58 === a) n = !0, i = !1, r = this.parseIdentifier(!0), this.expect(14), s = this.tsParseType();
                                else if (63 === a) {
                                    i = !0;
                                    const e1 = this.state.startLoc, t = this.state.value, a = this.tsParseNonArrayType();
                                    58 === this.lookaheadCharCode() ? (n = !0, r = this.createIdentifier(this.startNodeAt(e1), t), this.expect(17), this.expect(14), s = this.tsParseType()) : (n = !1, s = a, this.expect(17));
                                } else s = this.tsParseType(), i = this.eat(17), n = this.eat(14);
                                if (n) {
                                    let e1;
                                    r ? (e1 = this.startNodeAtNode(r), e1.optional = i, e1.label = r, e1.elementType = s, this.eat(17) && (e1.optional = !0, this.raise(Pt.TupleOptionalAfterType, {
                                        at: this.state.lastTokStartLoc
                                    }))) : (e1 = this.startNodeAtNode(s), e1.optional = i, this.raise(Pt.InvalidTupleMemberLabel, {
                                        at: s
                                    }), e1.label = s, e1.elementType = this.tsParseType()), s = this.finishNode(e1, "TSNamedTupleMember");
                                } else if (i) {
                                    const e1 = this.startNodeAtNode(s);
                                    e1.typeAnnotation = s, s = this.finishNode(e1, "TSOptionalType");
                                }
                                if (t) {
                                    const t = this.startNodeAt(e1);
                                    t.typeAnnotation = s, s = this.finishNode(t, "TSRestType");
                                }
                                return s;
                            }
                            tsParseParenthesizedType() {
                                const e1 = this.startNode();
                                return this.expect(10), e1.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(e1, "TSParenthesizedType");
                            }
                            tsParseFunctionOrConstructorType(e1, t) {
                                const n = this.startNode();
                                return "TSConstructorType" === e1 && (n.abstract = !!t, t && this.next(), this.next()), this.tsInAllowConditionalTypesContext(()=>this.tsFillSignature(19, n)), this.finishNode(n, e1);
                            }
                            tsParseLiteralTypeNode() {
                                const e1 = this.startNode();
                                switch(this.state.type){
                                    case 132:
                                    case 133:
                                    case 131:
                                    case 85:
                                    case 86:
                                        e1.literal = super.parseExprAtom();
                                        break;
                                    default:
                                        this.unexpected();
                                }
                                return this.finishNode(e1, "TSLiteralType");
                            }
                            tsParseTemplateLiteralType() {
                                const e1 = this.startNode();
                                return e1.literal = super.parseTemplate(!1), this.finishNode(e1, "TSLiteralType");
                            }
                            parseTemplateSubstitution() {
                                return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
                            }
                            tsParseThisTypeOrThisTypePredicate() {
                                const e1 = this.tsParseThisTypeNode();
                                return this.isContextual(114) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e1) : e1;
                            }
                            tsParseNonArrayType() {
                                switch(this.state.type){
                                    case 131:
                                    case 132:
                                    case 133:
                                    case 85:
                                    case 86:
                                        return this.tsParseLiteralTypeNode();
                                    case 53:
                                        if ("-" === this.state.value) {
                                            const e1 = this.startNode(), t = this.lookahead();
                                            return 132 !== t.type && 133 !== t.type && this.unexpected(), e1.literal = this.parseMaybeUnary(), this.finishNode(e1, "TSLiteralType");
                                        }
                                        break;
                                    case 78:
                                        return this.tsParseThisTypeOrThisTypePredicate();
                                    case 87:
                                        return this.tsParseTypeQuery();
                                    case 83:
                                        return this.tsParseImportType();
                                    case 5:
                                        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
                                    case 0:
                                        return this.tsParseTupleType();
                                    case 10:
                                        return this.tsParseParenthesizedType();
                                    case 25:
                                    case 24:
                                        return this.tsParseTemplateLiteralType();
                                    default:
                                        {
                                            const { type: e1 } = this.state;
                                            if (W(e1) || 88 === e1 || 84 === e1) {
                                                const t = 88 === e1 ? "TSVoidKeyword" : 84 === e1 ? "TSNullKeyword" : function(e1) {
                                                    switch(e1){
                                                        case "any":
                                                            return "TSAnyKeyword";
                                                        case "boolean":
                                                            return "TSBooleanKeyword";
                                                        case "bigint":
                                                            return "TSBigIntKeyword";
                                                        case "never":
                                                            return "TSNeverKeyword";
                                                        case "number":
                                                            return "TSNumberKeyword";
                                                        case "object":
                                                            return "TSObjectKeyword";
                                                        case "string":
                                                            return "TSStringKeyword";
                                                        case "symbol":
                                                            return "TSSymbolKeyword";
                                                        case "undefined":
                                                            return "TSUndefinedKeyword";
                                                        case "unknown":
                                                            return "TSUnknownKeyword";
                                                        default:
                                                            return;
                                                    }
                                                }(this.state.value);
                                                if (void 0 !== t && 46 !== this.lookaheadCharCode()) {
                                                    const e1 = this.startNode();
                                                    return this.next(), this.finishNode(e1, t);
                                                }
                                                return this.tsParseTypeReference();
                                            }
                                        }
                                }
                                this.unexpected();
                            }
                            tsParseArrayTypeOrHigher() {
                                let e1 = this.tsParseNonArrayType();
                                for(; !this.hasPrecedingLineBreak() && this.eat(0);)if (this.match(3)) {
                                    const t = this.startNodeAtNode(e1);
                                    t.elementType = e1, this.expect(3), e1 = this.finishNode(t, "TSArrayType");
                                } else {
                                    const t = this.startNodeAtNode(e1);
                                    t.objectType = e1, t.indexType = this.tsParseType(), this.expect(3), e1 = this.finishNode(t, "TSIndexedAccessType");
                                }
                                return e1;
                            }
                            tsParseTypeOperator() {
                                const e1 = this.startNode(), t = this.state.value;
                                return this.next(), e1.operator = t, e1.typeAnnotation = this.tsParseTypeOperatorOrHigher(), "readonly" === t && this.tsCheckTypeAnnotationForReadOnly(e1), this.finishNode(e1, "TSTypeOperator");
                            }
                            tsCheckTypeAnnotationForReadOnly(e1) {
                                switch(e1.typeAnnotation.type){
                                    case "TSTupleType":
                                    case "TSArrayType":
                                        return;
                                    default:
                                        this.raise(Pt.UnexpectedReadonly, {
                                            at: e1
                                        });
                                }
                            }
                            tsParseInferType() {
                                const e1 = this.startNode();
                                this.expectContextual(113);
                                const t = this.startNode();
                                return t.name = this.tsParseTypeParameterName(), t.constraint = this.tsTryParse(()=>this.tsParseConstraintForInferType()), e1.typeParameter = this.finishNode(t, "TSTypeParameter"), this.finishNode(e1, "TSInferType");
                            }
                            tsParseConstraintForInferType() {
                                if (this.eat(81)) {
                                    const e1 = this.tsInDisallowConditionalTypesContext(()=>this.tsParseType());
                                    if (this.state.inDisallowConditionalTypesContext || !this.match(17)) return e1;
                                }
                            }
                            tsParseTypeOperatorOrHigher() {
                                var e1;
                                return (e1 = this.state.type) >= 119 && e1 <= 121 && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(113) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(()=>this.tsParseArrayTypeOrHigher());
                            }
                            tsParseUnionOrIntersectionType(e1, t, n) {
                                const r = this.startNode(), i = this.eat(n), s = [];
                                do {
                                    s.push(t());
                                }while (this.eat(n))
                                return 1 !== s.length || i ? (r.types = s, this.finishNode(r, e1)) : s[0];
                            }
                            tsParseIntersectionTypeOrHigher() {
                                return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
                            }
                            tsParseUnionTypeOrHigher() {
                                return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
                            }
                            tsIsStartOfFunctionType() {
                                return !!this.match(47) || this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
                            }
                            tsSkipParameterStart() {
                                if (W(this.state.type) || this.match(78)) return this.next(), !0;
                                if (this.match(5)) {
                                    const { errors: e1 } = this.state, t = e1.length;
                                    try {
                                        return this.parseObjectLike(8, !0), e1.length === t;
                                    } catch (e1) {
                                        return !1;
                                    }
                                }
                                if (this.match(0)) {
                                    this.next();
                                    const { errors: e1 } = this.state, t = e1.length;
                                    try {
                                        return super.parseBindingList(3, 93, 1), e1.length === t;
                                    } catch (e1) {
                                        return !1;
                                    }
                                }
                                return !1;
                            }
                            tsIsUnambiguouslyStartOfFunctionType() {
                                if (this.next(), this.match(11) || this.match(21)) return !0;
                                if (this.tsSkipParameterStart()) {
                                    if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) return !0;
                                    if (this.match(11) && (this.next(), this.match(19))) return !0;
                                }
                                return !1;
                            }
                            tsParseTypeOrTypePredicateAnnotation(e1) {
                                return this.tsInType(()=>{
                                    const t = this.startNode();
                                    this.expect(e1);
                                    const n = this.startNode(), r = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
                                    if (r && this.match(78)) {
                                        let e1 = this.tsParseThisTypeOrThisTypePredicate();
                                        return "TSThisType" === e1.type ? (n.parameterName = e1, n.asserts = !0, n.typeAnnotation = null, e1 = this.finishNode(n, "TSTypePredicate")) : (this.resetStartLocationFromNode(e1, n), e1.asserts = !0), t.typeAnnotation = e1, this.finishNode(t, "TSTypeAnnotation");
                                    }
                                    const i = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
                                    if (!i) return r ? (n.parameterName = this.parseIdentifier(), n.asserts = r, n.typeAnnotation = null, t.typeAnnotation = this.finishNode(n, "TSTypePredicate"), this.finishNode(t, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, t);
                                    const s = this.tsParseTypeAnnotation(!1);
                                    return n.parameterName = i, n.typeAnnotation = s, n.asserts = r, t.typeAnnotation = this.finishNode(n, "TSTypePredicate"), this.finishNode(t, "TSTypeAnnotation");
                                });
                            }
                            tsTryParseTypeOrTypePredicateAnnotation() {
                                if (this.match(14)) return this.tsParseTypeOrTypePredicateAnnotation(14);
                            }
                            tsTryParseTypeAnnotation() {
                                if (this.match(14)) return this.tsParseTypeAnnotation();
                            }
                            tsTryParseType() {
                                return this.tsEatThenParseType(14);
                            }
                            tsParseTypePredicatePrefix() {
                                const e1 = this.parseIdentifier();
                                if (this.isContextual(114) && !this.hasPrecedingLineBreak()) return this.next(), e1;
                            }
                            tsParseTypePredicateAsserts() {
                                if (107 !== this.state.type) return !1;
                                const e1 = this.state.containsEsc;
                                return this.next(), !(!W(this.state.type) && !this.match(78) || (e1 && this.raise(g.InvalidEscapedReservedWord, {
                                    at: this.state.lastTokStartLoc,
                                    reservedWord: "asserts"
                                }), 0));
                            }
                            tsParseTypeAnnotation(e1 = !0, t = this.startNode()) {
                                return this.tsInType(()=>{
                                    e1 && this.expect(14), t.typeAnnotation = this.tsParseType();
                                }), this.finishNode(t, "TSTypeAnnotation");
                            }
                            tsParseType() {
                                St(this.state.inType);
                                const e1 = this.tsParseNonConditionalType();
                                if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) return e1;
                                const t = this.startNodeAtNode(e1);
                                return t.checkType = e1, t.extendsType = this.tsInDisallowConditionalTypesContext(()=>this.tsParseNonConditionalType()), this.expect(17), t.trueType = this.tsInAllowConditionalTypesContext(()=>this.tsParseType()), this.expect(14), t.falseType = this.tsInAllowConditionalTypesContext(()=>this.tsParseType()), this.finishNode(t, "TSConditionalType");
                            }
                            isAbstractConstructorSignature() {
                                return this.isContextual(122) && 77 === this.lookahead().type;
                            }
                            tsParseNonConditionalType() {
                                return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
                            }
                            tsParseTypeAssertion() {
                                this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(Pt.ReservedTypeAssertion, {
                                    at: this.state.startLoc
                                });
                                const e1 = this.startNode();
                                return e1.typeAnnotation = this.tsInType(()=>(this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), e1.expression = this.parseMaybeUnary(), this.finishNode(e1, "TSTypeAssertion");
                            }
                            tsParseHeritageClause(e1) {
                                const t = this.state.startLoc, n = this.tsParseDelimitedList("HeritageClauseElement", ()=>{
                                    const e1 = this.startNode();
                                    return e1.expression = this.tsParseEntityName(), this.match(47) && (e1.typeParameters = this.tsParseTypeArguments()), this.finishNode(e1, "TSExpressionWithTypeArguments");
                                });
                                return n.length || this.raise(Pt.EmptyHeritageClauseType, {
                                    at: t,
                                    token: e1
                                }), n;
                            }
                            tsParseInterfaceDeclaration(e1, t = {}) {
                                if (this.hasFollowingLineBreak()) return null;
                                this.expectContextual(127), t.declare && (e1.declare = !0), W(this.state.type) ? (e1.id = this.parseIdentifier(), this.checkIdentifier(e1.id, 130)) : (e1.id = null, this.raise(Pt.MissingInterfaceName, {
                                    at: this.state.startLoc
                                })), e1.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (e1.extends = this.tsParseHeritageClause("extends"));
                                const n = this.startNode();
                                return n.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e1.body = this.finishNode(n, "TSInterfaceBody"), this.finishNode(e1, "TSInterfaceDeclaration");
                            }
                            tsParseTypeAliasDeclaration(e1) {
                                return e1.id = this.parseIdentifier(), this.checkIdentifier(e1.id, 2), e1.typeAnnotation = this.tsInType(()=>{
                                    if (e1.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(112) && 16 !== this.lookahead().type) {
                                        const e1 = this.startNode();
                                        return this.next(), this.finishNode(e1, "TSIntrinsicKeyword");
                                    }
                                    return this.tsParseType();
                                }), this.semicolon(), this.finishNode(e1, "TSTypeAliasDeclaration");
                            }
                            tsInNoContext(e1) {
                                const t = this.state.context;
                                this.state.context = [
                                    t[0]
                                ];
                                try {
                                    return e1();
                                } finally{
                                    this.state.context = t;
                                }
                            }
                            tsInType(e1) {
                                const t = this.state.inType;
                                this.state.inType = !0;
                                try {
                                    return e1();
                                } finally{
                                    this.state.inType = t;
                                }
                            }
                            tsInDisallowConditionalTypesContext(e1) {
                                const t = this.state.inDisallowConditionalTypesContext;
                                this.state.inDisallowConditionalTypesContext = !0;
                                try {
                                    return e1();
                                } finally{
                                    this.state.inDisallowConditionalTypesContext = t;
                                }
                            }
                            tsInAllowConditionalTypesContext(e1) {
                                const t = this.state.inDisallowConditionalTypesContext;
                                this.state.inDisallowConditionalTypesContext = !1;
                                try {
                                    return e1();
                                } finally{
                                    this.state.inDisallowConditionalTypesContext = t;
                                }
                            }
                            tsEatThenParseType(e1) {
                                if (this.match(e1)) return this.tsNextThenParseType();
                            }
                            tsExpectThenParseType(e1) {
                                return this.tsInType(()=>(this.expect(e1), this.tsParseType()));
                            }
                            tsNextThenParseType() {
                                return this.tsInType(()=>(this.next(), this.tsParseType()));
                            }
                            tsParseEnumMember() {
                                const e1 = this.startNode();
                                return e1.id = this.match(131) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (e1.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(e1, "TSEnumMember");
                            }
                            tsParseEnumDeclaration(e1, t = {}) {
                                return t.const && (e1.const = !0), t.declare && (e1.declare = !0), this.expectContextual(124), e1.id = this.parseIdentifier(), this.checkIdentifier(e1.id, e1.const ? 8971 : 8459), this.expect(5), e1.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(e1, "TSEnumDeclaration");
                            }
                            tsParseModuleBlock() {
                                const e1 = this.startNode();
                                return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(e1.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(e1, "TSModuleBlock");
                            }
                            tsParseModuleOrNamespaceDeclaration(e1, t = !1) {
                                if (e1.id = this.parseIdentifier(), t || this.checkIdentifier(e1.id, 1024), this.eat(16)) {
                                    const t = this.startNode();
                                    this.tsParseModuleOrNamespaceDeclaration(t, !0), e1.body = t;
                                } else this.scope.enter(256), this.prodParam.enter(0), e1.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
                                return this.finishNode(e1, "TSModuleDeclaration");
                            }
                            tsParseAmbientExternalModuleDeclaration(e1) {
                                return this.isContextual(110) ? (e1.global = !0, e1.id = this.parseIdentifier()) : this.match(131) ? e1.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), e1.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e1, "TSModuleDeclaration");
                            }
                            tsParseImportEqualsDeclaration(e1, t, n) {
                                e1.isExport = n || !1, e1.id = t || this.parseIdentifier(), this.checkIdentifier(e1.id, 4096), this.expect(29);
                                const r = this.tsParseModuleReference();
                                return "type" === e1.importKind && "TSExternalModuleReference" !== r.type && this.raise(Pt.ImportAliasHasImportType, {
                                    at: r
                                }), e1.moduleReference = r, this.semicolon(), this.finishNode(e1, "TSImportEqualsDeclaration");
                            }
                            tsIsExternalModuleReference() {
                                return this.isContextual(117) && 40 === this.lookaheadCharCode();
                            }
                            tsParseModuleReference() {
                                return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
                            }
                            tsParseExternalModuleReference() {
                                const e1 = this.startNode();
                                return this.expectContextual(117), this.expect(10), this.match(131) || this.unexpected(), e1.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = !0, this.finishNode(e1, "TSExternalModuleReference");
                            }
                            tsLookAhead(e1) {
                                const t = this.state.clone(), n = e1();
                                return this.state = t, n;
                            }
                            tsTryParseAndCatch(e1) {
                                const t = this.tryParse((t)=>e1() || t());
                                if (!t.aborted && t.node) return t.error && (this.state = t.failState), t.node;
                            }
                            tsTryParse(e1) {
                                const t = this.state.clone(), n = e1();
                                if (void 0 !== n && !1 !== n) return n;
                                this.state = t;
                            }
                            tsTryParseDeclare(e1) {
                                if (this.isLineTerminator()) return;
                                let t, n = this.state.type;
                                return this.isContextual(99) && (n = 74, t = "let"), this.tsInAmbientContext(()=>{
                                    switch(n){
                                        case 68:
                                            return e1.declare = !0, super.parseFunctionStatement(e1, !1, !1);
                                        case 80:
                                            return e1.declare = !0, this.parseClass(e1, !0, !1);
                                        case 124:
                                            return this.tsParseEnumDeclaration(e1, {
                                                declare: !0
                                            });
                                        case 110:
                                            return this.tsParseAmbientExternalModuleDeclaration(e1);
                                        case 75:
                                        case 74:
                                            return this.match(75) && this.isLookaheadContextual("enum") ? (this.expect(75), this.tsParseEnumDeclaration(e1, {
                                                const: !0,
                                                declare: !0
                                            })) : (e1.declare = !0, this.parseVarStatement(e1, t || this.state.value, !0));
                                        case 127:
                                            {
                                                const t = this.tsParseInterfaceDeclaration(e1, {
                                                    declare: !0
                                                });
                                                if (t) return t;
                                            }
                                        default:
                                            if (W(n)) return this.tsParseDeclaration(e1, this.state.value, !0, null);
                                    }
                                });
                            }
                            tsTryParseExportDeclaration() {
                                return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
                            }
                            tsParseExpressionStatement(e1, t, n) {
                                switch(t.name){
                                    case "declare":
                                        {
                                            const t = this.tsTryParseDeclare(e1);
                                            return t && (t.declare = !0), t;
                                        }
                                    case "global":
                                        if (this.match(5)) {
                                            this.scope.enter(256), this.prodParam.enter(0);
                                            const n = e1;
                                            return n.global = !0, n.id = t, n.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(n, "TSModuleDeclaration");
                                        }
                                        break;
                                    default:
                                        return this.tsParseDeclaration(e1, t.name, !1, n);
                                }
                            }
                            tsParseDeclaration(e1, t, n, r) {
                                switch(t){
                                    case "abstract":
                                        if (this.tsCheckLineTerminator(n) && (this.match(80) || W(this.state.type))) return this.tsParseAbstractDeclaration(e1, r);
                                        break;
                                    case "module":
                                        if (this.tsCheckLineTerminator(n)) {
                                            if (this.match(131)) return this.tsParseAmbientExternalModuleDeclaration(e1);
                                            if (W(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(e1);
                                        }
                                        break;
                                    case "namespace":
                                        if (this.tsCheckLineTerminator(n) && W(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(e1);
                                        break;
                                    case "type":
                                        if (this.tsCheckLineTerminator(n) && W(this.state.type)) return this.tsParseTypeAliasDeclaration(e1);
                                }
                            }
                            tsCheckLineTerminator(e1) {
                                return e1 ? !this.hasFollowingLineBreak() && (this.next(), !0) : !this.isLineTerminator();
                            }
                            tsTryParseGenericAsyncArrowFunction(e1) {
                                if (!this.match(47)) return;
                                const t = this.state.maybeInArrowParameters;
                                this.state.maybeInArrowParameters = !0;
                                const n = this.tsTryParseAndCatch(()=>{
                                    const t = this.startNodeAt(e1);
                                    return t.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(t), t.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), t;
                                });
                                return this.state.maybeInArrowParameters = t, n ? super.parseArrowExpression(n, null, !0) : void 0;
                            }
                            tsParseTypeArgumentsInExpression() {
                                if (47 === this.reScan_lt()) return this.tsParseTypeArguments();
                            }
                            tsParseTypeArguments() {
                                const e1 = this.startNode();
                                return e1.params = this.tsInType(()=>this.tsInNoContext(()=>(this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), 0 === e1.params.length ? this.raise(Pt.EmptyTypeArguments, {
                                    at: e1
                                }) : this.state.inType || this.curContext() !== x.brace || this.reScan_lt_gt(), this.expect(48), this.finishNode(e1, "TSTypeParameterInstantiation");
                            }
                            tsIsDeclarationStart() {
                                return (e1 = this.state.type) >= 122 && e1 <= 128;
                                "TURBOPACK unreachable";
                                var e1;
                            }
                            isExportDefaultSpecifier() {
                                return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
                            }
                            parseAssignableListItem(e1, t) {
                                const n = this.state.startLoc, r = {};
                                this.tsParseModifiers({
                                    allowedModifiers: [
                                        "public",
                                        "private",
                                        "protected",
                                        "override",
                                        "readonly"
                                    ]
                                }, r);
                                const i = r.accessibility, s = r.override, a = r.readonly;
                                4 & e1 || !(i || a || s) || this.raise(Pt.UnexpectedParameterModifier, {
                                    at: n
                                });
                                const o = this.parseMaybeDefault();
                                this.parseAssignableListItemTypes(o, e1);
                                const l = this.parseMaybeDefault(o.loc.start, o);
                                if (i || a || s) {
                                    const e1 = this.startNodeAt(n);
                                    return t.length && (e1.decorators = t), i && (e1.accessibility = i), a && (e1.readonly = a), s && (e1.override = s), "Identifier" !== l.type && "AssignmentPattern" !== l.type && this.raise(Pt.UnsupportedParameterPropertyKind, {
                                        at: e1
                                    }), e1.parameter = l, this.finishNode(e1, "TSParameterProperty");
                                }
                                return t.length && (o.decorators = t), l;
                            }
                            isSimpleParameter(e1) {
                                return "TSParameterProperty" === e1.type && super.isSimpleParameter(e1.parameter) || super.isSimpleParameter(e1);
                            }
                            tsDisallowOptionalPattern(e1) {
                                for (const t of e1.params)"Identifier" !== t.type && t.optional && !this.state.isAmbientContext && this.raise(Pt.PatternIsOptional, {
                                    at: t
                                });
                            }
                            setArrowFunctionParameters(e1, t, n) {
                                super.setArrowFunctionParameters(e1, t, n), this.tsDisallowOptionalPattern(e1);
                            }
                            parseFunctionBodyAndFinish(e1, t, n = !1) {
                                this.match(14) && (e1.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
                                const r = "FunctionDeclaration" === t ? "TSDeclareFunction" : "ClassMethod" === t || "ClassPrivateMethod" === t ? "TSDeclareMethod" : void 0;
                                return r && !this.match(5) && this.isLineTerminator() ? this.finishNode(e1, r) : "TSDeclareFunction" === r && this.state.isAmbientContext && (this.raise(Pt.DeclareFunctionHasImplementation, {
                                    at: e1
                                }), e1.declare) ? super.parseFunctionBodyAndFinish(e1, r, n) : (this.tsDisallowOptionalPattern(e1), super.parseFunctionBodyAndFinish(e1, t, n));
                            }
                            registerFunctionStatementId(e1) {
                                !e1.body && e1.id ? this.checkIdentifier(e1.id, 1024) : super.registerFunctionStatementId(e1);
                            }
                            tsCheckForInvalidTypeCasts(e1) {
                                e1.forEach((e1)=>{
                                    "TSTypeCastExpression" === (null == e1 ? void 0 : e1.type) && this.raise(Pt.UnexpectedTypeAnnotation, {
                                        at: e1.typeAnnotation
                                    });
                                });
                            }
                            toReferencedList(e1, t) {
                                return this.tsCheckForInvalidTypeCasts(e1), e1;
                            }
                            parseArrayLike(e1, t, n, r) {
                                const i = super.parseArrayLike(e1, t, n, r);
                                return "ArrayExpression" === i.type && this.tsCheckForInvalidTypeCasts(i.elements), i;
                            }
                            parseSubscript(e1, t, n, r) {
                                if (!this.hasPrecedingLineBreak() && this.match(35)) {
                                    this.state.canStartJSXElement = !1, this.next();
                                    const n = this.startNodeAt(t);
                                    return n.expression = e1, this.finishNode(n, "TSNonNullExpression");
                                }
                                let i = !1;
                                if (this.match(18) && 60 === this.lookaheadCharCode()) {
                                    if (n) return r.stop = !0, e1;
                                    r.optionalChainMember = i = !0, this.next();
                                }
                                if (this.match(47) || this.match(51)) {
                                    let s;
                                    const a = this.tsTryParseAndCatch(()=>{
                                        if (!n && this.atPossibleAsyncArrow(e1)) {
                                            const e1 = this.tsTryParseGenericAsyncArrowFunction(t);
                                            if (e1) return e1;
                                        }
                                        const a = this.tsParseTypeArgumentsInExpression();
                                        if (!a) return;
                                        if (i && !this.match(10)) return void (s = this.state.curPosition());
                                        if (z(this.state.type)) {
                                            const n = super.parseTaggedTemplateExpression(e1, t, r);
                                            return n.typeParameters = a, n;
                                        }
                                        if (!n && this.eat(10)) {
                                            const n = this.startNodeAt(t);
                                            return n.callee = e1, n.arguments = this.parseCallExpressionArguments(11, !1), this.tsCheckForInvalidTypeCasts(n.arguments), n.typeParameters = a, r.optionalChainMember && (n.optional = i), this.finishCallExpression(n, r.optionalChainMember);
                                        }
                                        const o = this.state.type;
                                        if (48 === o || 52 === o || 10 !== o && q(o) && !this.hasPrecedingLineBreak()) return;
                                        const l = this.startNodeAt(t);
                                        return l.expression = e1, l.typeParameters = a, this.finishNode(l, "TSInstantiationExpression");
                                    });
                                    if (s && this.unexpected(s, 10), a) return "TSInstantiationExpression" === a.type && (this.match(16) || this.match(18) && 40 !== this.lookaheadCharCode()) && this.raise(Pt.InvalidPropertyAccessAfterInstantiationExpression, {
                                        at: this.state.startLoc
                                    }), a;
                                }
                                return super.parseSubscript(e1, t, n, r);
                            }
                            parseNewCallee(e1) {
                                var t;
                                super.parseNewCallee(e1);
                                const { callee: n } = e1;
                                "TSInstantiationExpression" !== n.type || null != (t = n.extra) && t.parenthesized || (e1.typeParameters = n.typeParameters, e1.callee = n.expression);
                            }
                            parseExprOp(e1, t, n) {
                                let r;
                                if (G(58) > n && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (r = this.isContextual(118)))) {
                                    const i = this.startNodeAt(t);
                                    return i.expression = e1, i.typeAnnotation = this.tsInType(()=>(this.next(), this.match(75) ? (r && this.raise(g.UnexpectedKeyword, {
                                            at: this.state.startLoc,
                                            keyword: "const"
                                        }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(i, r ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(i, t, n);
                                }
                                return super.parseExprOp(e1, t, n);
                            }
                            checkReservedWord(e1, t, n, r) {
                                this.state.isAmbientContext || super.checkReservedWord(e1, t, n, r);
                            }
                            checkImportReflection(e1) {
                                super.checkImportReflection(e1), e1.module && "value" !== e1.importKind && this.raise(Pt.ImportReflectionHasImportType, {
                                    at: e1.specifiers[0].loc.start
                                });
                            }
                            checkDuplicateExports() {}
                            isPotentialImportPhase(e1) {
                                if (super.isPotentialImportPhase(e1)) return !0;
                                if (this.isContextual(128)) {
                                    const t = this.lookaheadCharCode();
                                    return e1 ? 123 === t || 42 === t : 61 !== t;
                                }
                                return !e1 && this.isContextual(87);
                            }
                            applyImportPhase(e1, t, n, r) {
                                super.applyImportPhase(e1, t, n, r), t ? e1.exportKind = "type" === n ? "type" : "value" : e1.importKind = "type" === n || "typeof" === n ? n : "value";
                            }
                            parseImport(e1) {
                                if (this.match(131)) return e1.importKind = "value", super.parseImport(e1);
                                let t;
                                if (W(this.state.type) && 61 === this.lookaheadCharCode()) return e1.importKind = "value", this.tsParseImportEqualsDeclaration(e1);
                                if (this.isContextual(128)) {
                                    const n = this.parseMaybeImportPhase(e1, !1);
                                    if (61 === this.lookaheadCharCode()) return this.tsParseImportEqualsDeclaration(e1, n);
                                    t = super.parseImportSpecifiersAndAfter(e1, n);
                                } else t = super.parseImport(e1);
                                return "type" === t.importKind && t.specifiers.length > 1 && "ImportDefaultSpecifier" === t.specifiers[0].type && this.raise(Pt.TypeImportCannotSpecifyDefaultAndNamed, {
                                    at: t
                                }), t;
                            }
                            parseExport(e1, t) {
                                if (this.match(83)) {
                                    this.next();
                                    let t = null;
                                    return this.isContextual(128) && this.isPotentialImportPhase(!1) ? t = this.parseMaybeImportPhase(e1, !1) : e1.importKind = "value", this.tsParseImportEqualsDeclaration(e1, t, !0);
                                }
                                if (this.eat(29)) {
                                    const t = e1;
                                    return t.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(t, "TSExportAssignment");
                                }
                                if (this.eatContextual(93)) {
                                    const t = e1;
                                    return this.expectContextual(126), t.id = this.parseIdentifier(), this.semicolon(), this.finishNode(t, "TSNamespaceExportDeclaration");
                                }
                                return super.parseExport(e1, t);
                            }
                            isAbstractClass() {
                                return this.isContextual(122) && 80 === this.lookahead().type;
                            }
                            parseExportDefaultExpression() {
                                if (this.isAbstractClass()) {
                                    const e1 = this.startNode();
                                    return this.next(), e1.abstract = !0, this.parseClass(e1, !0, !0);
                                }
                                if (this.match(127)) {
                                    const e1 = this.tsParseInterfaceDeclaration(this.startNode());
                                    if (e1) return e1;
                                }
                                return super.parseExportDefaultExpression();
                            }
                            parseVarStatement(e1, t, n = !1) {
                                const { isAmbientContext: r } = this.state, i = super.parseVarStatement(e1, t, n || r);
                                if (!r) return i;
                                for (const { id: e1, init: n } of i.declarations)n && ("const" !== t || e1.typeAnnotation ? this.raise(Pt.InitializerNotAllowedInAmbientContext, {
                                    at: n
                                }) : vt(n, this.hasPlugin("estree")) || this.raise(Pt.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {
                                    at: n
                                }));
                                return i;
                            }
                            parseStatementContent(e1, t) {
                                if (this.match(75) && this.isLookaheadContextual("enum")) {
                                    const e1 = this.startNode();
                                    return this.expect(75), this.tsParseEnumDeclaration(e1, {
                                        const: !0
                                    });
                                }
                                if (this.isContextual(124)) return this.tsParseEnumDeclaration(this.startNode());
                                if (this.isContextual(127)) {
                                    const e1 = this.tsParseInterfaceDeclaration(this.startNode());
                                    if (e1) return e1;
                                }
                                return super.parseStatementContent(e1, t);
                            }
                            parseAccessModifier() {
                                return this.tsParseModifier([
                                    "public",
                                    "protected",
                                    "private"
                                ]);
                            }
                            tsHasSomeModifiers(e1, t) {
                                return t.some((t)=>xt(t) ? e1.accessibility === t : !!e1[t]);
                            }
                            tsIsStartOfStaticBlocks() {
                                return this.isContextual(104) && 123 === this.lookaheadCharCode();
                            }
                            parseClassMember(e1, t, n) {
                                const r = [
                                    "declare",
                                    "private",
                                    "public",
                                    "protected",
                                    "override",
                                    "abstract",
                                    "readonly",
                                    "static"
                                ];
                                this.tsParseModifiers({
                                    allowedModifiers: r,
                                    disallowedModifiers: [
                                        "in",
                                        "out"
                                    ],
                                    stopOnStartOfClassStaticBlock: !0,
                                    errorTemplate: Pt.InvalidModifierOnTypeParameterPositions
                                }, t);
                                const i = ()=>{
                                    this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(t, r) && this.raise(Pt.StaticBlockCannotHaveModifier, {
                                        at: this.state.curPosition()
                                    }), super.parseClassStaticBlock(e1, t)) : this.parseClassMemberWithIsStatic(e1, t, n, !!t.static);
                                };
                                t.declare ? this.tsInAmbientContext(i) : i();
                            }
                            parseClassMemberWithIsStatic(e1, t, n, r) {
                                const i = this.tsTryParseIndexSignature(t);
                                if (i) return e1.body.push(i), t.abstract && this.raise(Pt.IndexSignatureHasAbstract, {
                                    at: t
                                }), t.accessibility && this.raise(Pt.IndexSignatureHasAccessibility, {
                                    at: t,
                                    modifier: t.accessibility
                                }), t.declare && this.raise(Pt.IndexSignatureHasDeclare, {
                                    at: t
                                }), void (t.override && this.raise(Pt.IndexSignatureHasOverride, {
                                    at: t
                                }));
                                !this.state.inAbstractClass && t.abstract && this.raise(Pt.NonAbstractClassHasAbstractMethod, {
                                    at: t
                                }), t.override && (n.hadSuperClass || this.raise(Pt.OverrideNotInSubClass, {
                                    at: t
                                })), super.parseClassMemberWithIsStatic(e1, t, n, r);
                            }
                            parsePostMemberNameModifiers(e1) {
                                this.eat(17) && (e1.optional = !0), e1.readonly && this.match(10) && this.raise(Pt.ClassMethodHasReadonly, {
                                    at: e1
                                }), e1.declare && this.match(10) && this.raise(Pt.ClassMethodHasDeclare, {
                                    at: e1
                                });
                            }
                            parseExpressionStatement(e1, t, n) {
                                return ("Identifier" === t.type ? this.tsParseExpressionStatement(e1, t, n) : void 0) || super.parseExpressionStatement(e1, t, n);
                            }
                            shouldParseExportDeclaration() {
                                return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
                            }
                            parseConditional(e1, t, n) {
                                if (!this.state.maybeInArrowParameters || !this.match(17)) return super.parseConditional(e1, t, n);
                                const r = this.tryParse(()=>super.parseConditional(e1, t));
                                return r.node ? (r.error && (this.state = r.failState), r.node) : (r.error && super.setOptionalParametersError(n, r.error), e1);
                            }
                            parseParenItem(e1, t) {
                                if (e1 = super.parseParenItem(e1, t), this.eat(17) && (e1.optional = !0, this.resetEndLocation(e1)), this.match(14)) {
                                    const n = this.startNodeAt(t);
                                    return n.expression = e1, n.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(n, "TSTypeCastExpression");
                                }
                                return e1;
                            }
                            parseExportDeclaration(e1) {
                                if (!this.state.isAmbientContext && this.isContextual(123)) return this.tsInAmbientContext(()=>this.parseExportDeclaration(e1));
                                const t = this.state.startLoc, n = this.eatContextual(123);
                                if (n && (this.isContextual(123) || !this.shouldParseExportDeclaration())) throw this.raise(Pt.ExpectedAmbientAfterExportDeclare, {
                                    at: this.state.startLoc
                                });
                                const r = W(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(e1);
                                return r ? (("TSInterfaceDeclaration" === r.type || "TSTypeAliasDeclaration" === r.type || n) && (e1.exportKind = "type"), n && (this.resetStartLocation(r, t), r.declare = !0), r) : null;
                            }
                            parseClassId(e1, t, n, r) {
                                if ((!t || n) && this.isContextual(111)) return;
                                super.parseClassId(e1, t, n, e1.declare ? 1024 : 8331);
                                const i = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
                                i && (e1.typeParameters = i);
                            }
                            parseClassPropertyAnnotation(e1) {
                                e1.optional || (this.eat(35) ? e1.definite = !0 : this.eat(17) && (e1.optional = !0));
                                const t = this.tsTryParseTypeAnnotation();
                                t && (e1.typeAnnotation = t);
                            }
                            parseClassProperty(e1) {
                                if (this.parseClassPropertyAnnotation(e1), this.state.isAmbientContext && (!e1.readonly || e1.typeAnnotation) && this.match(29) && this.raise(Pt.DeclareClassFieldHasInitializer, {
                                    at: this.state.startLoc
                                }), e1.abstract && this.match(29)) {
                                    const { key: t } = e1;
                                    this.raise(Pt.AbstractPropertyHasInitializer, {
                                        at: this.state.startLoc,
                                        propertyName: "Identifier" !== t.type || e1.computed ? `[${this.input.slice(t.start, t.end)}]` : t.name
                                    });
                                }
                                return super.parseClassProperty(e1);
                            }
                            parseClassPrivateProperty(e1) {
                                return e1.abstract && this.raise(Pt.PrivateElementHasAbstract, {
                                    at: e1
                                }), e1.accessibility && this.raise(Pt.PrivateElementHasAccessibility, {
                                    at: e1,
                                    modifier: e1.accessibility
                                }), this.parseClassPropertyAnnotation(e1), super.parseClassPrivateProperty(e1);
                            }
                            parseClassAccessorProperty(e1) {
                                return this.parseClassPropertyAnnotation(e1), e1.optional && this.raise(Pt.AccessorCannotBeOptional, {
                                    at: e1
                                }), super.parseClassAccessorProperty(e1);
                            }
                            pushClassMethod(e1, t, n, r, i, s) {
                                const a = this.tsTryParseTypeParameters(this.tsParseConstModifier);
                                a && i && this.raise(Pt.ConstructorHasTypeParameters, {
                                    at: a
                                });
                                const { declare: o = !1, kind: l } = t;
                                !o || "get" !== l && "set" !== l || this.raise(Pt.DeclareAccessor, {
                                    at: t,
                                    kind: l
                                }), a && (t.typeParameters = a), super.pushClassMethod(e1, t, n, r, i, s);
                            }
                            pushClassPrivateMethod(e1, t, n, r) {
                                const i = this.tsTryParseTypeParameters(this.tsParseConstModifier);
                                i && (t.typeParameters = i), super.pushClassPrivateMethod(e1, t, n, r);
                            }
                            declareClassPrivateMethodInScope(e1, t) {
                                "TSDeclareMethod" !== e1.type && ("MethodDefinition" !== e1.type || e1.value.body) && super.declareClassPrivateMethodInScope(e1, t);
                            }
                            parseClassSuper(e1) {
                                super.parseClassSuper(e1), e1.superClass && (this.match(47) || this.match(51)) && (e1.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(111) && (e1.implements = this.tsParseHeritageClause("implements"));
                            }
                            parseObjPropValue(e1, t, n, r, i, s, a) {
                                const o = this.tsTryParseTypeParameters(this.tsParseConstModifier);
                                return o && (e1.typeParameters = o), super.parseObjPropValue(e1, t, n, r, i, s, a);
                            }
                            parseFunctionParams(e1, t) {
                                const n = this.tsTryParseTypeParameters(this.tsParseConstModifier);
                                n && (e1.typeParameters = n), super.parseFunctionParams(e1, t);
                            }
                            parseVarId(e1, t) {
                                super.parseVarId(e1, t), "Identifier" === e1.id.type && !this.hasPrecedingLineBreak() && this.eat(35) && (e1.definite = !0);
                                const n = this.tsTryParseTypeAnnotation();
                                n && (e1.id.typeAnnotation = n, this.resetEndLocation(e1.id));
                            }
                            parseAsyncArrowFromCallExpression(e1, t) {
                                return this.match(14) && (e1.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e1, t);
                            }
                            parseMaybeAssign(e1, t) {
                                var n, r, i, s, a;
                                let o, l, c, u;
                                if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
                                    if (o = this.state.clone(), l = this.tryParse(()=>super.parseMaybeAssign(e1, t), o), !l.error) return l.node;
                                    const { context: n } = this.state, r = n[n.length - 1];
                                    r !== x.j_oTag && r !== x.j_expr || n.pop();
                                }
                                if (!(null != (n = l) && n.error || this.match(47))) return super.parseMaybeAssign(e1, t);
                                o && o !== this.state || (o = this.state.clone());
                                const p = this.tryParse((n)=>{
                                    var r, i;
                                    u = this.tsParseTypeParameters(this.tsParseConstModifier);
                                    const s = super.parseMaybeAssign(e1, t);
                                    return ("ArrowFunctionExpression" !== s.type || null != (r = s.extra) && r.parenthesized) && n(), 0 !== (null == (i = u) ? void 0 : i.params.length) && this.resetStartLocationFromNode(s, u), s.typeParameters = u, s;
                                }, o);
                                if (!p.error && !p.aborted) return u && this.reportReservedArrowTypeParam(u), p.node;
                                if (!l && (St(!this.hasPlugin("jsx")), c = this.tryParse(()=>super.parseMaybeAssign(e1, t), o), !c.error)) return c.node;
                                if (null != (r = l) && r.node) return this.state = l.failState, l.node;
                                if (p.node) return this.state = p.failState, u && this.reportReservedArrowTypeParam(u), p.node;
                                if (null != (i = c) && i.node) return this.state = c.failState, c.node;
                                throw (null == (s = l) ? void 0 : s.error) || p.error || (null == (a = c) ? void 0 : a.error);
                            }
                            reportReservedArrowTypeParam(e1) {
                                var t;
                                1 !== e1.params.length || e1.params[0].constraint || null != (t = e1.extra) && t.trailingComma || !this.getPluginOption("typescript", "disallowAmbiguousJSXLike") || this.raise(Pt.ReservedArrowTypeParam, {
                                    at: e1
                                });
                            }
                            parseMaybeUnary(e1, t) {
                                return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e1, t);
                            }
                            parseArrow(e1) {
                                if (this.match(14)) {
                                    const t = this.tryParse((e1)=>{
                                        const t = this.tsParseTypeOrTypePredicateAnnotation(14);
                                        return !this.canInsertSemicolon() && this.match(19) || e1(), t;
                                    });
                                    if (t.aborted) return;
                                    t.thrown || (t.error && (this.state = t.failState), e1.returnType = t.node);
                                }
                                return super.parseArrow(e1);
                            }
                            parseAssignableListItemTypes(e1, t) {
                                if (!(2 & t)) return e1;
                                this.eat(17) && (e1.optional = !0);
                                const n = this.tsTryParseTypeAnnotation();
                                return n && (e1.typeAnnotation = n), this.resetEndLocation(e1), e1;
                            }
                            isAssignable(e1, t) {
                                switch(e1.type){
                                    case "TSTypeCastExpression":
                                        return this.isAssignable(e1.expression, t);
                                    case "TSParameterProperty":
                                        return !0;
                                    default:
                                        return super.isAssignable(e1, t);
                                }
                            }
                            toAssignable(e1, t = !1) {
                                switch(e1.type){
                                    case "ParenthesizedExpression":
                                        this.toAssignableParenthesizedExpression(e1, t);
                                        break;
                                    case "TSAsExpression":
                                    case "TSSatisfiesExpression":
                                    case "TSNonNullExpression":
                                    case "TSTypeAssertion":
                                        t ? this.expressionScope.recordArrowParameterBindingError(Pt.UnexpectedTypeCastInParameter, {
                                            at: e1
                                        }) : this.raise(Pt.UnexpectedTypeCastInParameter, {
                                            at: e1
                                        }), this.toAssignable(e1.expression, t);
                                        break;
                                    case "AssignmentExpression":
                                        t || "TSTypeCastExpression" !== e1.left.type || (e1.left = this.typeCastToParameter(e1.left));
                                    default:
                                        super.toAssignable(e1, t);
                                }
                            }
                            toAssignableParenthesizedExpression(e1, t) {
                                switch(e1.expression.type){
                                    case "TSAsExpression":
                                    case "TSSatisfiesExpression":
                                    case "TSNonNullExpression":
                                    case "TSTypeAssertion":
                                    case "ParenthesizedExpression":
                                        this.toAssignable(e1.expression, t);
                                        break;
                                    default:
                                        super.toAssignable(e1, t);
                                }
                            }
                            checkToRestConversion(e1, t) {
                                switch(e1.type){
                                    case "TSAsExpression":
                                    case "TSSatisfiesExpression":
                                    case "TSTypeAssertion":
                                    case "TSNonNullExpression":
                                        this.checkToRestConversion(e1.expression, !1);
                                        break;
                                    default:
                                        super.checkToRestConversion(e1, t);
                                }
                            }
                            isValidLVal(e1, t, n) {
                                return r = {
                                    TSTypeCastExpression: !0,
                                    TSParameterProperty: "parameter",
                                    TSNonNullExpression: "expression",
                                    TSAsExpression: (64 !== n || !t) && [
                                        "expression",
                                        !0
                                    ],
                                    TSSatisfiesExpression: (64 !== n || !t) && [
                                        "expression",
                                        !0
                                    ],
                                    TSTypeAssertion: (64 !== n || !t) && [
                                        "expression",
                                        !0
                                    ]
                                }, i = e1, Object.hasOwnProperty.call(r, i) && r[i] || super.isValidLVal(e1, t, n);
                                "TURBOPACK unreachable";
                                var r, i;
                            }
                            parseBindingAtom() {
                                return 78 === this.state.type ? this.parseIdentifier(!0) : super.parseBindingAtom();
                            }
                            parseMaybeDecoratorArguments(e1) {
                                if (this.match(47) || this.match(51)) {
                                    const t = this.tsParseTypeArgumentsInExpression();
                                    if (this.match(10)) {
                                        const n = super.parseMaybeDecoratorArguments(e1);
                                        return n.typeParameters = t, n;
                                    }
                                    this.unexpected(null, 10);
                                }
                                return super.parseMaybeDecoratorArguments(e1);
                            }
                            checkCommaAfterRest(e1) {
                                return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e1 ? (this.next(), !1) : super.checkCommaAfterRest(e1);
                            }
                            isClassMethod() {
                                return this.match(47) || super.isClassMethod();
                            }
                            isClassProperty() {
                                return this.match(35) || this.match(14) || super.isClassProperty();
                            }
                            parseMaybeDefault(e1, t) {
                                const n = super.parseMaybeDefault(e1, t);
                                return "AssignmentPattern" === n.type && n.typeAnnotation && n.right.start < n.typeAnnotation.start && this.raise(Pt.TypeAnnotationAfterAssign, {
                                    at: n.typeAnnotation
                                }), n;
                            }
                            getTokenFromCode(e1) {
                                if (this.state.inType) {
                                    if (62 === e1) return void this.finishOp(48, 1);
                                    if (60 === e1) return void this.finishOp(47, 1);
                                }
                                super.getTokenFromCode(e1);
                            }
                            reScan_lt_gt() {
                                const { type: e1 } = this.state;
                                47 === e1 ? (this.state.pos -= 1, this.readToken_lt()) : 48 === e1 && (this.state.pos -= 1, this.readToken_gt());
                            }
                            reScan_lt() {
                                const { type: e1 } = this.state;
                                return 51 === e1 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : e1;
                            }
                            toAssignableList(e1, t, n) {
                                for(let t = 0; t < e1.length; t++){
                                    const n = e1[t];
                                    "TSTypeCastExpression" === (null == n ? void 0 : n.type) && (e1[t] = this.typeCastToParameter(n));
                                }
                                super.toAssignableList(e1, t, n);
                            }
                            typeCastToParameter(e1) {
                                return e1.expression.typeAnnotation = e1.typeAnnotation, this.resetEndLocation(e1.expression, e1.typeAnnotation.loc.end), e1.expression;
                            }
                            shouldParseArrow(e1) {
                                return this.match(14) ? e1.every((e1)=>this.isAssignable(e1, !0)) : super.shouldParseArrow(e1);
                            }
                            shouldParseAsyncArrow() {
                                return this.match(14) || super.shouldParseAsyncArrow();
                            }
                            canHaveLeadingDecorator() {
                                return super.canHaveLeadingDecorator() || this.isAbstractClass();
                            }
                            jsxParseOpeningElementAfterName(e1) {
                                if (this.match(47) || this.match(51)) {
                                    const t = this.tsTryParseAndCatch(()=>this.tsParseTypeArgumentsInExpression());
                                    t && (e1.typeParameters = t);
                                }
                                return super.jsxParseOpeningElementAfterName(e1);
                            }
                            getGetterSetterExpectedParamCount(e1) {
                                const t = super.getGetterSetterExpectedParamCount(e1), n = this.getObjectOrClassMethodParams(e1)[0];
                                return n && this.isThisParam(n) ? t + 1 : t;
                            }
                            parseCatchClauseParam() {
                                const e1 = super.parseCatchClauseParam(), t = this.tsTryParseTypeAnnotation();
                                return t && (e1.typeAnnotation = t, this.resetEndLocation(e1)), e1;
                            }
                            tsInAmbientContext(e1) {
                                const t = this.state.isAmbientContext;
                                this.state.isAmbientContext = !0;
                                try {
                                    return e1();
                                } finally{
                                    this.state.isAmbientContext = t;
                                }
                            }
                            parseClass(e1, t, n) {
                                const r = this.state.inAbstractClass;
                                this.state.inAbstractClass = !!e1.abstract;
                                try {
                                    return super.parseClass(e1, t, n);
                                } finally{
                                    this.state.inAbstractClass = r;
                                }
                            }
                            tsParseAbstractDeclaration(e1, t) {
                                if (this.match(80)) return e1.abstract = !0, this.maybeTakeDecorators(t, this.parseClass(e1, !0, !1));
                                if (this.isContextual(127)) {
                                    if (!this.hasFollowingLineBreak()) return e1.abstract = !0, this.raise(Pt.NonClassMethodPropertyHasAbstractModifer, {
                                        at: e1
                                    }), this.tsParseInterfaceDeclaration(e1);
                                } else this.unexpected(null, 80);
                            }
                            parseMethod(e1, t, n, r, i, s, a) {
                                const o = super.parseMethod(e1, t, n, r, i, s, a);
                                if (o.abstract && (this.hasPlugin("estree") ? o.value.body : o.body)) {
                                    const { key: e1 } = o;
                                    this.raise(Pt.AbstractMethodHasImplementation, {
                                        at: o,
                                        methodName: "Identifier" !== e1.type || o.computed ? `[${this.input.slice(e1.start, e1.end)}]` : e1.name
                                    });
                                }
                                return o;
                            }
                            tsParseTypeParameterName() {
                                return this.parseIdentifier().name;
                            }
                            shouldParseAsAmbientContext() {
                                return !!this.getPluginOption("typescript", "dts");
                            }
                            parse() {
                                return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
                            }
                            getExpression() {
                                return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
                            }
                            parseExportSpecifier(e1, t, n, r) {
                                return !t && r ? (this.parseTypeOnlyImportExportSpecifier(e1, !1, n), this.finishNode(e1, "ExportSpecifier")) : (e1.exportKind = "value", super.parseExportSpecifier(e1, t, n, r));
                            }
                            parseImportSpecifier(e1, t, n, r, i) {
                                return !t && r ? (this.parseTypeOnlyImportExportSpecifier(e1, !0, n), this.finishNode(e1, "ImportSpecifier")) : (e1.importKind = "value", super.parseImportSpecifier(e1, t, n, r, n ? 4098 : 4096));
                            }
                            parseTypeOnlyImportExportSpecifier(e1, t, n) {
                                const r = t ? "imported" : "local", i = t ? "local" : "exported";
                                let s, a = e1[r], o = !1, l = !0;
                                const c = a.loc.start;
                                if (this.isContextual(93)) {
                                    const e1 = this.parseIdentifier();
                                    if (this.isContextual(93)) {
                                        const n = this.parseIdentifier();
                                        X(this.state.type) ? (o = !0, a = e1, s = t ? this.parseIdentifier() : this.parseModuleExportName(), l = !1) : (s = n, l = !1);
                                    } else X(this.state.type) ? (l = !1, s = t ? this.parseIdentifier() : this.parseModuleExportName()) : (o = !0, a = e1);
                                } else X(this.state.type) && (o = !0, t ? (a = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(a.name, a.loc.start, !0, !0)) : a = this.parseModuleExportName());
                                o && n && this.raise(t ? Pt.TypeModifierIsUsedInTypeImports : Pt.TypeModifierIsUsedInTypeExports, {
                                    at: c
                                }), e1[r] = a, e1[i] = s, e1[t ? "importKind" : "exportKind"] = o ? "type" : "value", l && this.eatContextual(93) && (e1[i] = t ? this.parseIdentifier() : this.parseModuleExportName()), e1[i] || (e1[i] = at(e1[r])), t && this.checkIdentifier(e1[i], o ? 4098 : 4096);
                            }
                        },
                    v8intrinsic: (e1)=>class extends e1 {
                            parseV8Intrinsic() {
                                if (this.match(54)) {
                                    const e1 = this.state.startLoc, t = this.startNode();
                                    if (this.next(), W(this.state.type)) {
                                        const e1 = this.parseIdentifierName(), n = this.createIdentifier(t, e1);
                                        if (n.type = "V8IntrinsicIdentifier", this.match(10)) return n;
                                    }
                                    this.unexpected(e1);
                                }
                            }
                            parseExprAtom(e1) {
                                return this.parseV8Intrinsic() || super.parseExprAtom(e1);
                            }
                        },
                    placeholders: (e1)=>class extends e1 {
                            parsePlaceholder(e1) {
                                if (this.match(142)) {
                                    const t = this.startNode();
                                    return this.next(), this.assertNoSpace(), t.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(142), this.finishPlaceholder(t, e1);
                                }
                            }
                            finishPlaceholder(e1, t) {
                                const n = !(!e1.expectedNode || "Placeholder" !== e1.type);
                                return e1.expectedNode = t, n ? e1 : this.finishNode(e1, "Placeholder");
                            }
                            getTokenFromCode(e1) {
                                37 === e1 && 37 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(142, 2) : super.getTokenFromCode(e1);
                            }
                            parseExprAtom(e1) {
                                return this.parsePlaceholder("Expression") || super.parseExprAtom(e1);
                            }
                            parseIdentifier(e1) {
                                return this.parsePlaceholder("Identifier") || super.parseIdentifier(e1);
                            }
                            checkReservedWord(e1, t, n, r) {
                                void 0 !== e1 && super.checkReservedWord(e1, t, n, r);
                            }
                            parseBindingAtom() {
                                return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
                            }
                            isValidLVal(e1, t, n) {
                                return "Placeholder" === e1 || super.isValidLVal(e1, t, n);
                            }
                            toAssignable(e1, t) {
                                e1 && "Placeholder" === e1.type && "Expression" === e1.expectedNode ? e1.expectedNode = "Pattern" : super.toAssignable(e1, t);
                            }
                            chStartsBindingIdentifier(e1, t) {
                                return !!super.chStartsBindingIdentifier(e1, t) || 142 === this.lookahead().type;
                            }
                            verifyBreakContinue(e1, t) {
                                e1.label && "Placeholder" === e1.label.type || super.verifyBreakContinue(e1, t);
                            }
                            parseExpressionStatement(e1, t) {
                                var n;
                                if ("Placeholder" !== t.type || null != (n = t.extra) && n.parenthesized) return super.parseExpressionStatement(e1, t);
                                if (this.match(14)) {
                                    const n = e1;
                                    return n.label = this.finishPlaceholder(t, "Identifier"), this.next(), n.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(n, "LabeledStatement");
                                }
                                return this.semicolon(), e1.name = t.name, this.finishPlaceholder(e1, "Statement");
                            }
                            parseBlock(e1, t, n) {
                                return this.parsePlaceholder("BlockStatement") || super.parseBlock(e1, t, n);
                            }
                            parseFunctionId(e1) {
                                return this.parsePlaceholder("Identifier") || super.parseFunctionId(e1);
                            }
                            parseClass(e1, t, n) {
                                const r = t ? "ClassDeclaration" : "ClassExpression";
                                this.next();
                                const i = this.state.strict, s = this.parsePlaceholder("Identifier");
                                if (s) {
                                    if (!(this.match(81) || this.match(142) || this.match(5))) {
                                        if (n || !t) return e1.id = null, e1.body = this.finishPlaceholder(s, "ClassBody"), this.finishNode(e1, r);
                                        throw this.raise(Ot.ClassNameIsRequired, {
                                            at: this.state.startLoc
                                        });
                                    }
                                    e1.id = s;
                                } else this.parseClassId(e1, t, n);
                                return super.parseClassSuper(e1), e1.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!e1.superClass, i), this.finishNode(e1, r);
                            }
                            parseExport(e1, t) {
                                const n = this.parsePlaceholder("Identifier");
                                if (!n) return super.parseExport(e1, t);
                                if (!this.isContextual(97) && !this.match(12)) return e1.specifiers = [], e1.source = null, e1.declaration = this.finishPlaceholder(n, "Declaration"), this.finishNode(e1, "ExportNamedDeclaration");
                                this.expectPlugin("exportDefaultFrom");
                                const r = this.startNode();
                                return r.exported = n, e1.specifiers = [
                                    this.finishNode(r, "ExportDefaultSpecifier")
                                ], super.parseExport(e1, t);
                            }
                            isExportDefaultSpecifier() {
                                if (this.match(65)) {
                                    const e1 = this.nextTokenStart();
                                    if (this.isUnparsedContextual(e1, "from") && this.input.startsWith($(142), this.nextTokenStartSince(e1 + 4))) return !0;
                                }
                                return super.isExportDefaultSpecifier();
                            }
                            maybeParseExportDefaultSpecifier(e1, t) {
                                var n;
                                return !(null == (n = e1.specifiers) || !n.length) || super.maybeParseExportDefaultSpecifier(e1, t);
                            }
                            checkExport(e1) {
                                const { specifiers: t } = e1;
                                null != t && t.length && (e1.specifiers = t.filter((e1)=>"Placeholder" === e1.exported.type)), super.checkExport(e1), e1.specifiers = t;
                            }
                            parseImport(e1) {
                                const t = this.parsePlaceholder("Identifier");
                                if (!t) return super.parseImport(e1);
                                if (e1.specifiers = [], !this.isContextual(97) && !this.match(12)) return e1.source = this.finishPlaceholder(t, "StringLiteral"), this.semicolon(), this.finishNode(e1, "ImportDeclaration");
                                const n = this.startNodeAtNode(t);
                                return n.local = t, e1.specifiers.push(this.finishNode(n, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(e1) || this.parseNamedImportSpecifiers(e1)), this.expectContextual(97), e1.source = this.parseImportSource(), this.semicolon(), this.finishNode(e1, "ImportDeclaration");
                            }
                            parseImportSource() {
                                return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
                            }
                            assertNoSpace() {
                                this.state.start > this.state.lastTokEndLoc.index && this.raise(Ot.UnexpectedSpace, {
                                    at: this.state.lastTokEndLoc
                                });
                            }
                        }
                }, Mt = Object.keys(_t), Bt = {
                    sourceType: "script",
                    sourceFilename: void 0,
                    startColumn: 0,
                    startLine: 1,
                    allowAwaitOutsideFunction: !1,
                    allowReturnOutsideFunction: !1,
                    allowNewTargetOutsideFunction: !1,
                    allowImportExportEverywhere: !1,
                    allowSuperOutsideMethod: !1,
                    allowUndeclaredExports: !1,
                    plugins: [],
                    strictMode: null,
                    ranges: !1,
                    tokens: !1,
                    createParenthesizedExpressions: !1,
                    errorRecovery: !1,
                    attachComment: !0,
                    annexB: !0
                };
                class jt extends Et {
                    checkProto(e1, t, n, r) {
                        if ("SpreadElement" === e1.type || this.isObjectMethod(e1) || e1.computed || e1.shorthand) return;
                        const i = e1.key;
                        if ("__proto__" === ("Identifier" === i.type ? i.name : i.value)) {
                            if (t) return void this.raise(g.RecordNoProto, {
                                at: i
                            });
                            n.used && (r ? null === r.doubleProtoLoc && (r.doubleProtoLoc = i.loc.start) : this.raise(g.DuplicateProto, {
                                at: i
                            })), n.used = !0;
                        }
                    }
                    shouldExitDescending(e1, t) {
                        return "ArrowFunctionExpression" === e1.type && e1.start === t;
                    }
                    getExpression() {
                        this.enterInitialScopes(), this.nextToken();
                        const e1 = this.parseExpression();
                        return this.match(137) || this.unexpected(), this.finalizeRemainingComments(), e1.comments = this.state.comments, e1.errors = this.state.errors, this.options.tokens && (e1.tokens = this.tokens), e1;
                    }
                    parseExpression(e1, t) {
                        return e1 ? this.disallowInAnd(()=>this.parseExpressionBase(t)) : this.allowInAnd(()=>this.parseExpressionBase(t));
                    }
                    parseExpressionBase(e1) {
                        const t = this.state.startLoc, n = this.parseMaybeAssign(e1);
                        if (this.match(12)) {
                            const r = this.startNodeAt(t);
                            for(r.expressions = [
                                n
                            ]; this.eat(12);)r.expressions.push(this.parseMaybeAssign(e1));
                            return this.toReferencedList(r.expressions), this.finishNode(r, "SequenceExpression");
                        }
                        return n;
                    }
                    parseMaybeAssignDisallowIn(e1, t) {
                        return this.disallowInAnd(()=>this.parseMaybeAssign(e1, t));
                    }
                    parseMaybeAssignAllowIn(e1, t) {
                        return this.allowInAnd(()=>this.parseMaybeAssign(e1, t));
                    }
                    setOptionalParametersError(e1, t) {
                        var n;
                        e1.optionalParametersLoc = null != (n = null == t ? void 0 : t.loc) ? n : this.state.startLoc;
                    }
                    parseMaybeAssign(e1, t) {
                        const n = this.state.startLoc;
                        if (this.isContextual(106) && this.prodParam.hasYield) {
                            let e1 = this.parseYield();
                            return t && (e1 = t.call(this, e1, n)), e1;
                        }
                        let r;
                        e1 ? r = !1 : (e1 = new rt, r = !0);
                        const { type: i } = this.state;
                        (10 === i || W(i)) && (this.state.potentialArrowAt = this.state.start);
                        let s = this.parseMaybeConditional(e1);
                        if (t && (s = t.call(this, s, n)), (a = this.state.type) >= 29 && a <= 33) {
                            const t = this.startNodeAt(n), r = this.state.value;
                            if (t.operator = r, this.match(29)) {
                                this.toAssignable(s, !0), t.left = s;
                                const r = n.index;
                                null != e1.doubleProtoLoc && e1.doubleProtoLoc.index >= r && (e1.doubleProtoLoc = null), null != e1.shorthandAssignLoc && e1.shorthandAssignLoc.index >= r && (e1.shorthandAssignLoc = null), null != e1.privateKeyLoc && e1.privateKeyLoc.index >= r && (this.checkDestructuringPrivate(e1), e1.privateKeyLoc = null);
                            } else t.left = s;
                            return this.next(), t.right = this.parseMaybeAssign(), this.checkLVal(s, {
                                in: this.finishNode(t, "AssignmentExpression")
                            }), t;
                        }
                        var a;
                        return r && this.checkExpressionErrors(e1, !0), s;
                    }
                    parseMaybeConditional(e1) {
                        const t = this.state.startLoc, n = this.state.potentialArrowAt, r = this.parseExprOps(e1);
                        return this.shouldExitDescending(r, n) ? r : this.parseConditional(r, t, e1);
                    }
                    parseConditional(e1, t, n) {
                        if (this.eat(17)) {
                            const n = this.startNodeAt(t);
                            return n.test = e1, n.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), n.alternate = this.parseMaybeAssign(), this.finishNode(n, "ConditionalExpression");
                        }
                        return e1;
                    }
                    parseMaybeUnaryOrPrivate(e1) {
                        return this.match(136) ? this.parsePrivateName() : this.parseMaybeUnary(e1);
                    }
                    parseExprOps(e1) {
                        const t = this.state.startLoc, n = this.state.potentialArrowAt, r = this.parseMaybeUnaryOrPrivate(e1);
                        return this.shouldExitDescending(r, n) ? r : this.parseExprOp(r, t, -1);
                    }
                    parseExprOp(e1, t, n) {
                        if (this.isPrivateName(e1)) {
                            const t = this.getPrivateNameSV(e1);
                            (n >= G(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(g.PrivateInExpectedIn, {
                                at: e1,
                                identifierName: t
                            }), this.classScope.usePrivateName(t, e1.loc.start);
                        }
                        const r = this.state.type;
                        if ((i = r) >= 39 && i <= 59 && (this.prodParam.hasIn || !this.match(58))) {
                            let i = G(r);
                            if (i > n) {
                                if (39 === r) {
                                    if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody) return e1;
                                    this.checkPipelineAtInfixOperator(e1, t);
                                }
                                const s = this.startNodeAt(t);
                                s.left = e1, s.operator = this.state.value;
                                const a = 41 === r || 42 === r, o = 40 === r;
                                if (o && (i = G(42)), this.next(), 39 === r && this.hasPlugin([
                                    "pipelineOperator",
                                    {
                                        proposal: "minimal"
                                    }
                                ]) && 96 === this.state.type && this.prodParam.hasAwait) throw this.raise(g.UnexpectedAwaitAfterPipelineBody, {
                                    at: this.state.startLoc
                                });
                                s.right = this.parseExprOpRightExpr(r, i);
                                const l = this.finishNode(s, a || o ? "LogicalExpression" : "BinaryExpression"), c = this.state.type;
                                if (o && (41 === c || 42 === c) || a && 40 === c) throw this.raise(g.MixingCoalesceWithLogical, {
                                    at: this.state.startLoc
                                });
                                return this.parseExprOp(l, t, n);
                            }
                        }
                        var i;
                        return e1;
                    }
                    parseExprOpRightExpr(e1, t) {
                        const n = this.state.startLoc;
                        if (39 === e1) switch(this.getPluginOption("pipelineOperator", "proposal")){
                            case "hack":
                                return this.withTopicBindingContext(()=>this.parseHackPipeBody());
                            case "smart":
                                return this.withTopicBindingContext(()=>{
                                    if (this.prodParam.hasYield && this.isContextual(106)) throw this.raise(g.PipeBodyIsTighter, {
                                        at: this.state.startLoc
                                    });
                                    return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e1, t), n);
                                });
                            case "fsharp":
                                return this.withSoloAwaitPermittingContext(()=>this.parseFSharpPipelineBody(t));
                        }
                        return this.parseExprOpBaseRightExpr(e1, t);
                    }
                    parseExprOpBaseRightExpr(e1, t) {
                        const n = this.state.startLoc;
                        return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), n, 57 === e1 ? t - 1 : t);
                    }
                    parseHackPipeBody() {
                        var e1;
                        const { startLoc: t } = this.state, n = this.parseMaybeAssign();
                        return !p.has(n.type) || null != (e1 = n.extra) && e1.parenthesized || this.raise(g.PipeUnparenthesizedBody, {
                            at: t,
                            type: n.type
                        }), this.topicReferenceWasUsedInCurrentContext() || this.raise(g.PipeTopicUnused, {
                            at: t
                        }), n;
                    }
                    checkExponentialAfterUnary(e1) {
                        this.match(57) && this.raise(g.UnexpectedTokenUnaryExponentiation, {
                            at: e1.argument
                        });
                    }
                    parseMaybeUnary(e1, t) {
                        const n = this.state.startLoc, r = this.isContextual(96);
                        if (r && this.isAwaitAllowed()) {
                            this.next();
                            const e1 = this.parseAwait(n);
                            return t || this.checkExponentialAfterUnary(e1), e1;
                        }
                        const i = this.match(34), s = this.startNode();
                        if (a = this.state.type, R[a]) {
                            s.operator = this.state.value, s.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
                            const n = this.match(89);
                            if (this.next(), s.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(e1, !0), this.state.strict && n) {
                                const e1 = s.argument;
                                "Identifier" === e1.type ? this.raise(g.StrictDelete, {
                                    at: s
                                }) : this.hasPropertyAsPrivateName(e1) && this.raise(g.DeletePrivateField, {
                                    at: s
                                });
                            }
                            if (!i) return t || this.checkExponentialAfterUnary(s), this.finishNode(s, "UnaryExpression");
                        }
                        var a;
                        const o = this.parseUpdate(s, i, e1);
                        if (r) {
                            const { type: e1 } = this.state;
                            if ((this.hasPlugin("v8intrinsic") ? q(e1) : q(e1) && !this.match(54)) && !this.isAmbiguousAwait()) return this.raiseOverwrite(g.AwaitNotInAsyncContext, {
                                at: n
                            }), this.parseAwait(n);
                        }
                        return o;
                    }
                    parseUpdate(e1, t, n) {
                        if (t) {
                            const t = e1;
                            return this.checkLVal(t.argument, {
                                in: this.finishNode(t, "UpdateExpression")
                            }), e1;
                        }
                        const r = this.state.startLoc;
                        let i = this.parseExprSubscripts(n);
                        if (this.checkExpressionErrors(n, !1)) return i;
                        for(; 34 === this.state.type && !this.canInsertSemicolon();){
                            const e1 = this.startNodeAt(r);
                            e1.operator = this.state.value, e1.prefix = !1, e1.argument = i, this.next(), this.checkLVal(i, {
                                in: i = this.finishNode(e1, "UpdateExpression")
                            });
                        }
                        return i;
                    }
                    parseExprSubscripts(e1) {
                        const t = this.state.startLoc, n = this.state.potentialArrowAt, r = this.parseExprAtom(e1);
                        return this.shouldExitDescending(r, n) ? r : this.parseSubscripts(r, t);
                    }
                    parseSubscripts(e1, t, n) {
                        const r = {
                            optionalChainMember: !1,
                            maybeAsyncArrow: this.atPossibleAsyncArrow(e1),
                            stop: !1
                        };
                        do {
                            e1 = this.parseSubscript(e1, t, n, r), r.maybeAsyncArrow = !1;
                        }while (!r.stop)
                        return e1;
                    }
                    parseSubscript(e1, t, n, r) {
                        const { type: i } = this.state;
                        if (!n && 15 === i) return this.parseBind(e1, t, n, r);
                        if (z(i)) return this.parseTaggedTemplateExpression(e1, t, r);
                        let s = !1;
                        if (18 === i) {
                            if (n && (this.raise(g.OptionalChainingNoNew, {
                                at: this.state.startLoc
                            }), 40 === this.lookaheadCharCode())) return r.stop = !0, e1;
                            r.optionalChainMember = s = !0, this.next();
                        }
                        if (!n && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(e1, t, r, s);
                        {
                            const n = this.eat(0);
                            return n || s || this.eat(16) ? this.parseMember(e1, t, r, n, s) : (r.stop = !0, e1);
                        }
                    }
                    parseMember(e1, t, n, r, i) {
                        const s = this.startNodeAt(t);
                        return s.object = e1, s.computed = r, r ? (s.property = this.parseExpression(), this.expect(3)) : this.match(136) ? ("Super" === e1.type && this.raise(g.SuperPrivateField, {
                            at: t
                        }), this.classScope.usePrivateName(this.state.value, this.state.startLoc), s.property = this.parsePrivateName()) : s.property = this.parseIdentifier(!0), n.optionalChainMember ? (s.optional = i, this.finishNode(s, "OptionalMemberExpression")) : this.finishNode(s, "MemberExpression");
                    }
                    parseBind(e1, t, n, r) {
                        const i = this.startNodeAt(t);
                        return i.object = e1, this.next(), i.callee = this.parseNoCallExpr(), r.stop = !0, this.parseSubscripts(this.finishNode(i, "BindExpression"), t, n);
                    }
                    parseCoverCallAndAsyncArrowHead(e1, t, n, r) {
                        const i = this.state.maybeInArrowParameters;
                        let s = null;
                        this.state.maybeInArrowParameters = !0, this.next();
                        const a = this.startNodeAt(t);
                        a.callee = e1;
                        const { maybeAsyncArrow: o, optionalChainMember: l } = n;
                        o && (this.expressionScope.enter(new ze(2)), s = new rt), l && (a.optional = r), a.arguments = r ? this.parseCallExpressionArguments(11) : this.parseCallExpressionArguments(11, "Import" === e1.type, "Super" !== e1.type, a, s);
                        let c = this.finishCallExpression(a, l);
                        return o && this.shouldParseAsyncArrow() && !r ? (n.stop = !0, this.checkDestructuringPrivate(s), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), c = this.parseAsyncArrowFromCallExpression(this.startNodeAt(t), c)) : (o && (this.checkExpressionErrors(s, !0), this.expressionScope.exit()), this.toReferencedArguments(c)), this.state.maybeInArrowParameters = i, c;
                    }
                    toReferencedArguments(e1, t) {
                        this.toReferencedListDeep(e1.arguments, t);
                    }
                    parseTaggedTemplateExpression(e1, t, n) {
                        const r = this.startNodeAt(t);
                        return r.tag = e1, r.quasi = this.parseTemplate(!0), n.optionalChainMember && this.raise(g.OptionalChainingNoTemplate, {
                            at: t
                        }), this.finishNode(r, "TaggedTemplateExpression");
                    }
                    atPossibleAsyncArrow(e1) {
                        return "Identifier" === e1.type && "async" === e1.name && this.state.lastTokEndLoc.index === e1.end && !this.canInsertSemicolon() && e1.end - e1.start == 5 && e1.start === this.state.potentialArrowAt;
                    }
                    expectImportAttributesPlugin() {
                        this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
                    }
                    finishCallExpression(e1, t) {
                        if ("Import" === e1.callee.type) if (2 === e1.arguments.length && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), 0 === e1.arguments.length || e1.arguments.length > 2) this.raise(g.ImportCallArity, {
                            at: e1,
                            maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
                        });
                        else for (const t of e1.arguments)"SpreadElement" === t.type && this.raise(g.ImportCallSpreadArgument, {
                            at: t
                        });
                        return this.finishNode(e1, t ? "OptionalCallExpression" : "CallExpression");
                    }
                    parseCallExpressionArguments(e1, t, n, r, i) {
                        const s = [];
                        let a = !0;
                        const o = this.state.inFSharpPipelineDirectBody;
                        for(this.state.inFSharpPipelineDirectBody = !1; !this.eat(e1);){
                            if (a) a = !1;
                            else if (this.expect(12), this.match(e1)) {
                                !t || this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") || this.raise(g.ImportCallArgumentTrailingComma, {
                                    at: this.state.lastTokStartLoc
                                }), r && this.addTrailingCommaExtraToNode(r), this.next();
                                break;
                            }
                            s.push(this.parseExprListItem(!1, i, n));
                        }
                        return this.state.inFSharpPipelineDirectBody = o, s;
                    }
                    shouldParseAsyncArrow() {
                        return this.match(19) && !this.canInsertSemicolon();
                    }
                    parseAsyncArrowFromCallExpression(e1, t) {
                        var n;
                        return this.resetPreviousNodeTrailingComments(t), this.expect(19), this.parseArrowExpression(e1, t.arguments, !0, null == (n = t.extra) ? void 0 : n.trailingCommaLoc), t.innerComments && Pe(e1, t.innerComments), t.callee.trailingComments && Pe(e1, t.callee.trailingComments), e1;
                    }
                    parseNoCallExpr() {
                        const e1 = this.state.startLoc;
                        return this.parseSubscripts(this.parseExprAtom(), e1, !0);
                    }
                    parseExprAtom(e1) {
                        let t, n = null;
                        const { type: r } = this.state;
                        switch(r){
                            case 79:
                                return this.parseSuper();
                            case 83:
                                return t = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(t) : (this.match(10) || this.raise(g.UnsupportedImport, {
                                    at: this.state.lastTokStartLoc
                                }), this.finishNode(t, "Import"));
                            case 78:
                                return t = this.startNode(), this.next(), this.finishNode(t, "ThisExpression");
                            case 90:
                                return this.parseDo(this.startNode(), !1);
                            case 56:
                            case 31:
                                return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
                            case 132:
                                return this.parseNumericLiteral(this.state.value);
                            case 133:
                                return this.parseBigIntLiteral(this.state.value);
                            case 134:
                                return this.parseDecimalLiteral(this.state.value);
                            case 131:
                                return this.parseStringLiteral(this.state.value);
                            case 84:
                                return this.parseNullLiteral();
                            case 85:
                                return this.parseBooleanLiteral(!0);
                            case 86:
                                return this.parseBooleanLiteral(!1);
                            case 10:
                                {
                                    const e1 = this.state.potentialArrowAt === this.state.start;
                                    return this.parseParenAndDistinguishExpression(e1);
                                }
                            case 2:
                            case 1:
                                return this.parseArrayLike(2 === this.state.type ? 4 : 3, !1, !0);
                            case 0:
                                return this.parseArrayLike(3, !0, !1, e1);
                            case 6:
                            case 7:
                                return this.parseObjectLike(6 === this.state.type ? 9 : 8, !1, !0);
                            case 5:
                                return this.parseObjectLike(8, !1, !1, e1);
                            case 68:
                                return this.parseFunctionOrFunctionSent();
                            case 26:
                                n = this.parseDecorators();
                            case 80:
                                return this.parseClass(this.maybeTakeDecorators(n, this.startNode()), !1);
                            case 77:
                                return this.parseNewOrNewTarget();
                            case 25:
                            case 24:
                                return this.parseTemplate(!1);
                            case 15:
                                {
                                    t = this.startNode(), this.next(), t.object = null;
                                    const e1 = t.callee = this.parseNoCallExpr();
                                    if ("MemberExpression" === e1.type) return this.finishNode(t, "BindExpression");
                                    throw this.raise(g.UnsupportedBind, {
                                        at: e1
                                    });
                                }
                            case 136:
                                return this.raise(g.PrivateInExpectedIn, {
                                    at: this.state.startLoc,
                                    identifierName: this.state.value
                                }), this.parsePrivateName();
                            case 33:
                                return this.parseTopicReferenceThenEqualsSign(54, "%");
                            case 32:
                                return this.parseTopicReferenceThenEqualsSign(44, "^");
                            case 37:
                            case 38:
                                return this.parseTopicReference("hack");
                            case 44:
                            case 54:
                            case 27:
                                {
                                    const e1 = this.getPluginOption("pipelineOperator", "proposal");
                                    if (e1) return this.parseTopicReference(e1);
                                    this.unexpected();
                                    break;
                                }
                            case 47:
                                {
                                    const e1 = this.input.codePointAt(this.nextTokenStart());
                                    ae(e1) || 62 === e1 ? this.expectOnePlugin([
                                        "jsx",
                                        "flow",
                                        "typescript"
                                    ]) : this.unexpected();
                                    break;
                                }
                            default:
                                if (W(r)) {
                                    if (this.isContextual(125) && 123 === this.lookaheadInLineCharCode()) return this.parseModuleExpression();
                                    const e1 = this.state.potentialArrowAt === this.state.start, t = this.state.containsEsc, n = this.parseIdentifier();
                                    if (!t && "async" === n.name && !this.canInsertSemicolon()) {
                                        const { type: e1 } = this.state;
                                        if (68 === e1) return this.resetPreviousNodeTrailingComments(n), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(n));
                                        if (W(e1)) return 61 === this.lookaheadCharCode() ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(n)) : n;
                                        if (90 === e1) return this.resetPreviousNodeTrailingComments(n), this.parseDo(this.startNodeAtNode(n), !0);
                                    }
                                    return e1 && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(n), [
                                        n
                                    ], !1)) : n;
                                }
                                this.unexpected();
                        }
                    }
                    parseTopicReferenceThenEqualsSign(e1, t) {
                        const n = this.getPluginOption("pipelineOperator", "proposal");
                        if (n) return this.state.type = e1, this.state.value = t, this.state.pos--, this.state.end--, this.state.endLoc = s(this.state.endLoc, -1), this.parseTopicReference(n);
                        this.unexpected();
                    }
                    parseTopicReference(e1) {
                        const t = this.startNode(), n = this.state.startLoc, r = this.state.type;
                        return this.next(), this.finishTopicReference(t, n, e1, r);
                    }
                    finishTopicReference(e1, t, n, r) {
                        if (this.testTopicReferenceConfiguration(n, t, r)) {
                            const r = "smart" === n ? "PipelinePrimaryTopicReference" : "TopicReference";
                            return this.topicReferenceIsAllowedInCurrentContext() || this.raise("smart" === n ? g.PrimaryTopicNotAllowed : g.PipeTopicUnbound, {
                                at: t
                            }), this.registerTopicReference(), this.finishNode(e1, r);
                        }
                        throw this.raise(g.PipeTopicUnconfiguredToken, {
                            at: t,
                            token: $(r)
                        });
                    }
                    testTopicReferenceConfiguration(e1, t, n) {
                        switch(e1){
                            case "hack":
                                return this.hasPlugin([
                                    "pipelineOperator",
                                    {
                                        topicToken: $(n)
                                    }
                                ]);
                            case "smart":
                                return 27 === n;
                            default:
                                throw this.raise(g.PipeTopicRequiresHackPipes, {
                                    at: t
                                });
                        }
                    }
                    parseAsyncArrowUnaryFunction(e1) {
                        this.prodParam.enter(tt(!0, this.prodParam.hasYield));
                        const t = [
                            this.parseIdentifier()
                        ];
                        return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(g.LineTerminatorBeforeArrow, {
                            at: this.state.curPosition()
                        }), this.expect(19), this.parseArrowExpression(e1, t, !0);
                    }
                    parseDo(e1, t) {
                        this.expectPlugin("doExpressions"), t && this.expectPlugin("asyncDoExpressions"), e1.async = t, this.next();
                        const n = this.state.labels;
                        return this.state.labels = [], t ? (this.prodParam.enter(2), e1.body = this.parseBlock(), this.prodParam.exit()) : e1.body = this.parseBlock(), this.state.labels = n, this.finishNode(e1, "DoExpression");
                    }
                    parseSuper() {
                        const e1 = this.startNode();
                        return this.next(), !this.match(10) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? this.scope.allowSuper || this.options.allowSuperOutsideMethod || this.raise(g.UnexpectedSuper, {
                            at: e1
                        }) : this.raise(g.SuperNotAllowed, {
                            at: e1
                        }), this.match(10) || this.match(0) || this.match(16) || this.raise(g.UnsupportedSuper, {
                            at: e1
                        }), this.finishNode(e1, "Super");
                    }
                    parsePrivateName() {
                        const e1 = this.startNode(), t = this.startNodeAt(s(this.state.startLoc, 1)), n = this.state.value;
                        return this.next(), e1.id = this.createIdentifier(t, n), this.finishNode(e1, "PrivateName");
                    }
                    parseFunctionOrFunctionSent() {
                        const e1 = this.startNode();
                        if (this.next(), this.prodParam.hasYield && this.match(16)) {
                            const t = this.createIdentifier(this.startNodeAtNode(e1), "function");
                            return this.next(), this.match(102) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(e1, t, "sent");
                        }
                        return this.parseFunction(e1);
                    }
                    parseMetaProperty(e1, t, n) {
                        e1.meta = t;
                        const r = this.state.containsEsc;
                        return e1.property = this.parseIdentifier(!0), (e1.property.name !== n || r) && this.raise(g.UnsupportedMetaProperty, {
                            at: e1.property,
                            target: t.name,
                            onlyValidPropertyName: n
                        }), this.finishNode(e1, "MetaProperty");
                    }
                    parseImportMetaProperty(e1) {
                        const t = this.createIdentifier(this.startNodeAtNode(e1), "import");
                        return this.next(), this.isContextual(100) && (this.inModule || this.raise(g.ImportMetaOutsideModule, {
                            at: t
                        }), this.sawUnambiguousESM = !0), this.parseMetaProperty(e1, t, "meta");
                    }
                    parseLiteralAtNode(e1, t, n) {
                        return this.addExtra(n, "rawValue", e1), this.addExtra(n, "raw", this.input.slice(n.start, this.state.end)), n.value = e1, this.next(), this.finishNode(n, t);
                    }
                    parseLiteral(e1, t) {
                        const n = this.startNode();
                        return this.parseLiteralAtNode(e1, t, n);
                    }
                    parseStringLiteral(e1) {
                        return this.parseLiteral(e1, "StringLiteral");
                    }
                    parseNumericLiteral(e1) {
                        return this.parseLiteral(e1, "NumericLiteral");
                    }
                    parseBigIntLiteral(e1) {
                        return this.parseLiteral(e1, "BigIntLiteral");
                    }
                    parseDecimalLiteral(e1) {
                        return this.parseLiteral(e1, "DecimalLiteral");
                    }
                    parseRegExpLiteral(e1) {
                        const t = this.parseLiteral(e1.value, "RegExpLiteral");
                        return t.pattern = e1.pattern, t.flags = e1.flags, t;
                    }
                    parseBooleanLiteral(e1) {
                        const t = this.startNode();
                        return t.value = e1, this.next(), this.finishNode(t, "BooleanLiteral");
                    }
                    parseNullLiteral() {
                        const e1 = this.startNode();
                        return this.next(), this.finishNode(e1, "NullLiteral");
                    }
                    parseParenAndDistinguishExpression(e1) {
                        const t = this.state.startLoc;
                        let n;
                        this.next(), this.expressionScope.enter(new ze(1));
                        const r = this.state.maybeInArrowParameters, i = this.state.inFSharpPipelineDirectBody;
                        this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
                        const s = this.state.startLoc, a = [], o = new rt;
                        let l, c, u = !0;
                        for(; !this.match(11);){
                            if (u) u = !1;
                            else if (this.expect(12, null === o.optionalParametersLoc ? null : o.optionalParametersLoc), this.match(11)) {
                                c = this.state.startLoc;
                                break;
                            }
                            if (this.match(21)) {
                                const e1 = this.state.startLoc;
                                if (l = this.state.startLoc, a.push(this.parseParenItem(this.parseRestBinding(), e1)), !this.checkCommaAfterRest(41)) break;
                            } else a.push(this.parseMaybeAssignAllowIn(o, this.parseParenItem));
                        }
                        const p = this.state.lastTokEndLoc;
                        this.expect(11), this.state.maybeInArrowParameters = r, this.state.inFSharpPipelineDirectBody = i;
                        let h = this.startNodeAt(t);
                        return e1 && this.shouldParseArrow(a) && (h = this.parseArrow(h)) ? (this.checkDestructuringPrivate(o), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(h, a, !1), h) : (this.expressionScope.exit(), a.length || this.unexpected(this.state.lastTokStartLoc), c && this.unexpected(c), l && this.unexpected(l), this.checkExpressionErrors(o, !0), this.toReferencedListDeep(a, !0), a.length > 1 ? (n = this.startNodeAt(s), n.expressions = a, this.finishNode(n, "SequenceExpression"), this.resetEndLocation(n, p)) : n = a[0], this.wrapParenthesis(t, n));
                    }
                    wrapParenthesis(e1, t) {
                        if (!this.options.createParenthesizedExpressions) return this.addExtra(t, "parenthesized", !0), this.addExtra(t, "parenStart", e1.index), this.takeSurroundingComments(t, e1.index, this.state.lastTokEndLoc.index), t;
                        const n = this.startNodeAt(e1);
                        return n.expression = t, this.finishNode(n, "ParenthesizedExpression");
                    }
                    shouldParseArrow(e1) {
                        return !this.canInsertSemicolon();
                    }
                    parseArrow(e1) {
                        if (this.eat(19)) return e1;
                    }
                    parseParenItem(e1, t) {
                        return e1;
                    }
                    parseNewOrNewTarget() {
                        const e1 = this.startNode();
                        if (this.next(), this.match(16)) {
                            const t = this.createIdentifier(this.startNodeAtNode(e1), "new");
                            this.next();
                            const n = this.parseMetaProperty(e1, t, "target");
                            return this.scope.inNonArrowFunction || this.scope.inClass || this.options.allowNewTargetOutsideFunction || this.raise(g.UnexpectedNewTarget, {
                                at: n
                            }), n;
                        }
                        return this.parseNew(e1);
                    }
                    parseNew(e1) {
                        if (this.parseNewCallee(e1), this.eat(10)) {
                            const t = this.parseExprList(11);
                            this.toReferencedList(t), e1.arguments = t;
                        } else e1.arguments = [];
                        return this.finishNode(e1, "NewExpression");
                    }
                    parseNewCallee(e1) {
                        e1.callee = this.parseNoCallExpr(), "Import" === e1.callee.type && this.raise(g.ImportCallNotNewExpression, {
                            at: e1.callee
                        });
                    }
                    parseTemplateElement(e1) {
                        const { start: t, startLoc: n, end: r, value: i } = this.state, a = t + 1, o = this.startNodeAt(s(n, 1));
                        null === i && (e1 || this.raise(g.InvalidEscapeSequenceTemplate, {
                            at: s(this.state.firstInvalidTemplateEscapePos, 1)
                        }));
                        const l = this.match(24), c = l ? -1 : -2, u = r + c;
                        o.value = {
                            raw: this.input.slice(a, u).replace(/\r\n?/g, "\n"),
                            cooked: null === i ? null : i.slice(1, c)
                        }, o.tail = l, this.next();
                        const p = this.finishNode(o, "TemplateElement");
                        return this.resetEndLocation(p, s(this.state.lastTokEndLoc, c)), p;
                    }
                    parseTemplate(e1) {
                        const t = this.startNode();
                        t.expressions = [];
                        let n = this.parseTemplateElement(e1);
                        for(t.quasis = [
                            n
                        ]; !n.tail;)t.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), t.quasis.push(n = this.parseTemplateElement(e1));
                        return this.finishNode(t, "TemplateLiteral");
                    }
                    parseTemplateSubstitution() {
                        return this.parseExpression();
                    }
                    parseObjectLike(e1, t, n, r) {
                        n && this.expectPlugin("recordAndTuple");
                        const i = this.state.inFSharpPipelineDirectBody;
                        this.state.inFSharpPipelineDirectBody = !1;
                        const s = Object.create(null);
                        let a = !0;
                        const o = this.startNode();
                        for(o.properties = [], this.next(); !this.match(e1);){
                            if (a) a = !1;
                            else if (this.expect(12), this.match(e1)) {
                                this.addTrailingCommaExtraToNode(o);
                                break;
                            }
                            let i;
                            t ? i = this.parseBindingProperty() : (i = this.parsePropertyDefinition(r), this.checkProto(i, n, s, r)), n && !this.isObjectProperty(i) && "SpreadElement" !== i.type && this.raise(g.InvalidRecordProperty, {
                                at: i
                            }), i.shorthand && this.addExtra(i, "shorthand", !0), o.properties.push(i);
                        }
                        this.next(), this.state.inFSharpPipelineDirectBody = i;
                        let l = "ObjectExpression";
                        return t ? l = "ObjectPattern" : n && (l = "RecordExpression"), this.finishNode(o, l);
                    }
                    addTrailingCommaExtraToNode(e1) {
                        this.addExtra(e1, "trailingComma", this.state.lastTokStart), this.addExtra(e1, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
                    }
                    maybeAsyncOrAccessorProp(e1) {
                        return !e1.computed && "Identifier" === e1.key.type && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
                    }
                    parsePropertyDefinition(e1) {
                        let t = [];
                        if (this.match(26)) for(this.hasPlugin("decorators") && this.raise(g.UnsupportedPropertyDecorator, {
                            at: this.state.startLoc
                        }); this.match(26);)t.push(this.parseDecorator());
                        const n = this.startNode();
                        let r, i = !1, s = !1;
                        if (this.match(21)) return t.length && this.unexpected(), this.parseSpread();
                        t.length && (n.decorators = t, t = []), n.method = !1, e1 && (r = this.state.startLoc);
                        let a = this.eat(55);
                        this.parsePropertyNamePrefixOperator(n);
                        const o = this.state.containsEsc, l = this.parsePropertyName(n, e1);
                        if (!a && !o && this.maybeAsyncOrAccessorProp(n)) {
                            const e1 = l.name;
                            "async" !== e1 || this.hasPrecedingLineBreak() || (i = !0, this.resetPreviousNodeTrailingComments(l), a = this.eat(55), this.parsePropertyName(n)), "get" !== e1 && "set" !== e1 || (s = !0, this.resetPreviousNodeTrailingComments(l), n.kind = e1, this.match(55) && (a = !0, this.raise(g.AccessorIsGenerator, {
                                at: this.state.curPosition(),
                                kind: e1
                            }), this.next()), this.parsePropertyName(n));
                        }
                        return this.parseObjPropValue(n, r, a, i, !1, s, e1);
                    }
                    getGetterSetterExpectedParamCount(e1) {
                        return "get" === e1.kind ? 0 : 1;
                    }
                    getObjectOrClassMethodParams(e1) {
                        return e1.params;
                    }
                    checkGetterSetterParams(e1) {
                        var t;
                        const n = this.getGetterSetterExpectedParamCount(e1), r = this.getObjectOrClassMethodParams(e1);
                        r.length !== n && this.raise("get" === e1.kind ? g.BadGetterArity : g.BadSetterArity, {
                            at: e1
                        }), "set" === e1.kind && "RestElement" === (null == (t = r[r.length - 1]) ? void 0 : t.type) && this.raise(g.BadSetterRestParameter, {
                            at: e1
                        });
                    }
                    parseObjectMethod(e1, t, n, r, i) {
                        if (i) {
                            const n = this.parseMethod(e1, t, !1, !1, !1, "ObjectMethod");
                            return this.checkGetterSetterParams(n), n;
                        }
                        if (n || t || this.match(10)) return r && this.unexpected(), e1.kind = "method", e1.method = !0, this.parseMethod(e1, t, n, !1, !1, "ObjectMethod");
                    }
                    parseObjectProperty(e1, t, n, r) {
                        if (e1.shorthand = !1, this.eat(14)) return e1.value = n ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(r), this.finishNode(e1, "ObjectProperty");
                        if (!e1.computed && "Identifier" === e1.key.type) {
                            if (this.checkReservedWord(e1.key.name, e1.key.loc.start, !0, !1), n) e1.value = this.parseMaybeDefault(t, at(e1.key));
                            else if (this.match(29)) {
                                const n = this.state.startLoc;
                                null != r ? null === r.shorthandAssignLoc && (r.shorthandAssignLoc = n) : this.raise(g.InvalidCoverInitializedName, {
                                    at: n
                                }), e1.value = this.parseMaybeDefault(t, at(e1.key));
                            } else e1.value = at(e1.key);
                            return e1.shorthand = !0, this.finishNode(e1, "ObjectProperty");
                        }
                    }
                    parseObjPropValue(e1, t, n, r, i, s, a) {
                        const o = this.parseObjectMethod(e1, n, r, i, s) || this.parseObjectProperty(e1, t, i, a);
                        return o || this.unexpected(), o;
                    }
                    parsePropertyName(e1, t) {
                        if (this.eat(0)) e1.computed = !0, e1.key = this.parseMaybeAssignAllowIn(), this.expect(3);
                        else {
                            const { type: n, value: r } = this.state;
                            let i;
                            if (X(n)) i = this.parseIdentifier(!0);
                            else switch(n){
                                case 132:
                                    i = this.parseNumericLiteral(r);
                                    break;
                                case 131:
                                    i = this.parseStringLiteral(r);
                                    break;
                                case 133:
                                    i = this.parseBigIntLiteral(r);
                                    break;
                                case 134:
                                    i = this.parseDecimalLiteral(r);
                                    break;
                                case 136:
                                    {
                                        const e1 = this.state.startLoc;
                                        null != t ? null === t.privateKeyLoc && (t.privateKeyLoc = e1) : this.raise(g.UnexpectedPrivateField, {
                                            at: e1
                                        }), i = this.parsePrivateName();
                                        break;
                                    }
                                default:
                                    this.unexpected();
                            }
                            e1.key = i, 136 !== n && (e1.computed = !1);
                        }
                        return e1.key;
                    }
                    initFunction(e1, t) {
                        e1.id = null, e1.generator = !1, e1.async = t;
                    }
                    parseMethod(e1, t, n, r, i, s, a = !1) {
                        this.initFunction(e1, n), e1.generator = t, this.scope.enter(18 | (a ? 64 : 0) | (i ? 32 : 0)), this.prodParam.enter(tt(n, e1.generator)), this.parseFunctionParams(e1, r);
                        const o = this.parseFunctionBodyAndFinish(e1, s, !0);
                        return this.prodParam.exit(), this.scope.exit(), o;
                    }
                    parseArrayLike(e1, t, n, r) {
                        n && this.expectPlugin("recordAndTuple");
                        const i = this.state.inFSharpPipelineDirectBody;
                        this.state.inFSharpPipelineDirectBody = !1;
                        const s = this.startNode();
                        return this.next(), s.elements = this.parseExprList(e1, !n, r, s), this.state.inFSharpPipelineDirectBody = i, this.finishNode(s, n ? "TupleExpression" : "ArrayExpression");
                    }
                    parseArrowExpression(e1, t, n, r) {
                        this.scope.enter(6);
                        let i = tt(n, !1);
                        !this.match(5) && this.prodParam.hasIn && (i |= 8), this.prodParam.enter(i), this.initFunction(e1, n);
                        const s = this.state.maybeInArrowParameters;
                        return t && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(e1, t, r)), this.state.maybeInArrowParameters = !1, this.parseFunctionBody(e1, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = s, this.finishNode(e1, "ArrowFunctionExpression");
                    }
                    setArrowFunctionParameters(e1, t, n) {
                        this.toAssignableList(t, n, !1), e1.params = t;
                    }
                    parseFunctionBodyAndFinish(e1, t, n = !1) {
                        return this.parseFunctionBody(e1, !1, n), this.finishNode(e1, t);
                    }
                    parseFunctionBody(e1, t, n = !1) {
                        const r = t && !this.match(5);
                        if (this.expressionScope.enter(Ze()), r) e1.body = this.parseMaybeAssign(), this.checkParams(e1, !1, t, !1);
                        else {
                            const r = this.state.strict, i = this.state.labels;
                            this.state.labels = [], this.prodParam.enter(4 | this.prodParam.currentFlags()), e1.body = this.parseBlock(!0, !1, (i)=>{
                                const s = !this.isSimpleParamList(e1.params);
                                i && s && this.raise(g.IllegalLanguageModeDirective, {
                                    at: "method" !== e1.kind && "constructor" !== e1.kind || !e1.key ? e1 : e1.key.loc.end
                                });
                                const a = !r && this.state.strict;
                                this.checkParams(e1, !(this.state.strict || t || n || s), t, a), this.state.strict && e1.id && this.checkIdentifier(e1.id, 65, a);
                            }), this.prodParam.exit(), this.state.labels = i;
                        }
                        this.expressionScope.exit();
                    }
                    isSimpleParameter(e1) {
                        return "Identifier" === e1.type;
                    }
                    isSimpleParamList(e1) {
                        for(let t = 0, n = e1.length; t < n; t++)if (!this.isSimpleParameter(e1[t])) return !1;
                        return !0;
                    }
                    checkParams(e1, t, n, r = !0) {
                        const i = !t && new Set, s = {
                            type: "FormalParameters"
                        };
                        for (const t of e1.params)this.checkLVal(t, {
                            in: s,
                            binding: 5,
                            checkClashes: i,
                            strictModeChanged: r
                        });
                    }
                    parseExprList(e1, t, n, r) {
                        const i = [];
                        let s = !0;
                        for(; !this.eat(e1);){
                            if (s) s = !1;
                            else if (this.expect(12), this.match(e1)) {
                                r && this.addTrailingCommaExtraToNode(r), this.next();
                                break;
                            }
                            i.push(this.parseExprListItem(t, n));
                        }
                        return i;
                    }
                    parseExprListItem(e1, t, n) {
                        let r;
                        if (this.match(12)) e1 || this.raise(g.UnexpectedToken, {
                            at: this.state.curPosition(),
                            unexpected: ","
                        }), r = null;
                        else if (this.match(21)) {
                            const e1 = this.state.startLoc;
                            r = this.parseParenItem(this.parseSpread(t), e1);
                        } else if (this.match(17)) {
                            this.expectPlugin("partialApplication"), n || this.raise(g.UnexpectedArgumentPlaceholder, {
                                at: this.state.startLoc
                            });
                            const e1 = this.startNode();
                            this.next(), r = this.finishNode(e1, "ArgumentPlaceholder");
                        } else r = this.parseMaybeAssignAllowIn(t, this.parseParenItem);
                        return r;
                    }
                    parseIdentifier(e1) {
                        const t = this.startNode(), n = this.parseIdentifierName(e1);
                        return this.createIdentifier(t, n);
                    }
                    createIdentifier(e1, t) {
                        return e1.name = t, e1.loc.identifierName = t, this.finishNode(e1, "Identifier");
                    }
                    parseIdentifierName(e1) {
                        let t;
                        const { startLoc: n, type: r } = this.state;
                        X(r) ? t = this.state.value : this.unexpected();
                        const i = r <= 92;
                        return e1 ? i && this.replaceToken(130) : this.checkReservedWord(t, n, i, !1), this.next(), t;
                    }
                    checkReservedWord(e1, t, n, r) {
                        if (!(e1.length > 10) && function(e1) {
                            return ye.has(e1);
                        }(e1)) {
                            if (n && function(e1) {
                                return le.has(e1);
                            }(e1)) this.raise(g.UnexpectedKeyword, {
                                at: t,
                                keyword: e1
                            });
                            else if ((this.state.strict ? r ? fe : he : pe)(e1, this.inModule)) this.raise(g.UnexpectedReservedWord, {
                                at: t,
                                reservedWord: e1
                            });
                            else if ("yield" === e1) {
                                if (this.prodParam.hasYield) return void this.raise(g.YieldBindingIdentifier, {
                                    at: t
                                });
                            } else if ("await" === e1) {
                                if (this.prodParam.hasAwait) return void this.raise(g.AwaitBindingIdentifier, {
                                    at: t
                                });
                                if (this.scope.inStaticBlock) return void this.raise(g.AwaitBindingIdentifierInStaticBlock, {
                                    at: t
                                });
                                this.expressionScope.recordAsyncArrowParametersError({
                                    at: t
                                });
                            } else if ("arguments" === e1 && this.scope.inClassAndNotInNonArrowFunction) return void this.raise(g.ArgumentsInClass, {
                                at: t
                            });
                        }
                    }
                    isAwaitAllowed() {
                        return !!this.prodParam.hasAwait || !(!this.options.allowAwaitOutsideFunction || this.scope.inFunction);
                    }
                    parseAwait(e1) {
                        const t = this.startNodeAt(e1);
                        return this.expressionScope.recordParameterInitializerError(g.AwaitExpressionFormalParameter, {
                            at: t
                        }), this.eat(55) && this.raise(g.ObsoleteAwaitStar, {
                            at: t
                        }), this.scope.inFunction || this.options.allowAwaitOutsideFunction || (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (t.argument = this.parseMaybeUnary(null, !0)), this.finishNode(t, "AwaitExpression");
                    }
                    isAmbiguousAwait() {
                        if (this.hasPrecedingLineBreak()) return !0;
                        const { type: e1 } = this.state;
                        return 53 === e1 || 10 === e1 || 0 === e1 || z(e1) || 101 === e1 && !this.state.containsEsc || 135 === e1 || 56 === e1 || this.hasPlugin("v8intrinsic") && 54 === e1;
                    }
                    parseYield() {
                        const e1 = this.startNode();
                        this.expressionScope.recordParameterInitializerError(g.YieldInParameter, {
                            at: e1
                        }), this.next();
                        let t = !1, n = null;
                        if (!this.hasPrecedingLineBreak()) switch(t = this.eat(55), this.state.type){
                            case 13:
                            case 137:
                            case 8:
                            case 11:
                            case 3:
                            case 9:
                            case 14:
                            case 12:
                                if (!t) break;
                            default:
                                n = this.parseMaybeAssign();
                        }
                        return e1.delegate = t, e1.argument = n, this.finishNode(e1, "YieldExpression");
                    }
                    checkPipelineAtInfixOperator(e1, t) {
                        this.hasPlugin([
                            "pipelineOperator",
                            {
                                proposal: "smart"
                            }
                        ]) && "SequenceExpression" === e1.type && this.raise(g.PipelineHeadSequenceExpression, {
                            at: t
                        });
                    }
                    parseSmartPipelineBodyInStyle(e1, t) {
                        if (this.isSimpleReference(e1)) {
                            const n = this.startNodeAt(t);
                            return n.callee = e1, this.finishNode(n, "PipelineBareFunction");
                        }
                        {
                            const n = this.startNodeAt(t);
                            return this.checkSmartPipeTopicBodyEarlyErrors(t), n.expression = e1, this.finishNode(n, "PipelineTopicExpression");
                        }
                    }
                    isSimpleReference(e1) {
                        switch(e1.type){
                            case "MemberExpression":
                                return !e1.computed && this.isSimpleReference(e1.object);
                            case "Identifier":
                                return !0;
                            default:
                                return !1;
                        }
                    }
                    checkSmartPipeTopicBodyEarlyErrors(e1) {
                        if (this.match(19)) throw this.raise(g.PipelineBodyNoArrow, {
                            at: this.state.startLoc
                        });
                        this.topicReferenceWasUsedInCurrentContext() || this.raise(g.PipelineTopicUnused, {
                            at: e1
                        });
                    }
                    withTopicBindingContext(e1) {
                        const t = this.state.topicContext;
                        this.state.topicContext = {
                            maxNumOfResolvableTopics: 1,
                            maxTopicIndex: null
                        };
                        try {
                            return e1();
                        } finally{
                            this.state.topicContext = t;
                        }
                    }
                    withSmartMixTopicForbiddingContext(e1) {
                        if (!this.hasPlugin([
                            "pipelineOperator",
                            {
                                proposal: "smart"
                            }
                        ])) return e1();
                        {
                            const t = this.state.topicContext;
                            this.state.topicContext = {
                                maxNumOfResolvableTopics: 0,
                                maxTopicIndex: null
                            };
                            try {
                                return e1();
                            } finally{
                                this.state.topicContext = t;
                            }
                        }
                    }
                    withSoloAwaitPermittingContext(e1) {
                        const t = this.state.soloAwait;
                        this.state.soloAwait = !0;
                        try {
                            return e1();
                        } finally{
                            this.state.soloAwait = t;
                        }
                    }
                    allowInAnd(e1) {
                        const t = this.prodParam.currentFlags();
                        if (8 & ~t) {
                            this.prodParam.enter(8 | t);
                            try {
                                return e1();
                            } finally{
                                this.prodParam.exit();
                            }
                        }
                        return e1();
                    }
                    disallowInAnd(e1) {
                        const t = this.prodParam.currentFlags();
                        if (8 & t) {
                            this.prodParam.enter(-9 & t);
                            try {
                                return e1();
                            } finally{
                                this.prodParam.exit();
                            }
                        }
                        return e1();
                    }
                    registerTopicReference() {
                        this.state.topicContext.maxTopicIndex = 0;
                    }
                    topicReferenceIsAllowedInCurrentContext() {
                        return this.state.topicContext.maxNumOfResolvableTopics >= 1;
                    }
                    topicReferenceWasUsedInCurrentContext() {
                        return null != this.state.topicContext.maxTopicIndex && this.state.topicContext.maxTopicIndex >= 0;
                    }
                    parseFSharpPipelineBody(e1) {
                        const t = this.state.startLoc;
                        this.state.potentialArrowAt = this.state.start;
                        const n = this.state.inFSharpPipelineDirectBody;
                        this.state.inFSharpPipelineDirectBody = !0;
                        const r = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), t, e1);
                        return this.state.inFSharpPipelineDirectBody = n, r;
                    }
                    parseModuleExpression() {
                        this.expectPlugin("moduleBlocks");
                        const e1 = this.startNode();
                        this.next(), this.match(5) || this.unexpected(null, 5);
                        const t = this.startNodeAt(this.state.endLoc);
                        this.next();
                        const n = this.initializeScopes(!0);
                        this.enterInitialScopes();
                        try {
                            e1.body = this.parseProgram(t, 8, "module");
                        } finally{
                            n();
                        }
                        return this.finishNode(e1, "ModuleExpression");
                    }
                    parsePropertyNamePrefixOperator(e1) {}
                }
                const Rt = {
                    kind: "loop"
                }, Ut = {
                    kind: "switch"
                }, Vt = /[\uD800-\uDFFF]/u, Kt = /in(?:stanceof)?/y;
                class Wt extends jt {
                    parseTopLevel(e1, t) {
                        return e1.program = this.parseProgram(t), e1.comments = this.state.comments, this.options.tokens && (e1.tokens = function(e1, t) {
                            for(let n = 0; n < e1.length; n++){
                                const r = e1[n], { type: i } = r;
                                if ("number" == typeof i) {
                                    if (136 === i) {
                                        const { loc: t, start: i, value: a, end: o } = r, l = i + 1, c = s(t.start, 1);
                                        e1.splice(n, 1, new qe({
                                            type: Q(27),
                                            value: "#",
                                            start: i,
                                            end: l,
                                            startLoc: t.start,
                                            endLoc: c
                                        }), new qe({
                                            type: Q(130),
                                            value: a,
                                            start: l,
                                            end: o,
                                            startLoc: c,
                                            endLoc: t.end
                                        })), n++;
                                        continue;
                                    }
                                    if (z(i)) {
                                        const { loc: a, start: o, value: l, end: c } = r, u = o + 1, p = s(a.start, 1);
                                        let h, d, f, y, m;
                                        h = 96 === t.charCodeAt(o) ? new qe({
                                            type: Q(22),
                                            value: "`",
                                            start: o,
                                            end: u,
                                            startLoc: a.start,
                                            endLoc: p
                                        }) : new qe({
                                            type: Q(8),
                                            value: "}",
                                            start: o,
                                            end: u,
                                            startLoc: a.start,
                                            endLoc: p
                                        }), 24 === i ? (f = c - 1, y = s(a.end, -1), d = null === l ? null : l.slice(1, -1), m = new qe({
                                            type: Q(22),
                                            value: "`",
                                            start: f,
                                            end: c,
                                            startLoc: y,
                                            endLoc: a.end
                                        })) : (f = c - 2, y = s(a.end, -2), d = null === l ? null : l.slice(1, -2), m = new qe({
                                            type: Q(23),
                                            value: "${",
                                            start: f,
                                            end: c,
                                            startLoc: y,
                                            endLoc: a.end
                                        })), e1.splice(n, 1, h, new qe({
                                            type: Q(20),
                                            value: d,
                                            start: u,
                                            end: f,
                                            startLoc: p,
                                            endLoc: y
                                        }), m), n += 2;
                                        continue;
                                    }
                                    r.type = Q(i);
                                }
                            }
                            return e1;
                        }(this.tokens, this.input)), this.finishNode(e1, "File");
                    }
                    parseProgram(e1, t = 137, n = this.options.sourceType) {
                        if (e1.sourceType = n, e1.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e1, !0, !0, t), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) for (const [e1, t] of Array.from(this.scope.undefinedExports))this.raise(g.ModuleExportUndefined, {
                            at: t,
                            localName: e1
                        });
                        let r;
                        return r = 137 === t ? this.finishNode(e1, "Program") : this.finishNodeAt(e1, "Program", s(this.state.startLoc, -1)), r;
                    }
                    stmtToDirective(e1) {
                        const t = e1;
                        t.type = "Directive", t.value = t.expression, delete t.expression;
                        const n = t.value, r = n.value, i = this.input.slice(n.start, n.end), s = n.value = i.slice(1, -1);
                        return this.addExtra(n, "raw", i), this.addExtra(n, "rawValue", s), this.addExtra(n, "expressionValue", r), n.type = "DirectiveLiteral", t;
                    }
                    parseInterpreterDirective() {
                        if (!this.match(28)) return null;
                        const e1 = this.startNode();
                        return e1.value = this.state.value, this.next(), this.finishNode(e1, "InterpreterDirective");
                    }
                    isLet() {
                        return !!this.isContextual(99) && this.hasFollowingBindingAtom();
                    }
                    chStartsBindingIdentifier(e1, t) {
                        if (ae(e1)) {
                            if (Kt.lastIndex = t, Kt.test(this.input)) {
                                const e1 = this.codePointAtPos(Kt.lastIndex);
                                if (!oe(e1) && 92 !== e1) return !1;
                            }
                            return !0;
                        }
                        return 92 === e1;
                    }
                    chStartsBindingPattern(e1) {
                        return 91 === e1 || 123 === e1;
                    }
                    hasFollowingBindingAtom() {
                        const e1 = this.nextTokenStart(), t = this.codePointAtPos(e1);
                        return this.chStartsBindingPattern(t) || this.chStartsBindingIdentifier(t, e1);
                    }
                    hasInLineFollowingBindingIdentifier() {
                        const e1 = this.nextTokenInLineStart(), t = this.codePointAtPos(e1);
                        return this.chStartsBindingIdentifier(t, e1);
                    }
                    startsUsingForOf() {
                        const { type: e1, containsEsc: t } = this.lookahead();
                        return !(101 === e1 && !t) && (W(e1) && !this.hasFollowingLineBreak() ? (this.expectPlugin("explicitResourceManagement"), !0) : void 0);
                    }
                    startsAwaitUsing() {
                        let e1 = this.nextTokenInLineStart();
                        if (this.isUnparsedContextual(e1, "using")) {
                            e1 = this.nextTokenInLineStartSince(e1 + 5);
                            const t = this.codePointAtPos(e1);
                            if (this.chStartsBindingIdentifier(t, e1)) return this.expectPlugin("explicitResourceManagement"), !0;
                        }
                        return !1;
                    }
                    parseModuleItem() {
                        return this.parseStatementLike(15);
                    }
                    parseStatementListItem() {
                        return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
                    }
                    parseStatementOrSloppyAnnexBFunctionDeclaration(e1 = !1) {
                        let t = 0;
                        return this.options.annexB && !this.state.strict && (t |= 4, e1 && (t |= 8)), this.parseStatementLike(t);
                    }
                    parseStatement() {
                        return this.parseStatementLike(0);
                    }
                    parseStatementLike(e1) {
                        let t = null;
                        return this.match(26) && (t = this.parseDecorators(!0)), this.parseStatementContent(e1, t);
                    }
                    parseStatementContent(e1, t) {
                        const n = this.state.type, r = this.startNode(), i = !!(2 & e1), s = !!(4 & e1), a = 1 & e1;
                        switch(n){
                            case 60:
                                return this.parseBreakContinueStatement(r, !0);
                            case 63:
                                return this.parseBreakContinueStatement(r, !1);
                            case 64:
                                return this.parseDebuggerStatement(r);
                            case 90:
                                return this.parseDoWhileStatement(r);
                            case 91:
                                return this.parseForStatement(r);
                            case 68:
                                if (46 === this.lookaheadCharCode()) break;
                                return s || this.raise(this.state.strict ? g.StrictFunction : this.options.annexB ? g.SloppyFunctionAnnexB : g.SloppyFunction, {
                                    at: this.state.startLoc
                                }), this.parseFunctionStatement(r, !1, !i && s);
                            case 80:
                                return i || this.unexpected(), this.parseClass(this.maybeTakeDecorators(t, r), !0);
                            case 69:
                                return this.parseIfStatement(r);
                            case 70:
                                return this.parseReturnStatement(r);
                            case 71:
                                return this.parseSwitchStatement(r);
                            case 72:
                                return this.parseThrowStatement(r);
                            case 73:
                                return this.parseTryStatement(r);
                            case 96:
                                if (!this.state.containsEsc && this.startsAwaitUsing()) return this.isAwaitAllowed() ? i || this.raise(g.UnexpectedLexicalDeclaration, {
                                    at: r
                                }) : this.raise(g.AwaitUsingNotInAsyncContext, {
                                    at: r
                                }), this.next(), this.parseVarStatement(r, "await using");
                                break;
                            case 105:
                                if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier()) break;
                                return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(g.UnexpectedUsingDeclaration, {
                                    at: this.state.startLoc
                                }) : i || this.raise(g.UnexpectedLexicalDeclaration, {
                                    at: this.state.startLoc
                                }), this.parseVarStatement(r, "using");
                            case 99:
                                {
                                    if (this.state.containsEsc) break;
                                    const e1 = this.nextTokenStart(), t = this.codePointAtPos(e1);
                                    if (91 !== t) {
                                        if (!i && this.hasFollowingLineBreak()) break;
                                        if (!this.chStartsBindingIdentifier(t, e1) && 123 !== t) break;
                                    }
                                }
                            case 75:
                                i || this.raise(g.UnexpectedLexicalDeclaration, {
                                    at: this.state.startLoc
                                });
                            case 74:
                                {
                                    const e1 = this.state.value;
                                    return this.parseVarStatement(r, e1);
                                }
                            case 92:
                                return this.parseWhileStatement(r);
                            case 76:
                                return this.parseWithStatement(r);
                            case 5:
                                return this.parseBlock();
                            case 13:
                                return this.parseEmptyStatement(r);
                            case 83:
                                {
                                    const e1 = this.lookaheadCharCode();
                                    if (40 === e1 || 46 === e1) break;
                                }
                            case 82:
                                {
                                    let e1;
                                    return this.options.allowImportExportEverywhere || a || this.raise(g.UnexpectedImportExport, {
                                        at: this.state.startLoc
                                    }), this.next(), 83 === n ? (e1 = this.parseImport(r), "ImportDeclaration" !== e1.type || e1.importKind && "value" !== e1.importKind || (this.sawUnambiguousESM = !0)) : (e1 = this.parseExport(r, t), ("ExportNamedDeclaration" !== e1.type || e1.exportKind && "value" !== e1.exportKind) && ("ExportAllDeclaration" !== e1.type || e1.exportKind && "value" !== e1.exportKind) && "ExportDefaultDeclaration" !== e1.type || (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(e1), e1;
                                }
                            default:
                                if (this.isAsyncFunction()) return i || this.raise(g.AsyncFunctionInSingleStatementContext, {
                                    at: this.state.startLoc
                                }), this.next(), this.parseFunctionStatement(r, !0, !i && s);
                        }
                        const o = this.state.value, l = this.parseExpression();
                        return W(n) && "Identifier" === l.type && this.eat(14) ? this.parseLabeledStatement(r, o, l, e1) : this.parseExpressionStatement(r, l, t);
                    }
                    assertModuleNodeAllowed(e1) {
                        this.options.allowImportExportEverywhere || this.inModule || this.raise(g.ImportOutsideModule, {
                            at: e1
                        });
                    }
                    decoratorsEnabledBeforeExport() {
                        return !!this.hasPlugin("decorators-legacy") || this.hasPlugin("decorators") && !1 !== this.getPluginOption("decorators", "decoratorsBeforeExport");
                    }
                    maybeTakeDecorators(e1, t, n) {
                        return e1 && (t.decorators && t.decorators.length > 0 ? ("boolean" != typeof this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(g.DecoratorsBeforeAfterExport, {
                            at: t.decorators[0]
                        }), t.decorators.unshift(...e1)) : t.decorators = e1, this.resetStartLocationFromNode(t, e1[0]), n && this.resetStartLocationFromNode(n, t)), t;
                    }
                    canHaveLeadingDecorator() {
                        return this.match(80);
                    }
                    parseDecorators(e1) {
                        const t = [];
                        do {
                            t.push(this.parseDecorator());
                        }while (this.match(26))
                        if (this.match(82)) e1 || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(g.DecoratorExportClass, {
                            at: this.state.startLoc
                        });
                        else if (!this.canHaveLeadingDecorator()) throw this.raise(g.UnexpectedLeadingDecorator, {
                            at: this.state.startLoc
                        });
                        return t;
                    }
                    parseDecorator() {
                        this.expectOnePlugin([
                            "decorators",
                            "decorators-legacy"
                        ]);
                        const e1 = this.startNode();
                        if (this.next(), this.hasPlugin("decorators")) {
                            const t = this.state.startLoc;
                            let n;
                            if (this.match(10)) {
                                const t = this.state.startLoc;
                                this.next(), n = this.parseExpression(), this.expect(11), n = this.wrapParenthesis(t, n);
                                const r = this.state.startLoc;
                                e1.expression = this.parseMaybeDecoratorArguments(n), !1 === this.getPluginOption("decorators", "allowCallParenthesized") && e1.expression !== n && this.raise(g.DecoratorArgumentsOutsideParentheses, {
                                    at: r
                                });
                            } else {
                                for(n = this.parseIdentifier(!1); this.eat(16);){
                                    const e1 = this.startNodeAt(t);
                                    e1.object = n, this.match(136) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), e1.property = this.parsePrivateName()) : e1.property = this.parseIdentifier(!0), e1.computed = !1, n = this.finishNode(e1, "MemberExpression");
                                }
                                e1.expression = this.parseMaybeDecoratorArguments(n);
                            }
                        } else e1.expression = this.parseExprSubscripts();
                        return this.finishNode(e1, "Decorator");
                    }
                    parseMaybeDecoratorArguments(e1) {
                        if (this.eat(10)) {
                            const t = this.startNodeAtNode(e1);
                            return t.callee = e1, t.arguments = this.parseCallExpressionArguments(11, !1), this.toReferencedList(t.arguments), this.finishNode(t, "CallExpression");
                        }
                        return e1;
                    }
                    parseBreakContinueStatement(e1, t) {
                        return this.next(), this.isLineTerminator() ? e1.label = null : (e1.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(e1, t), this.finishNode(e1, t ? "BreakStatement" : "ContinueStatement");
                    }
                    verifyBreakContinue(e1, t) {
                        let n;
                        for(n = 0; n < this.state.labels.length; ++n){
                            const r = this.state.labels[n];
                            if (null == e1.label || r.name === e1.label.name) {
                                if (null != r.kind && (t || "loop" === r.kind)) break;
                                if (e1.label && t) break;
                            }
                        }
                        if (n === this.state.labels.length) {
                            const n = t ? "BreakStatement" : "ContinueStatement";
                            this.raise(g.IllegalBreakContinue, {
                                at: e1,
                                type: n
                            });
                        }
                    }
                    parseDebuggerStatement(e1) {
                        return this.next(), this.semicolon(), this.finishNode(e1, "DebuggerStatement");
                    }
                    parseHeaderExpression() {
                        this.expect(10);
                        const e1 = this.parseExpression();
                        return this.expect(11), e1;
                    }
                    parseDoWhileStatement(e1) {
                        return this.next(), this.state.labels.push(Rt), e1.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement()), this.state.labels.pop(), this.expect(92), e1.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(e1, "DoWhileStatement");
                    }
                    parseForStatement(e1) {
                        this.next(), this.state.labels.push(Rt);
                        let t = null;
                        if (this.isAwaitAllowed() && this.eatContextual(96) && (t = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(13)) return null !== t && this.unexpected(t), this.parseFor(e1, null);
                        const n = this.isContextual(99);
                        {
                            const r = this.isContextual(96) && this.startsAwaitUsing(), i = r || this.isContextual(105) && this.startsUsingForOf(), s = n && this.hasFollowingBindingAtom() || i;
                            if (this.match(74) || this.match(75) || s) {
                                const n = this.startNode();
                                let s;
                                r ? (s = "await using", this.isAwaitAllowed() || this.raise(g.AwaitUsingNotInAsyncContext, {
                                    at: this.state.startLoc
                                }), this.next()) : s = this.state.value, this.next(), this.parseVar(n, !0, s);
                                const a = this.finishNode(n, "VariableDeclaration"), o = this.match(58);
                                return o && i && this.raise(g.ForInUsing, {
                                    at: a
                                }), (o || this.isContextual(101)) && 1 === a.declarations.length ? this.parseForIn(e1, a, t) : (null !== t && this.unexpected(t), this.parseFor(e1, a));
                            }
                        }
                        const r = this.isContextual(95), i = new rt, s = this.parseExpression(!0, i), a = this.isContextual(101);
                        if (a && (n && this.raise(g.ForOfLet, {
                            at: s
                        }), null === t && r && "Identifier" === s.type && this.raise(g.ForOfAsync, {
                            at: s
                        })), a || this.match(58)) {
                            this.checkDestructuringPrivate(i), this.toAssignable(s, !0);
                            const n = a ? "ForOfStatement" : "ForInStatement";
                            return this.checkLVal(s, {
                                in: {
                                    type: n
                                }
                            }), this.parseForIn(e1, s, t);
                        }
                        return this.checkExpressionErrors(i, !0), null !== t && this.unexpected(t), this.parseFor(e1, s);
                    }
                    parseFunctionStatement(e1, t, n) {
                        return this.next(), this.parseFunction(e1, 1 | (n ? 2 : 0) | (t ? 8 : 0));
                    }
                    parseIfStatement(e1) {
                        return this.next(), e1.test = this.parseHeaderExpression(), e1.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), e1.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(e1, "IfStatement");
                    }
                    parseReturnStatement(e1) {
                        return this.prodParam.hasReturn || this.options.allowReturnOutsideFunction || this.raise(g.IllegalReturn, {
                            at: this.state.startLoc
                        }), this.next(), this.isLineTerminator() ? e1.argument = null : (e1.argument = this.parseExpression(), this.semicolon()), this.finishNode(e1, "ReturnStatement");
                    }
                    parseSwitchStatement(e1) {
                        this.next(), e1.discriminant = this.parseHeaderExpression();
                        const t = e1.cases = [];
                        let n;
                        this.expect(5), this.state.labels.push(Ut), this.scope.enter(0);
                        for(let e1; !this.match(8);)if (this.match(61) || this.match(65)) {
                            const r = this.match(61);
                            n && this.finishNode(n, "SwitchCase"), t.push(n = this.startNode()), n.consequent = [], this.next(), r ? n.test = this.parseExpression() : (e1 && this.raise(g.MultipleDefaultsInSwitch, {
                                at: this.state.lastTokStartLoc
                            }), e1 = !0, n.test = null), this.expect(14);
                        } else n ? n.consequent.push(this.parseStatementListItem()) : this.unexpected();
                        return this.scope.exit(), n && this.finishNode(n, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e1, "SwitchStatement");
                    }
                    parseThrowStatement(e1) {
                        return this.next(), this.hasPrecedingLineBreak() && this.raise(g.NewlineAfterThrow, {
                            at: this.state.lastTokEndLoc
                        }), e1.argument = this.parseExpression(), this.semicolon(), this.finishNode(e1, "ThrowStatement");
                    }
                    parseCatchClauseParam() {
                        const e1 = this.parseBindingAtom();
                        return this.scope.enter(this.options.annexB && "Identifier" === e1.type ? 8 : 0), this.checkLVal(e1, {
                            in: {
                                type: "CatchClause"
                            },
                            binding: 9
                        }), e1;
                    }
                    parseTryStatement(e1) {
                        if (this.next(), e1.block = this.parseBlock(), e1.handler = null, this.match(62)) {
                            const t = this.startNode();
                            this.next(), this.match(10) ? (this.expect(10), t.param = this.parseCatchClauseParam(), this.expect(11)) : (t.param = null, this.scope.enter(0)), t.body = this.withSmartMixTopicForbiddingContext(()=>this.parseBlock(!1, !1)), this.scope.exit(), e1.handler = this.finishNode(t, "CatchClause");
                        }
                        return e1.finalizer = this.eat(67) ? this.parseBlock() : null, e1.handler || e1.finalizer || this.raise(g.NoCatchOrFinally, {
                            at: e1
                        }), this.finishNode(e1, "TryStatement");
                    }
                    parseVarStatement(e1, t, n = !1) {
                        return this.next(), this.parseVar(e1, !1, t, n), this.semicolon(), this.finishNode(e1, "VariableDeclaration");
                    }
                    parseWhileStatement(e1) {
                        return this.next(), e1.test = this.parseHeaderExpression(), this.state.labels.push(Rt), e1.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement()), this.state.labels.pop(), this.finishNode(e1, "WhileStatement");
                    }
                    parseWithStatement(e1) {
                        return this.state.strict && this.raise(g.StrictWith, {
                            at: this.state.startLoc
                        }), this.next(), e1.object = this.parseHeaderExpression(), e1.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement()), this.finishNode(e1, "WithStatement");
                    }
                    parseEmptyStatement(e1) {
                        return this.next(), this.finishNode(e1, "EmptyStatement");
                    }
                    parseLabeledStatement(e1, t, n, r) {
                        for (const e1 of this.state.labels)e1.name === t && this.raise(g.LabelRedeclaration, {
                            at: n,
                            labelName: t
                        });
                        const i = (s = this.state.type) >= 90 && s <= 92 ? "loop" : this.match(71) ? "switch" : null;
                        var s;
                        for(let t = this.state.labels.length - 1; t >= 0; t--){
                            const n = this.state.labels[t];
                            if (n.statementStart !== e1.start) break;
                            n.statementStart = this.state.start, n.kind = i;
                        }
                        return this.state.labels.push({
                            name: t,
                            kind: i,
                            statementStart: this.state.start
                        }), e1.body = 8 & r ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), e1.label = n, this.finishNode(e1, "LabeledStatement");
                    }
                    parseExpressionStatement(e1, t, n) {
                        return e1.expression = t, this.semicolon(), this.finishNode(e1, "ExpressionStatement");
                    }
                    parseBlock(e1 = !1, t = !0, n) {
                        const r = this.startNode();
                        return e1 && this.state.strictErrors.clear(), this.expect(5), t && this.scope.enter(0), this.parseBlockBody(r, e1, !1, 8, n), t && this.scope.exit(), this.finishNode(r, "BlockStatement");
                    }
                    isValidDirective(e1) {
                        return "ExpressionStatement" === e1.type && "StringLiteral" === e1.expression.type && !e1.expression.extra.parenthesized;
                    }
                    parseBlockBody(e1, t, n, r, i) {
                        const s = e1.body = [], a = e1.directives = [];
                        this.parseBlockOrModuleBlockBody(s, t ? a : void 0, n, r, i);
                    }
                    parseBlockOrModuleBlockBody(e1, t, n, r, i) {
                        const s = this.state.strict;
                        let a = !1, o = !1;
                        for(; !this.match(r);){
                            const r = n ? this.parseModuleItem() : this.parseStatementListItem();
                            if (t && !o) {
                                if (this.isValidDirective(r)) {
                                    const e1 = this.stmtToDirective(r);
                                    t.push(e1), a || "use strict" !== e1.value.value || (a = !0, this.setStrict(!0));
                                    continue;
                                }
                                o = !0, this.state.strictErrors.clear();
                            }
                            e1.push(r);
                        }
                        null == i || i.call(this, a), s || this.setStrict(!1), this.next();
                    }
                    parseFor(e1, t) {
                        return e1.init = t, this.semicolon(!1), e1.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), e1.update = this.match(11) ? null : this.parseExpression(), this.expect(11), e1.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(e1, "ForStatement");
                    }
                    parseForIn(e1, t, n) {
                        const r = this.match(58);
                        return this.next(), r ? null !== n && this.unexpected(n) : e1.await = null !== n, "VariableDeclaration" !== t.type || null == t.declarations[0].init || r && this.options.annexB && !this.state.strict && "var" === t.kind && "Identifier" === t.declarations[0].id.type || this.raise(g.ForInOfLoopInitializer, {
                            at: t,
                            type: r ? "ForInStatement" : "ForOfStatement"
                        }), "AssignmentPattern" === t.type && this.raise(g.InvalidLhs, {
                            at: t,
                            ancestor: {
                                type: "ForStatement"
                            }
                        }), e1.left = t, e1.right = r ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), e1.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(e1, r ? "ForInStatement" : "ForOfStatement");
                    }
                    parseVar(e1, t, n, r = !1) {
                        const i = e1.declarations = [];
                        for(e1.kind = n;;){
                            const e1 = this.startNode();
                            if (this.parseVarId(e1, n), e1.init = this.eat(29) ? t ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, null !== e1.init || r || ("Identifier" === e1.id.type || t && (this.match(58) || this.isContextual(101)) ? "const" !== n || this.match(58) || this.isContextual(101) || this.raise(g.DeclarationMissingInitializer, {
                                at: this.state.lastTokEndLoc,
                                kind: "const"
                            }) : this.raise(g.DeclarationMissingInitializer, {
                                at: this.state.lastTokEndLoc,
                                kind: "destructuring"
                            })), i.push(this.finishNode(e1, "VariableDeclarator")), !this.eat(12)) break;
                        }
                        return e1;
                    }
                    parseVarId(e1, t) {
                        const n = this.parseBindingAtom();
                        this.checkLVal(n, {
                            in: {
                                type: "VariableDeclarator"
                            },
                            binding: "var" === t ? 5 : 8201
                        }), e1.id = n;
                    }
                    parseAsyncFunctionExpression(e1) {
                        return this.parseFunction(e1, 8);
                    }
                    parseFunction(e1, t = 0) {
                        const n = 2 & t, r = !!(1 & t), i = r && !(4 & t), s = !!(8 & t);
                        this.initFunction(e1, s), this.match(55) && (n && this.raise(g.GeneratorInSingleStatementContext, {
                            at: this.state.startLoc
                        }), this.next(), e1.generator = !0), r && (e1.id = this.parseFunctionId(i));
                        const a = this.state.maybeInArrowParameters;
                        return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(tt(s, e1.generator)), r || (e1.id = this.parseFunctionId()), this.parseFunctionParams(e1, !1), this.withSmartMixTopicForbiddingContext(()=>{
                            this.parseFunctionBodyAndFinish(e1, r ? "FunctionDeclaration" : "FunctionExpression");
                        }), this.prodParam.exit(), this.scope.exit(), r && !n && this.registerFunctionStatementId(e1), this.state.maybeInArrowParameters = a, e1;
                    }
                    parseFunctionId(e1) {
                        return e1 || W(this.state.type) ? this.parseIdentifier() : null;
                    }
                    parseFunctionParams(e1, t) {
                        this.expect(10), this.expressionScope.enter(new Ge(3)), e1.params = this.parseBindingList(11, 41, 2 | (t ? 4 : 0)), this.expressionScope.exit();
                    }
                    registerFunctionStatementId(e1) {
                        e1.id && this.scope.declareName(e1.id.name, !this.options.annexB || this.state.strict || e1.generator || e1.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, e1.id.loc.start);
                    }
                    parseClass(e1, t, n) {
                        this.next();
                        const r = this.state.strict;
                        return this.state.strict = !0, this.parseClassId(e1, t, n), this.parseClassSuper(e1), e1.body = this.parseClassBody(!!e1.superClass, r), this.finishNode(e1, t ? "ClassDeclaration" : "ClassExpression");
                    }
                    isClassProperty() {
                        return this.match(29) || this.match(13) || this.match(8);
                    }
                    isClassMethod() {
                        return this.match(10);
                    }
                    isNonstaticConstructor(e1) {
                        return !(e1.computed || e1.static || "constructor" !== e1.key.name && "constructor" !== e1.key.value);
                    }
                    parseClassBody(e1, t) {
                        this.classScope.enter();
                        const n = {
                            hadConstructor: !1,
                            hadSuperClass: e1
                        };
                        let r = [];
                        const i = this.startNode();
                        if (i.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(()=>{
                            for(; !this.match(8);){
                                if (this.eat(13)) {
                                    if (r.length > 0) throw this.raise(g.DecoratorSemicolon, {
                                        at: this.state.lastTokEndLoc
                                    });
                                    continue;
                                }
                                if (this.match(26)) {
                                    r.push(this.parseDecorator());
                                    continue;
                                }
                                const e1 = this.startNode();
                                r.length && (e1.decorators = r, this.resetStartLocationFromNode(e1, r[0]), r = []), this.parseClassMember(i, e1, n), "constructor" === e1.kind && e1.decorators && e1.decorators.length > 0 && this.raise(g.DecoratorConstructor, {
                                    at: e1
                                });
                            }
                        }), this.state.strict = t, this.next(), r.length) throw this.raise(g.TrailingDecorator, {
                            at: this.state.startLoc
                        });
                        return this.classScope.exit(), this.finishNode(i, "ClassBody");
                    }
                    parseClassMemberFromModifier(e1, t) {
                        const n = this.parseIdentifier(!0);
                        if (this.isClassMethod()) {
                            const r = t;
                            return r.kind = "method", r.computed = !1, r.key = n, r.static = !1, this.pushClassMethod(e1, r, !1, !1, !1, !1), !0;
                        }
                        if (this.isClassProperty()) {
                            const r = t;
                            return r.computed = !1, r.key = n, r.static = !1, e1.body.push(this.parseClassProperty(r)), !0;
                        }
                        return this.resetPreviousNodeTrailingComments(n), !1;
                    }
                    parseClassMember(e1, t, n) {
                        const r = this.isContextual(104);
                        if (r) {
                            if (this.parseClassMemberFromModifier(e1, t)) return;
                            if (this.eat(5)) return void this.parseClassStaticBlock(e1, t);
                        }
                        this.parseClassMemberWithIsStatic(e1, t, n, r);
                    }
                    parseClassMemberWithIsStatic(e1, t, n, r) {
                        const i = t, s = t, a = t, o = t, l = t, c = i, u = i;
                        if (t.static = r, this.parsePropertyNamePrefixOperator(t), this.eat(55)) {
                            c.kind = "method";
                            const t = this.match(136);
                            return this.parseClassElementName(c), t ? void this.pushClassPrivateMethod(e1, s, !0, !1) : (this.isNonstaticConstructor(i) && this.raise(g.ConstructorIsGenerator, {
                                at: i.key
                            }), void this.pushClassMethod(e1, i, !0, !1, !1, !1));
                        }
                        const p = W(this.state.type) && !this.state.containsEsc, h = this.match(136), d = this.parseClassElementName(t), f = this.state.startLoc;
                        if (this.parsePostMemberNameModifiers(u), this.isClassMethod()) {
                            if (c.kind = "method", h) return void this.pushClassPrivateMethod(e1, s, !1, !1);
                            const r = this.isNonstaticConstructor(i);
                            let a = !1;
                            r && (i.kind = "constructor", n.hadConstructor && !this.hasPlugin("typescript") && this.raise(g.DuplicateConstructor, {
                                at: d
                            }), r && this.hasPlugin("typescript") && t.override && this.raise(g.OverrideOnConstructor, {
                                at: d
                            }), n.hadConstructor = !0, a = n.hadSuperClass), this.pushClassMethod(e1, i, !1, !1, r, a);
                        } else if (this.isClassProperty()) h ? this.pushClassPrivateProperty(e1, o) : this.pushClassProperty(e1, a);
                        else if (p && "async" === d.name && !this.isLineTerminator()) {
                            this.resetPreviousNodeTrailingComments(d);
                            const t = this.eat(55);
                            u.optional && this.unexpected(f), c.kind = "method";
                            const n = this.match(136);
                            this.parseClassElementName(c), this.parsePostMemberNameModifiers(u), n ? this.pushClassPrivateMethod(e1, s, t, !0) : (this.isNonstaticConstructor(i) && this.raise(g.ConstructorIsAsync, {
                                at: i.key
                            }), this.pushClassMethod(e1, i, t, !0, !1, !1));
                        } else if (!p || "get" !== d.name && "set" !== d.name || this.match(55) && this.isLineTerminator()) if (p && "accessor" === d.name && !this.isLineTerminator()) {
                            this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(d);
                            const t = this.match(136);
                            this.parseClassElementName(a), this.pushClassAccessorProperty(e1, l, t);
                        } else this.isLineTerminator() ? h ? this.pushClassPrivateProperty(e1, o) : this.pushClassProperty(e1, a) : this.unexpected();
                        else {
                            this.resetPreviousNodeTrailingComments(d), c.kind = d.name;
                            const t = this.match(136);
                            this.parseClassElementName(i), t ? this.pushClassPrivateMethod(e1, s, !1, !1) : (this.isNonstaticConstructor(i) && this.raise(g.ConstructorIsAccessor, {
                                at: i.key
                            }), this.pushClassMethod(e1, i, !1, !1, !1, !1)), this.checkGetterSetterParams(i);
                        }
                    }
                    parseClassElementName(e1) {
                        const { type: t, value: n } = this.state;
                        if (130 !== t && 131 !== t || !e1.static || "prototype" !== n || this.raise(g.StaticPrototype, {
                            at: this.state.startLoc
                        }), 136 === t) {
                            "constructor" === n && this.raise(g.ConstructorClassPrivateField, {
                                at: this.state.startLoc
                            });
                            const t = this.parsePrivateName();
                            return e1.key = t, t;
                        }
                        return this.parsePropertyName(e1);
                    }
                    parseClassStaticBlock(e1, t) {
                        var n;
                        this.scope.enter(208);
                        const r = this.state.labels;
                        this.state.labels = [], this.prodParam.enter(0);
                        const i = t.body = [];
                        this.parseBlockOrModuleBlockBody(i, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = r, e1.body.push(this.finishNode(t, "StaticBlock")), null != (n = t.decorators) && n.length && this.raise(g.DecoratorStaticBlock, {
                            at: t
                        });
                    }
                    pushClassProperty(e1, t) {
                        t.computed || "constructor" !== t.key.name && "constructor" !== t.key.value || this.raise(g.ConstructorClassField, {
                            at: t.key
                        }), e1.body.push(this.parseClassProperty(t));
                    }
                    pushClassPrivateProperty(e1, t) {
                        const n = this.parseClassPrivateProperty(t);
                        e1.body.push(n), this.classScope.declarePrivateName(this.getPrivateNameSV(n.key), 0, n.key.loc.start);
                    }
                    pushClassAccessorProperty(e1, t, n) {
                        if (!n && !t.computed) {
                            const e1 = t.key;
                            "constructor" !== e1.name && "constructor" !== e1.value || this.raise(g.ConstructorClassField, {
                                at: e1
                            });
                        }
                        const r = this.parseClassAccessorProperty(t);
                        e1.body.push(r), n && this.classScope.declarePrivateName(this.getPrivateNameSV(r.key), 0, r.key.loc.start);
                    }
                    pushClassMethod(e1, t, n, r, i, s) {
                        e1.body.push(this.parseMethod(t, n, r, i, s, "ClassMethod", !0));
                    }
                    pushClassPrivateMethod(e1, t, n, r) {
                        const i = this.parseMethod(t, n, r, !1, !1, "ClassPrivateMethod", !0);
                        e1.body.push(i);
                        const s = "get" === i.kind ? i.static ? 6 : 2 : "set" === i.kind ? i.static ? 5 : 1 : 0;
                        this.declareClassPrivateMethodInScope(i, s);
                    }
                    declareClassPrivateMethodInScope(e1, t) {
                        this.classScope.declarePrivateName(this.getPrivateNameSV(e1.key), t, e1.key.loc.start);
                    }
                    parsePostMemberNameModifiers(e1) {}
                    parseClassPrivateProperty(e1) {
                        return this.parseInitializer(e1), this.semicolon(), this.finishNode(e1, "ClassPrivateProperty");
                    }
                    parseClassProperty(e1) {
                        return this.parseInitializer(e1), this.semicolon(), this.finishNode(e1, "ClassProperty");
                    }
                    parseClassAccessorProperty(e1) {
                        return this.parseInitializer(e1), this.semicolon(), this.finishNode(e1, "ClassAccessorProperty");
                    }
                    parseInitializer(e1) {
                        this.scope.enter(80), this.expressionScope.enter(Ze()), this.prodParam.enter(0), e1.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
                    }
                    parseClassId(e1, t, n, r = 8331) {
                        if (W(this.state.type)) e1.id = this.parseIdentifier(), t && this.declareNameFromIdentifier(e1.id, r);
                        else {
                            if (!n && t) throw this.raise(g.MissingClassName, {
                                at: this.state.startLoc
                            });
                            e1.id = null;
                        }
                    }
                    parseClassSuper(e1) {
                        e1.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
                    }
                    parseExport(e1, t) {
                        const n = this.parseMaybeImportPhase(e1, !0), r = this.maybeParseExportDefaultSpecifier(e1, n), i = !r || this.eat(12), s = i && this.eatExportStar(e1), a = s && this.maybeParseExportNamespaceSpecifier(e1), o = i && (!a || this.eat(12)), l = r || s;
                        if (s && !a) {
                            if (r && this.unexpected(), t) throw this.raise(g.UnsupportedDecoratorExport, {
                                at: e1
                            });
                            return this.parseExportFrom(e1, !0), this.finishNode(e1, "ExportAllDeclaration");
                        }
                        const c = this.maybeParseExportNamedSpecifiers(e1);
                        let u;
                        if (r && i && !s && !c && this.unexpected(null, 5), a && o && this.unexpected(null, 97), l || c) {
                            if (u = !1, t) throw this.raise(g.UnsupportedDecoratorExport, {
                                at: e1
                            });
                            this.parseExportFrom(e1, l);
                        } else u = this.maybeParseExportDeclaration(e1);
                        if (l || c || u) {
                            var p;
                            const n = e1;
                            if (this.checkExport(n, !0, !1, !!n.source), "ClassDeclaration" === (null == (p = n.declaration) ? void 0 : p.type)) this.maybeTakeDecorators(t, n.declaration, n);
                            else if (t) throw this.raise(g.UnsupportedDecoratorExport, {
                                at: e1
                            });
                            return this.finishNode(n, "ExportNamedDeclaration");
                        }
                        if (this.eat(65)) {
                            const n = e1, r = this.parseExportDefaultExpression();
                            if (n.declaration = r, "ClassDeclaration" === r.type) this.maybeTakeDecorators(t, r, n);
                            else if (t) throw this.raise(g.UnsupportedDecoratorExport, {
                                at: e1
                            });
                            return this.checkExport(n, !0, !0), this.finishNode(n, "ExportDefaultDeclaration");
                        }
                        this.unexpected(null, 5);
                    }
                    eatExportStar(e1) {
                        return this.eat(55);
                    }
                    maybeParseExportDefaultSpecifier(e1, t) {
                        if (t || this.isExportDefaultSpecifier()) {
                            this.expectPlugin("exportDefaultFrom", null == t ? void 0 : t.loc.start);
                            const n = t || this.parseIdentifier(!0), r = this.startNodeAtNode(n);
                            return r.exported = n, e1.specifiers = [
                                this.finishNode(r, "ExportDefaultSpecifier")
                            ], !0;
                        }
                        return !1;
                    }
                    maybeParseExportNamespaceSpecifier(e1) {
                        if (this.isContextual(93)) {
                            e1.specifiers || (e1.specifiers = []);
                            const t = this.startNodeAt(this.state.lastTokStartLoc);
                            return this.next(), t.exported = this.parseModuleExportName(), e1.specifiers.push(this.finishNode(t, "ExportNamespaceSpecifier")), !0;
                        }
                        return !1;
                    }
                    maybeParseExportNamedSpecifiers(e1) {
                        if (this.match(5)) {
                            e1.specifiers || (e1.specifiers = []);
                            const t = "type" === e1.exportKind;
                            return e1.specifiers.push(...this.parseExportSpecifiers(t)), e1.source = null, e1.declaration = null, this.hasPlugin("importAssertions") && (e1.assertions = []), !0;
                        }
                        return !1;
                    }
                    maybeParseExportDeclaration(e1) {
                        return !!this.shouldParseExportDeclaration() && (e1.specifiers = [], e1.source = null, this.hasPlugin("importAssertions") && (e1.assertions = []), e1.declaration = this.parseExportDeclaration(e1), !0);
                    }
                    isAsyncFunction() {
                        if (!this.isContextual(95)) return !1;
                        const e1 = this.nextTokenInLineStart();
                        return this.isUnparsedContextual(e1, "function");
                    }
                    parseExportDefaultExpression() {
                        const e1 = this.startNode();
                        if (this.match(68)) return this.next(), this.parseFunction(e1, 5);
                        if (this.isAsyncFunction()) return this.next(), this.next(), this.parseFunction(e1, 13);
                        if (this.match(80)) return this.parseClass(e1, !0, !0);
                        if (this.match(26)) return this.hasPlugin("decorators") && !0 === this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(g.DecoratorBeforeExport, {
                            at: this.state.startLoc
                        }), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
                        if (this.match(75) || this.match(74) || this.isLet()) throw this.raise(g.UnsupportedDefaultExport, {
                            at: this.state.startLoc
                        });
                        const t = this.parseMaybeAssignAllowIn();
                        return this.semicolon(), t;
                    }
                    parseExportDeclaration(e1) {
                        return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
                    }
                    isExportDefaultSpecifier() {
                        const { type: e1 } = this.state;
                        if (W(e1)) {
                            if (95 === e1 && !this.state.containsEsc || 99 === e1) return !1;
                            if ((128 === e1 || 127 === e1) && !this.state.containsEsc) {
                                const { type: e1 } = this.lookahead();
                                if (W(e1) && 97 !== e1 || 5 === e1) return this.expectOnePlugin([
                                    "flow",
                                    "typescript"
                                ]), !1;
                            }
                        } else if (!this.match(65)) return !1;
                        const t = this.nextTokenStart(), n = this.isUnparsedContextual(t, "from");
                        if (44 === this.input.charCodeAt(t) || W(this.state.type) && n) return !0;
                        if (this.match(65) && n) {
                            const e1 = this.input.charCodeAt(this.nextTokenStartSince(t + 4));
                            return 34 === e1 || 39 === e1;
                        }
                        return !1;
                    }
                    parseExportFrom(e1, t) {
                        this.eatContextual(97) ? (e1.source = this.parseImportSource(), this.checkExport(e1), this.maybeParseImportAttributes(e1), this.checkJSONModuleImport(e1)) : t && this.unexpected(), this.semicolon();
                    }
                    shouldParseExportDeclaration() {
                        const { type: e1 } = this.state;
                        return 26 === e1 && (this.expectOnePlugin([
                            "decorators",
                            "decorators-legacy"
                        ]), this.hasPlugin("decorators")) ? (!0 === this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(g.DecoratorBeforeExport, {
                            at: this.state.startLoc
                        }), !0) : 74 === e1 || 75 === e1 || 68 === e1 || 80 === e1 || this.isLet() || this.isAsyncFunction();
                    }
                    checkExport(e1, t, n, r) {
                        var i;
                        if (t) {
                            if (n) {
                                if (this.checkDuplicateExports(e1, "default"), this.hasPlugin("exportDefaultFrom")) {
                                    var s;
                                    const t = e1.declaration;
                                    "Identifier" !== t.type || "from" !== t.name || t.end - t.start != 4 || null != (s = t.extra) && s.parenthesized || this.raise(g.ExportDefaultFromAsIdentifier, {
                                        at: t
                                    });
                                }
                            } else if (null != (i = e1.specifiers) && i.length) for (const t of e1.specifiers){
                                const { exported: e1 } = t, n = "Identifier" === e1.type ? e1.name : e1.value;
                                if (this.checkDuplicateExports(t, n), !r && t.local) {
                                    const { local: e1 } = t;
                                    "Identifier" !== e1.type ? this.raise(g.ExportBindingIsString, {
                                        at: t,
                                        localName: e1.value,
                                        exportName: n
                                    }) : (this.checkReservedWord(e1.name, e1.loc.start, !0, !1), this.scope.checkLocalExport(e1));
                                }
                            }
                            else if (e1.declaration) {
                                if ("FunctionDeclaration" === e1.declaration.type || "ClassDeclaration" === e1.declaration.type) {
                                    const t = e1.declaration.id;
                                    if (!t) throw new Error("Assertion failure");
                                    this.checkDuplicateExports(e1, t.name);
                                } else if ("VariableDeclaration" === e1.declaration.type) for (const t of e1.declaration.declarations)this.checkDeclaration(t.id);
                            }
                        }
                    }
                    checkDeclaration(e1) {
                        if ("Identifier" === e1.type) this.checkDuplicateExports(e1, e1.name);
                        else if ("ObjectPattern" === e1.type) for (const t of e1.properties)this.checkDeclaration(t);
                        else if ("ArrayPattern" === e1.type) for (const t of e1.elements)t && this.checkDeclaration(t);
                        else "ObjectProperty" === e1.type ? this.checkDeclaration(e1.value) : "RestElement" === e1.type ? this.checkDeclaration(e1.argument) : "AssignmentPattern" === e1.type && this.checkDeclaration(e1.left);
                    }
                    checkDuplicateExports(e1, t) {
                        this.exportedIdentifiers.has(t) && ("default" === t ? this.raise(g.DuplicateDefaultExport, {
                            at: e1
                        }) : this.raise(g.DuplicateExport, {
                            at: e1,
                            exportName: t
                        })), this.exportedIdentifiers.add(t);
                    }
                    parseExportSpecifiers(e1) {
                        const t = [];
                        let n = !0;
                        for(this.expect(5); !this.eat(8);){
                            if (n) n = !1;
                            else if (this.expect(12), this.eat(8)) break;
                            const r = this.isContextual(128), i = this.match(131), s = this.startNode();
                            s.local = this.parseModuleExportName(), t.push(this.parseExportSpecifier(s, i, e1, r));
                        }
                        return t;
                    }
                    parseExportSpecifier(e1, t, n, r) {
                        return this.eatContextual(93) ? e1.exported = this.parseModuleExportName() : t ? e1.exported = function(e1) {
                            const { type: t, start: n, end: r, loc: i, range: s, extra: a } = e1;
                            if ("Placeholder" === t) return function(e1) {
                                return at(e1);
                            }(e1);
                            const o = Object.create(st);
                            return o.type = t, o.start = n, o.end = r, o.loc = i, o.range = s, void 0 !== e1.raw ? o.raw = e1.raw : o.extra = a, o.value = e1.value, o;
                        }(e1.local) : e1.exported || (e1.exported = at(e1.local)), this.finishNode(e1, "ExportSpecifier");
                    }
                    parseModuleExportName() {
                        if (this.match(131)) {
                            const e1 = this.parseStringLiteral(this.state.value), t = e1.value.match(Vt);
                            return t && this.raise(g.ModuleExportNameHasLoneSurrogate, {
                                at: e1,
                                surrogateCharCode: t[0].charCodeAt(0)
                            }), e1;
                        }
                        return this.parseIdentifier(!0);
                    }
                    isJSONModuleImport(e1) {
                        return null != e1.assertions && e1.assertions.some(({ key: e1, value: t })=>"json" === t.value && ("Identifier" === e1.type ? "type" === e1.name : "type" === e1.value));
                    }
                    checkImportReflection(e1) {
                        var t;
                        e1.module && (1 === e1.specifiers.length && "ImportDefaultSpecifier" === e1.specifiers[0].type || this.raise(g.ImportReflectionNotBinding, {
                            at: e1.specifiers[0].loc.start
                        }), (null == (t = e1.assertions) ? void 0 : t.length) > 0 && this.raise(g.ImportReflectionHasAssertion, {
                            at: e1.specifiers[0].loc.start
                        }));
                    }
                    checkJSONModuleImport(e1) {
                        if (this.isJSONModuleImport(e1) && "ExportAllDeclaration" !== e1.type) {
                            const { specifiers: t } = e1;
                            if (null != t) {
                                const e1 = t.find((e1)=>{
                                    let t;
                                    if ("ExportSpecifier" === e1.type ? t = e1.local : "ImportSpecifier" === e1.type && (t = e1.imported), void 0 !== t) return "Identifier" === t.type ? "default" !== t.name : "default" !== t.value;
                                });
                                void 0 !== e1 && this.raise(g.ImportJSONBindingNotDefault, {
                                    at: e1.loc.start
                                });
                            }
                        }
                    }
                    isPotentialImportPhase(e1) {
                        return !e1 && this.isContextual(125);
                    }
                    applyImportPhase(e1, t, n, r) {
                        t || ("module" === n ? (this.expectPlugin("importReflection", r), e1.module = !0) : this.hasPlugin("importReflection") && (e1.module = !1));
                    }
                    parseMaybeImportPhase(e1, t) {
                        if (!this.isPotentialImportPhase(t)) return this.applyImportPhase(e1, t, null), null;
                        const n = this.parseIdentifier(!0), { type: r } = this.state;
                        return (X(r) ? 97 !== r || 102 === this.lookaheadCharCode() : 12 !== r) ? (this.resetPreviousIdentifierLeadingComments(n), this.applyImportPhase(e1, t, n.name, n.loc.start), null) : (this.applyImportPhase(e1, t, null), n);
                    }
                    isPrecedingIdImportPhase(e1) {
                        const { type: t } = this.state;
                        return W(t) ? 97 !== t || 102 === this.lookaheadCharCode() : 12 !== t;
                    }
                    parseImport(e1) {
                        return this.match(131) ? this.parseImportSourceAndAttributes(e1) : this.parseImportSpecifiersAndAfter(e1, this.parseMaybeImportPhase(e1, !1));
                    }
                    parseImportSpecifiersAndAfter(e1, t) {
                        e1.specifiers = [];
                        const n = !this.maybeParseDefaultImportSpecifier(e1, t) || this.eat(12), r = n && this.maybeParseStarImportSpecifier(e1);
                        return n && !r && this.parseNamedImportSpecifiers(e1), this.expectContextual(97), this.parseImportSourceAndAttributes(e1);
                    }
                    parseImportSourceAndAttributes(e1) {
                        return null != e1.specifiers || (e1.specifiers = []), e1.source = this.parseImportSource(), this.maybeParseImportAttributes(e1), this.checkImportReflection(e1), this.checkJSONModuleImport(e1), this.semicolon(), this.finishNode(e1, "ImportDeclaration");
                    }
                    parseImportSource() {
                        return this.match(131) || this.unexpected(), this.parseExprAtom();
                    }
                    parseImportSpecifierLocal(e1, t, n) {
                        t.local = this.parseIdentifier(), e1.specifiers.push(this.finishImportSpecifier(t, n));
                    }
                    finishImportSpecifier(e1, t, n = 8201) {
                        return this.checkLVal(e1.local, {
                            in: {
                                type: t
                            },
                            binding: n
                        }), this.finishNode(e1, t);
                    }
                    parseImportAttributes() {
                        this.expect(5);
                        const e1 = [], t = new Set;
                        do {
                            if (this.match(8)) break;
                            const n = this.startNode(), r = this.state.value;
                            if (t.has(r) && this.raise(g.ModuleAttributesWithDuplicateKeys, {
                                at: this.state.startLoc,
                                key: r
                            }), t.add(r), this.match(131) ? n.key = this.parseStringLiteral(r) : n.key = this.parseIdentifier(!0), this.expect(14), !this.match(131)) throw this.raise(g.ModuleAttributeInvalidValue, {
                                at: this.state.startLoc
                            });
                            n.value = this.parseStringLiteral(this.state.value), e1.push(this.finishNode(n, "ImportAttribute"));
                        }while (this.eat(12))
                        return this.expect(8), e1;
                    }
                    parseModuleAttributes() {
                        const e1 = [], t = new Set;
                        do {
                            const n = this.startNode();
                            if (n.key = this.parseIdentifier(!0), "type" !== n.key.name && this.raise(g.ModuleAttributeDifferentFromType, {
                                at: n.key
                            }), t.has(n.key.name) && this.raise(g.ModuleAttributesWithDuplicateKeys, {
                                at: n.key,
                                key: n.key.name
                            }), t.add(n.key.name), this.expect(14), !this.match(131)) throw this.raise(g.ModuleAttributeInvalidValue, {
                                at: this.state.startLoc
                            });
                            n.value = this.parseStringLiteral(this.state.value), e1.push(this.finishNode(n, "ImportAttribute"));
                        }while (this.eat(12))
                        return e1;
                    }
                    maybeParseImportAttributes(e1) {
                        let t, n = !1;
                        if (this.match(76)) {
                            if (this.hasPrecedingLineBreak() && 40 === this.lookaheadCharCode()) return;
                            this.next(), this.hasPlugin("moduleAttributes") ? t = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), t = this.parseImportAttributes()), n = !0;
                        } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) this.hasPlugin("importAttributes") ? (!0 !== this.getPluginOption("importAttributes", "deprecatedAssertSyntax") && this.raise(g.ImportAttributesUseAssert, {
                            at: this.state.startLoc
                        }), this.addExtra(e1, "deprecatedAssertSyntax", !0)) : this.expectOnePlugin([
                            "importAttributes",
                            "importAssertions"
                        ]), this.next(), t = this.parseImportAttributes();
                        else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) t = [];
                        else {
                            if (!this.hasPlugin("moduleAttributes")) return;
                            t = [];
                        }
                        !n && this.hasPlugin("importAssertions") ? e1.assertions = t : e1.attributes = t;
                    }
                    maybeParseDefaultImportSpecifier(e1, t) {
                        if (t) {
                            const n = this.startNodeAtNode(t);
                            return n.local = t, e1.specifiers.push(this.finishImportSpecifier(n, "ImportDefaultSpecifier")), !0;
                        }
                        return !!X(this.state.type) && (this.parseImportSpecifierLocal(e1, this.startNode(), "ImportDefaultSpecifier"), !0);
                    }
                    maybeParseStarImportSpecifier(e1) {
                        if (this.match(55)) {
                            const t = this.startNode();
                            return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e1, t, "ImportNamespaceSpecifier"), !0;
                        }
                        return !1;
                    }
                    parseNamedImportSpecifiers(e1) {
                        let t = !0;
                        for(this.expect(5); !this.eat(8);){
                            if (t) t = !1;
                            else {
                                if (this.eat(14)) throw this.raise(g.DestructureNamedImport, {
                                    at: this.state.startLoc
                                });
                                if (this.expect(12), this.eat(8)) break;
                            }
                            const n = this.startNode(), r = this.match(131), i = this.isContextual(128);
                            n.imported = this.parseModuleExportName();
                            const s = this.parseImportSpecifier(n, r, "type" === e1.importKind || "typeof" === e1.importKind, i, void 0);
                            e1.specifiers.push(s);
                        }
                    }
                    parseImportSpecifier(e1, t, n, r, i) {
                        if (this.eatContextual(93)) e1.local = this.parseIdentifier();
                        else {
                            const { imported: n } = e1;
                            if (t) throw this.raise(g.ImportBindingIsString, {
                                at: e1,
                                importName: n.value
                            });
                            this.checkReservedWord(n.name, e1.loc.start, !0, !0), e1.local || (e1.local = at(n));
                        }
                        return this.finishImportSpecifier(e1, "ImportSpecifier", i);
                    }
                    isThisParam(e1) {
                        return "Identifier" === e1.type && "this" === e1.name;
                    }
                }
                class Xt extends Wt {
                    constructor(e1, t){
                        super(e1 = function(e1) {
                            if (null == e1) return Object.assign({}, Bt);
                            if (null != e1.annexB && !1 !== e1.annexB) throw new Error("The `annexB` option can only be set to `false`.");
                            const t = {};
                            for (const r of Object.keys(Bt)){
                                var n;
                                t[r] = null != (n = e1[r]) ? n : Bt[r];
                            }
                            return t;
                        }(e1), t), this.options = e1, this.initializeScopes(), this.plugins = function(e1) {
                            const t = new Map;
                            for (const n of e1){
                                const [e1, r] = Array.isArray(n) ? n : [
                                    n,
                                    {}
                                ];
                                t.has(e1) || t.set(e1, r || {});
                            }
                            return t;
                        }(this.options.plugins), this.filename = e1.sourceFilename;
                    }
                    getScopeHandler() {
                        return Te;
                    }
                    parse() {
                        this.enterInitialScopes();
                        const e1 = this.startNode(), t = this.startNode();
                        return this.nextToken(), e1.errors = null, this.parseTopLevel(e1, t), e1.errors = this.state.errors, e1;
                    }
                }
                const Yt = function(e1) {
                    const t = {};
                    for (const n of Object.keys(e1))t[n] = Q(e1[n]);
                    return t;
                }(K);
                function qt(e1, t) {
                    let n = Xt;
                    return null != e1 && e1.plugins && (function(e1) {
                        if (It(e1, "decorators")) {
                            if (It(e1, "decorators-legacy")) throw new Error("Cannot use the decorators and decorators-legacy plugin together");
                            const t = Nt(e1, "decorators", "decoratorsBeforeExport");
                            if (null != t && "boolean" != typeof t) throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
                            const n = Nt(e1, "decorators", "allowCallParenthesized");
                            if (null != n && "boolean" != typeof n) throw new Error("'allowCallParenthesized' must be a boolean.");
                        }
                        if (It(e1, "flow") && It(e1, "typescript")) throw new Error("Cannot combine flow and typescript plugins.");
                        if (It(e1, "placeholders") && It(e1, "v8intrinsic")) throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
                        if (It(e1, "pipelineOperator")) {
                            const t = Nt(e1, "pipelineOperator", "proposal");
                            if (!Ft.includes(t)) {
                                const e1 = Ft.map((e1)=>`"${e1}"`).join(", ");
                                throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${e1}.`);
                            }
                            const n = It(e1, [
                                "recordAndTuple",
                                {
                                    syntaxType: "hash"
                                }
                            ]);
                            if ("hack" === t) {
                                if (It(e1, "placeholders")) throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
                                if (It(e1, "v8intrinsic")) throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
                                const t = Nt(e1, "pipelineOperator", "topicToken");
                                if (!kt.includes(t)) {
                                    const e1 = kt.map((e1)=>`"${e1}"`).join(", ");
                                    throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${e1}.`);
                                }
                                if ("#" === t && n) throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
                            } else if ("smart" === t && n) throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
                        }
                        if (It(e1, "moduleAttributes")) {
                            if (It(e1, "importAssertions") || It(e1, "importAttributes")) throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
                            if ("may-2020" !== Nt(e1, "moduleAttributes", "version")) throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
                        }
                        if (It(e1, "importAssertions") && It(e1, "importAttributes")) throw new Error("Cannot combine importAssertions and importAttributes plugins.");
                        if (It(e1, "recordAndTuple") && null != Nt(e1, "recordAndTuple", "syntaxType") && !Lt.includes(Nt(e1, "recordAndTuple", "syntaxType"))) throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + Lt.map((e1)=>`'${e1}'`).join(", "));
                        if (It(e1, "asyncDoExpressions") && !It(e1, "doExpressions")) {
                            const e1 = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
                            throw e1.missingPlugins = "doExpressions", e1;
                        }
                    }(e1.plugins), n = function(e1) {
                        const t = Mt.filter((t)=>It(e1, t)), n = t.join("/");
                        let r = Ht[n];
                        if (!r) {
                            r = Xt;
                            for (const e1 of t)r = _t[e1](r);
                            Ht[n] = r;
                        }
                        return r;
                    }(e1.plugins)), new n(e1, t);
                }
                const Ht = {};
                t.parse = function(e1, t) {
                    var n;
                    if ("unambiguous" !== (null == (n = t) ? void 0 : n.sourceType)) return qt(t, e1).parse();
                    t = Object.assign({}, t);
                    try {
                        t.sourceType = "module";
                        const n = qt(t, e1), r = n.parse();
                        if (n.sawUnambiguousESM) return r;
                        if (n.ambiguousScriptDifferentAst) try {
                            return t.sourceType = "script", qt(t, e1).parse();
                        } catch (e1) {}
                        else r.program.sourceType = "script";
                        return r;
                    } catch (n) {
                        try {
                            return t.sourceType = "script", qt(t, e1).parse();
                        } catch (e1) {}
                        throw n;
                    }
                }, t.parseExpression = function(e1, t) {
                    const n = qt(t, e1);
                    return n.options.strictMode && (n.state.strict = !0), n.getExpression();
                }, t.tokTypes = Yt;
            },
            97: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function e1(t, n) {
                    const l = new WeakMap, c = new WeakMap, u = n || (0, r.validate)(null);
                    return Object.assign((n, ...a)=>{
                        if ("string" == typeof n) {
                            if (a.length > 1) throw new Error("Unexpected extra params.");
                            return o((0, i.default)(t, n, (0, r.merge)(u, (0, r.validate)(a[0]))));
                        }
                        if (Array.isArray(n)) {
                            let e1 = l.get(n);
                            return e1 || (e1 = (0, s.default)(t, n, u), l.set(n, e1)), o(e1(a));
                        }
                        if ("object" == typeof n && n) {
                            if (a.length > 0) throw new Error("Unexpected extra params.");
                            return e1(t, (0, r.merge)(u, (0, r.validate)(n)));
                        }
                        throw new Error("Unexpected template param " + typeof n);
                    }, {
                        ast: (e1, ...n)=>{
                            if ("string" == typeof e1) {
                                if (n.length > 1) throw new Error("Unexpected extra params.");
                                return (0, i.default)(t, e1, (0, r.merge)((0, r.merge)(u, (0, r.validate)(n[0])), a))();
                            }
                            if (Array.isArray(e1)) {
                                let i = c.get(e1);
                                return i || (i = (0, s.default)(t, e1, (0, r.merge)(u, a)), c.set(e1, i)), i(n)();
                            }
                            throw new Error("Unexpected template param " + typeof e1);
                        }
                    });
                };
                var r = n(2655), i = n(5650), s = n(2579);
                const a = (0, r.validate)({
                    placeholderPattern: !1
                });
                function o(e1) {
                    let t = "";
                    try {
                        throw new Error;
                    } catch (e1) {
                        e1.stack && (t = e1.stack.split("\n").slice(3).join("\n"));
                    }
                    return (n)=>{
                        try {
                            return e1(n);
                        } catch (e1) {
                            throw e1.stack += `\n    =============\n${t}`, e1;
                        }
                    };
                }
            },
            6586: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.statements = t.statement = t.smart = t.program = t.expression = void 0;
                var r = n(6067);
                const { assertExpressionStatement: i } = r;
                function s(e1) {
                    return {
                        code: (e1)=>`/* @babel/template */;\n${e1}`,
                        validate: ()=>{},
                        unwrap: (t)=>e1(t.program.body.slice(1))
                    };
                }
                const a = s((e1)=>e1.length > 1 ? e1 : e1[0]);
                t.smart = a;
                const o = s((e1)=>e1);
                t.statements = o;
                const l = s((e1)=>{
                    if (0 === e1.length) throw new Error("Found nothing to return.");
                    if (e1.length > 1) throw new Error("Found multiple statements but wanted one");
                    return e1[0];
                });
                t.statement = l;
                const c = {
                    code: (e1)=>`(\n${e1}\n)`,
                    validate: (e1)=>{
                        if (e1.program.body.length > 1) throw new Error("Found multiple statements but wanted one");
                        if (0 === c.unwrap(e1).start) throw new Error("Parse result included parens.");
                    },
                    unwrap: ({ program: e1 })=>{
                        const [t] = e1.body;
                        return i(t), t.expression;
                    }
                };
                t.expression = c, t.program = {
                    code: (e1)=>e1,
                    validate: ()=>{},
                    unwrap: (e1)=>e1.program
                };
            },
            6849: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.statements = t.statement = t.smart = t.program = t.expression = t.default = void 0;
                var r = n(6586), i = n(97);
                const s = (0, i.default)(r.smart);
                t.smart = s;
                const a = (0, i.default)(r.statement);
                t.statement = a;
                const o = (0, i.default)(r.statements);
                t.statements = o;
                const l = (0, i.default)(r.expression);
                t.expression = l;
                const c = (0, i.default)(r.program);
                t.program = c;
                var u = Object.assign(s.bind(void 0), {
                    smart: s,
                    statement: a,
                    statements: o,
                    expression: l,
                    program: c,
                    ast: s.ast
                });
                t.default = u;
            },
            2579: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t, n) {
                    const { metadata: a, names: o } = function(e1, t, n) {
                        let r = "BABEL_TPL$";
                        const s = t.join("");
                        do {
                            r = "$$" + r;
                        }while (s.includes(r))
                        const { names: a, code: o } = function(e1, t) {
                            const n = [];
                            let r = e1[0];
                            for(let i = 1; i < e1.length; i++){
                                const s = `${t}${i - 1}`;
                                n.push(s), r += s + e1[i];
                            }
                            return {
                                names: n,
                                code: r
                            };
                        }(t, r);
                        return {
                            metadata: (0, i.default)(e1, e1.code(o), {
                                parser: n.parser,
                                placeholderWhitelist: new Set(a.concat(n.placeholderWhitelist ? Array.from(n.placeholderWhitelist) : [])),
                                placeholderPattern: n.placeholderPattern,
                                preserveComments: n.preserveComments,
                                syntacticPlaceholders: n.syntacticPlaceholders
                            }),
                            names: a
                        };
                    }(e1, t, n);
                    return (t)=>{
                        const n = {};
                        return t.forEach((e1, t)=>{
                            n[o[t]] = e1;
                        }), (t)=>{
                            const i = (0, r.normalizeReplacements)(t);
                            return i && Object.keys(i).forEach((e1)=>{
                                if (Object.prototype.hasOwnProperty.call(n, e1)) throw new Error("Unexpected replacement overlap.");
                            }), e1.unwrap((0, s.default)(a, i ? Object.assign(i, n) : n));
                        };
                    };
                };
                var r = n(2655), i = n(6382), s = n(8112);
            },
            2655: (e1, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.merge = function(e1, t) {
                    const { placeholderWhitelist: n = e1.placeholderWhitelist, placeholderPattern: r = e1.placeholderPattern, preserveComments: i = e1.preserveComments, syntacticPlaceholders: s = e1.syntacticPlaceholders } = t;
                    return {
                        parser: Object.assign({}, e1.parser, t.parser),
                        placeholderWhitelist: n,
                        placeholderPattern: r,
                        preserveComments: i,
                        syntacticPlaceholders: s
                    };
                }, t.normalizeReplacements = function(e1) {
                    if (Array.isArray(e1)) return e1.reduce((e1, t, n)=>(e1["$" + n] = t, e1), {});
                    if ("object" == typeof e1 || null == e1) return e1 || void 0;
                    throw new Error("Template replacements must be an array, object, null, or undefined");
                }, t.validate = function(e1) {
                    if (null != e1 && "object" != typeof e1) throw new Error("Unknown template options.");
                    const t = e1 || {}, { placeholderWhitelist: r, placeholderPattern: i, preserveComments: s, syntacticPlaceholders: a } = t, o = function(e1, t) {
                        if (null == e1) return {};
                        var n, r, i = {}, s = Object.keys(e1);
                        for(r = 0; r < s.length; r++)n = s[r], t.indexOf(n) >= 0 || (i[n] = e1[n]);
                        return i;
                    }(t, n);
                    if (null != r && !(r instanceof Set)) throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
                    if (null != i && !(i instanceof RegExp) && !1 !== i) throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
                    if (null != s && "boolean" != typeof s) throw new Error("'.preserveComments' must be a boolean, null, or undefined");
                    if (null != a && "boolean" != typeof a) throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
                    if (!0 === a && (null != r || null != i)) throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
                    return {
                        parser: o,
                        placeholderWhitelist: r || void 0,
                        placeholderPattern: null == i ? void 0 : i,
                        preserveComments: null == s ? void 0 : s,
                        syntacticPlaceholders: null == a ? void 0 : a
                    };
                };
                const n = [
                    "placeholderWhitelist",
                    "placeholderPattern",
                    "preserveComments",
                    "syntacticPlaceholders"
                ];
            },
            6382: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t, n) {
                    const { placeholderWhitelist: r, placeholderPattern: a, preserveComments: o, syntacticPlaceholders: l } = n, c = function(e1, t, n) {
                        const r = (t.plugins || []).slice();
                        !1 !== n && r.push("placeholders"), t = Object.assign({
                            allowReturnOutsideFunction: !0,
                            allowSuperOutsideMethod: !0,
                            sourceType: "module"
                        }, t, {
                            plugins: r
                        });
                        try {
                            return (0, i.parse)(e1, t);
                        } catch (t) {
                            const n = t.loc;
                            throw n && (t.message += "\n" + (0, s.codeFrameColumns)(e1, {
                                start: n
                            }), t.code = "BABEL_TEMPLATE_PARSE_ERROR"), t;
                        }
                    }(t, n.parser, l);
                    y(c, {
                        preserveComments: o
                    }), e1.validate(c);
                    const u = {
                        syntactic: {
                            placeholders: [],
                            placeholderNames: new Set
                        },
                        legacy: {
                            placeholders: [],
                            placeholderNames: new Set
                        },
                        placeholderWhitelist: r,
                        placeholderPattern: a,
                        syntacticPlaceholders: l
                    };
                    return m(c, g, u), Object.assign({
                        ast: c
                    }, u.syntactic.placeholders.length ? u.syntactic : u.legacy);
                };
                var r = n(6067), i = n(7191), s = n(4704);
                const { isCallExpression: a, isExpressionStatement: o, isFunction: l, isIdentifier: c, isJSXIdentifier: u, isNewExpression: p, isPlaceholder: h, isStatement: d, isStringLiteral: f, removePropertiesDeep: y, traverse: m } = r, T = /^[_$A-Z0-9]+$/;
                function g(e1, t, n) {
                    var r;
                    let i, s = n.syntactic.placeholders.length > 0;
                    if (h(e1)) {
                        if (!1 === n.syntacticPlaceholders) throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
                        i = e1.name.name, s = !0;
                    } else {
                        if (s || n.syntacticPlaceholders) return;
                        if (c(e1) || u(e1)) i = e1.name;
                        else {
                            if (!f(e1)) return;
                            i = e1.value;
                        }
                    }
                    if (s && (null != n.placeholderPattern || null != n.placeholderWhitelist)) throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
                    if (!(s || !1 !== n.placeholderPattern && (n.placeholderPattern || T).test(i) || null != (r = n.placeholderWhitelist) && r.has(i))) return;
                    t = t.slice();
                    const { node: y, key: m } = t[t.length - 1];
                    let g;
                    f(e1) || h(e1, {
                        expectedNode: "StringLiteral"
                    }) ? g = "string" : p(y) && "arguments" === m || a(y) && "arguments" === m || l(y) && "params" === m ? g = "param" : o(y) && !h(e1) ? (g = "statement", t = t.slice(0, -1)) : g = d(e1) && h(e1) ? "statement" : "other";
                    const { placeholders: b, placeholderNames: E } = s ? n.syntactic : n.legacy;
                    b.push({
                        name: i,
                        type: g,
                        resolve: (e1)=>(function(e1, t) {
                                let n = e1;
                                for(let e1 = 0; e1 < t.length - 1; e1++){
                                    const { key: r, index: i } = t[e1];
                                    n = void 0 === i ? n[r] : n[r][i];
                                }
                                const { key: r, index: i } = t[t.length - 1];
                                return {
                                    parent: n,
                                    key: r,
                                    index: i
                                };
                            })(e1, t),
                        isDuplicate: E.has(i)
                    }), E.add(i);
                }
            },
            8112: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t) {
                    const n = s(e1.ast);
                    return t && (e1.placeholders.forEach((e1)=>{
                        if (!Object.prototype.hasOwnProperty.call(t, e1.name)) {
                            const t = e1.name;
                            throw new Error(`Error: No substitution given for "${t}". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['${t}'])}\n            - { placeholderPattern: /^${t}$/ }`);
                        }
                    }), Object.keys(t).forEach((t)=>{
                        if (!e1.placeholderNames.has(t)) throw new Error(`Unknown substitution "${t}" given`);
                    })), e1.placeholders.slice().reverse().forEach((e1)=>{
                        try {
                            !function(e1, t, n) {
                                e1.isDuplicate && (Array.isArray(n) ? n = n.map((e1)=>s(e1)) : "object" == typeof n && (n = s(n)));
                                const { parent: r, key: d, index: f } = e1.resolve(t);
                                if ("string" === e1.type) {
                                    if ("string" == typeof n && (n = p(n)), !n || !u(n)) throw new Error("Expected string substitution");
                                } else if ("statement" === e1.type) void 0 === f ? n ? Array.isArray(n) ? n = i(n) : "string" == typeof n ? n = o(l(n)) : c(n) || (n = o(n)) : n = a() : n && !Array.isArray(n) && ("string" == typeof n && (n = l(n)), c(n) || (n = o(n)));
                                else if ("param" === e1.type) {
                                    if ("string" == typeof n && (n = l(n)), void 0 === f) throw new Error("Assertion failure.");
                                } else if ("string" == typeof n && (n = l(n)), Array.isArray(n)) throw new Error("Cannot replace single expression with an array.");
                                if (void 0 === f) h(r, d, n), r[d] = n;
                                else {
                                    const t = r[d].slice();
                                    "statement" === e1.type || "param" === e1.type ? null == n ? t.splice(f, 1) : Array.isArray(n) ? t.splice(f, 1, ...n) : t[f] = n : t[f] = n, h(r, d, t), r[d] = t;
                                }
                            }(e1, n, t && t[e1.name] || null);
                        } catch (t) {
                            throw t.message = `@babel/template placeholder "${e1.name}": ${t.message}`, t;
                        }
                    }), n;
                };
                var r = n(6067);
                const { blockStatement: i, cloneNode: s, emptyStatement: a, expressionStatement: o, identifier: l, isStatement: c, isStringLiteral: u, stringLiteral: p, validate: h } = r;
            },
            5650: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t, n) {
                    let a;
                    return t = e1.code(t), (o)=>{
                        const l = (0, r.normalizeReplacements)(o);
                        return a || (a = (0, i.default)(e1, t, n)), e1.unwrap((0, s.default)(a, l));
                    };
                };
                var r = n(2655), i = n(6382), s = n(8112);
            },
            9446: (e1, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.clear = function() {
                    i(), s();
                }, t.clearPath = i, t.clearScope = s, t.getCachedPaths = function(e1, t) {
                    var r;
                    return null == (r = n.get(a)) ? void 0 : r.get(t);
                }, t.getOrCreateCachedPaths = function(e1, t) {
                    let r = n.get(a);
                    r || n.set(a, r = new WeakMap);
                    let i = r.get(t);
                    return i || r.set(t, i = new Map), i;
                }, t.scope = t.path = void 0;
                let n = new WeakMap;
                t.path = n;
                let r = new WeakMap;
                function i() {
                    t.path = n = new WeakMap;
                }
                function s() {
                    t.scope = r = new WeakMap;
                }
                t.scope = r;
                const a = Object.freeze({});
            },
            4165: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var r = n(763), i = n(6067);
                const { VISITOR_KEYS: s } = i;
                t.default = class {
                    constructor(e1, t, n, r){
                        this.queue = null, this.priorityQueue = null, this.parentPath = r, this.scope = e1, this.state = n, this.opts = t;
                    }
                    shouldVisit(e1) {
                        const t = this.opts;
                        if (t.enter || t.exit) return !0;
                        if (t[e1.type]) return !0;
                        const n = s[e1.type];
                        if (null == n || !n.length) return !1;
                        for (const t of n)if (e1[t]) return !0;
                        return !1;
                    }
                    create(e1, t, n, i) {
                        return r.default.get({
                            parentPath: this.parentPath,
                            parent: e1,
                            container: t,
                            key: n,
                            listKey: i
                        });
                    }
                    maybeQueue(e1, t) {
                        this.queue && (t ? this.queue.push(e1) : this.priorityQueue.push(e1));
                    }
                    visitMultiple(e1, t, n) {
                        if (0 === e1.length) return !1;
                        const r = [];
                        for(let i = 0; i < e1.length; i++){
                            const s = e1[i];
                            s && this.shouldVisit(s) && r.push(this.create(t, e1, i, n));
                        }
                        return this.visitQueue(r);
                    }
                    visitSingle(e1, t) {
                        return !!this.shouldVisit(e1[t]) && this.visitQueue([
                            this.create(e1, e1, t)
                        ]);
                    }
                    visitQueue(e1) {
                        this.queue = e1, this.priorityQueue = [];
                        const t = new WeakSet;
                        let n = !1;
                        for (const r of e1){
                            if (r.resync(), 0 !== r.contexts.length && r.contexts[r.contexts.length - 1] === this || r.pushContext(this), null === r.key) continue;
                            const { node: i } = r;
                            if (!t.has(i)) {
                                if (i && t.add(i), r.visit()) {
                                    n = !0;
                                    break;
                                }
                                if (this.priorityQueue.length && (n = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = e1, n)) break;
                            }
                        }
                        for (const t of e1)t.popContext();
                        return this.queue = null, n;
                    }
                    visit(e1, t) {
                        const n = e1[t];
                        return !!n && (Array.isArray(n) ? this.visitMultiple(n, e1, t) : this.visitSingle(e1, t));
                    }
                };
            },
            9799: (e1, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0, t.default = class {
                    getCode() {}
                    getScope() {}
                    addHelper() {
                        throw new Error("Helpers are not supported by the default hub.");
                    }
                    buildError(e1, t, n = TypeError) {
                        return new n(t);
                    }
                };
            },
            5686: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), Object.defineProperty(t, "Hub", {
                    enumerable: !0,
                    get: function() {
                        return c.default;
                    }
                }), Object.defineProperty(t, "NodePath", {
                    enumerable: !0,
                    get: function() {
                        return o.default;
                    }
                }), Object.defineProperty(t, "Scope", {
                    enumerable: !0,
                    get: function() {
                        return l.default;
                    }
                }), t.visitors = t.default = void 0;
                var r = n(7380);
                t.visitors = r;
                var i = n(6067), s = n(9446), a = n(9432), o = n(763), l = n(200), c = n(9799);
                const { VISITOR_KEYS: u, removeProperties: p, traverseFast: h } = i;
                function d(e1, t = {}, n, i, s, o) {
                    if (e1) {
                        if (!t.noScope && !n && "Program" !== e1.type && "File" !== e1.type) throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${e1.type} node without passing scope and parentPath.`);
                        if (!s && o) throw new Error("visitSelf can only be used when providing a NodePath.");
                        u[e1.type] && (r.explode(t), (0, a.traverseNode)(e1, t, n, i, s, null, o));
                    }
                }
                var f = d;
                function y(e1, t) {
                    e1.node.type === t.type && (t.has = !0, e1.stop());
                }
                t.default = f, d.visitors = r, d.verify = r.verify, d.explode = r.explode, d.cheap = function(e1, t) {
                    h(e1, t);
                }, d.node = function(e1, t, n, r, i, s) {
                    (0, a.traverseNode)(e1, t, n, r, i, s);
                }, d.clearNode = function(e1, t) {
                    p(e1, t);
                }, d.removeProperties = function(e1, t) {
                    return h(e1, d.clearNode, t), e1;
                }, d.hasType = function(e1, t, n) {
                    if (null != n && n.includes(e1.type)) return !1;
                    if (e1.type === t) return !0;
                    const r = {
                        has: !1,
                        type: t
                    };
                    return d(e1, {
                        noScope: !0,
                        denylist: n,
                        enter: y
                    }, null, r), r.has;
                }, d.cache = s;
            },
            531: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.find = function(e1) {
                    let t = this;
                    do {
                        if (e1(t)) return t;
                    }while (t = t.parentPath)
                    return null;
                }, t.findParent = function(e1) {
                    let t = this;
                    for(; t = t.parentPath;)if (e1(t)) return t;
                    return null;
                }, t.getAncestry = function() {
                    let e1 = this;
                    const t = [];
                    do {
                        t.push(e1);
                    }while (e1 = e1.parentPath)
                    return t;
                }, t.getDeepestCommonAncestorFrom = function(e1, t) {
                    if (!e1.length) return this;
                    if (1 === e1.length) return e1[0];
                    let n, r, i = 1 / 0;
                    const s = e1.map((e1)=>{
                        const t = [];
                        do {
                            t.unshift(e1);
                        }while ((e1 = e1.parentPath) && e1 !== this)
                        return t.length < i && (i = t.length), t;
                    }), a = s[0];
                    e: for(let e1 = 0; e1 < i; e1++){
                        const t = a[e1];
                        for (const n of s)if (n[e1] !== t) break e;
                        n = e1, r = t;
                    }
                    if (r) return t ? t(r, n, s) : r;
                    throw new Error("Couldn't find intersection");
                }, t.getEarliestCommonAncestorFrom = function(e1) {
                    return this.getDeepestCommonAncestorFrom(e1, function(e1, t, n) {
                        let r;
                        const s = i[e1.type];
                        for (const e1 of n){
                            const n = e1[t + 1];
                            r ? (n.listKey && r.listKey === n.listKey && n.key < r.key || s.indexOf(r.parentKey) > s.indexOf(n.parentKey)) && (r = n) : r = n;
                        }
                        return r;
                    });
                }, t.getFunctionParent = function() {
                    return this.findParent((e1)=>e1.isFunction());
                }, t.getStatementParent = function() {
                    let e1 = this;
                    do {
                        if (!e1.parentPath || Array.isArray(e1.container) && e1.isStatement()) break;
                        e1 = e1.parentPath;
                    }while (e1)
                    if (e1 && (e1.isProgram() || e1.isFile())) throw new Error("File/Program node, we can't possibly find a statement parent to this");
                    return e1;
                }, t.inType = function(...e1) {
                    let t = this;
                    for(; t;){
                        for (const n of e1)if (t.node.type === n) return !0;
                        t = t.parentPath;
                    }
                    return !1;
                }, t.isAncestor = function(e1) {
                    return e1.isDescendant(this);
                }, t.isDescendant = function(e1) {
                    return !!this.findParent((t)=>t === e1);
                };
                var r = n(6067);
                const { VISITOR_KEYS: i } = r;
            },
            1801: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.addComment = function(e1, t, n) {
                    i(this.node, e1, t, n);
                }, t.addComments = function(e1, t) {
                    s(this.node, e1, t);
                }, t.shareCommentsWithSiblings = function() {
                    if ("string" == typeof this.key) return;
                    const e1 = this.node;
                    if (!e1) return;
                    const t = e1.trailingComments, n = e1.leadingComments;
                    if (!t && !n) return;
                    const r = this.getSibling(this.key - 1), i = this.getSibling(this.key + 1), s = Boolean(r.node), o = Boolean(i.node);
                    s && (n && r.addComments("trailing", a(n, r.node.trailingComments)), t && !o && r.addComments("trailing", t)), o && (t && i.addComments("leading", a(t, i.node.leadingComments)), n && !s && i.addComments("leading", n));
                };
                var r = n(6067);
                const { addComment: i, addComments: s } = r;
                function a(e1, t) {
                    if (!t) return e1;
                    let n = -1;
                    return e1.filter((e1)=>{
                        const r = t.indexOf(e1, n);
                        if (-1 === r) return !0;
                        n = r;
                    });
                }
            },
            2981: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t._call = function(e1) {
                    if (!e1) return !1;
                    for (const t of e1){
                        if (!t) continue;
                        const e1 = this.node;
                        if (!e1) return !0;
                        const n = t.call(this.state, this, this.state);
                        if (n && "object" == typeof n && "function" == typeof n.then) throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
                        if (n) throw new Error(`Unexpected return value from visitor method ${t}`);
                        if (this.node !== e1) return !0;
                        if (this._traverseFlags > 0) return !0;
                    }
                    return !1;
                }, t._getQueueContexts = function() {
                    let e1 = this, t = this.contexts;
                    for(; !t.length && (e1 = e1.parentPath, e1);)t = e1.contexts;
                    return t;
                }, t._resyncKey = function() {
                    if (this.container && this.node !== this.container[this.key]) {
                        if (Array.isArray(this.container)) {
                            for(let e1 = 0; e1 < this.container.length; e1++)if (this.container[e1] === this.node) return void this.setKey(e1);
                        } else for (const e1 of Object.keys(this.container))if (this.container[e1] === this.node) return void this.setKey(e1);
                        this.key = null;
                    }
                }, t._resyncList = function() {
                    if (!this.parent || !this.inList) return;
                    const e1 = this.parent[this.listKey];
                    this.container !== e1 && (this.container = e1 || null);
                }, t._resyncParent = function() {
                    this.parentPath && (this.parent = this.parentPath.node);
                }, t._resyncRemoved = function() {
                    null != this.key && this.container && this.container[this.key] === this.node || this._markRemoved();
                }, t.call = function(e1) {
                    const t = this.opts;
                    return this.debug(e1), !(!this.node || !this._call(t[e1])) || !!this.node && this._call(null == (n = t[this.node.type]) ? void 0 : n[e1]);
                    "TURBOPACK unreachable";
                    var n;
                }, t.isBlacklisted = t.isDenylisted = function() {
                    var e1;
                    const t = null != (e1 = this.opts.denylist) ? e1 : this.opts.blacklist;
                    return t && t.indexOf(this.node.type) > -1;
                }, t.popContext = function() {
                    this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
                }, t.pushContext = function(e1) {
                    this.contexts.push(e1), this.setContext(e1);
                }, t.requeue = function(e1 = this) {
                    if (e1.removed) return;
                    const t = this.contexts;
                    for (const n of t)n.maybeQueue(e1);
                }, t.resync = function() {
                    this.removed || (this._resyncParent(), this._resyncList(), this._resyncKey());
                }, t.setContext = function(e1) {
                    return null != this.skipKeys && (this.skipKeys = {}), this._traverseFlags = 0, e1 && (this.context = e1, this.state = e1.state, this.opts = e1.opts), this.setScope(), this;
                }, t.setKey = function(e1) {
                    var t;
                    this.key = e1, this.node = this.container[this.key], this.type = null == (t = this.node) ? void 0 : t.type;
                }, t.setScope = function() {
                    var e1, t;
                    if (null != (e1 = this.opts) && e1.noScope) return;
                    let n, r = this.parentPath;
                    for((("key" === this.key || "decorators" === this.listKey) && r.isMethod() || "discriminant" === this.key && r.isSwitchStatement()) && (r = r.parentPath); r && !n;){
                        var i;
                        if (null != (i = r.opts) && i.noScope) return;
                        n = r.scope, r = r.parentPath;
                    }
                    this.scope = this.getScope(n), null == (t = this.scope) || t.init();
                }, t.setup = function(e1, t, n, r) {
                    this.listKey = n, this.container = t, this.parentPath = e1 || this.parentPath, this.setKey(r);
                }, t.skip = function() {
                    this.shouldSkip = !0;
                }, t.skipKey = function(e1) {
                    null == this.skipKeys && (this.skipKeys = {}), this.skipKeys[e1] = !0;
                }, t.stop = function() {
                    this._traverseFlags |= i.SHOULD_SKIP | i.SHOULD_STOP;
                }, t.visit = function() {
                    var e1, t;
                    if (!this.node) return !1;
                    if (this.isDenylisted()) return !1;
                    if (null != (e1 = (t = this.opts).shouldSkip) && e1.call(t, this)) return !1;
                    const n = this.context;
                    return this.shouldSkip || this.call("enter") ? (this.debug("Skip..."), this.shouldStop) : (s(this, n), this.debug("Recursing into..."), this.shouldStop = (0, r.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), s(this, n), this.call("exit"), this.shouldStop);
                };
                var r = n(9432), i = n(763);
                function s(e1, t) {
                    e1.context !== t && (e1.context = t, e1.state = t.state, e1.opts = t.opts);
                }
            },
            6309: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.arrowFunctionToExpression = function({ allowInsertArrow: e1 = !0, allowInsertArrowWithRest: t = e1, noNewArrows: n = !((e1)=>null == (e1 = arguments[0]) ? void 0 : e1.specCompliant)() } = {}) {
                    if (!this.isArrowFunctionExpression()) throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
                    const { thisBinding: r, fnPath: i } = k(this, n, e1, t);
                    if (i.ensureBlock(), i.node.type = "FunctionExpression", !n) {
                        const e1 = r ? null : i.scope.generateUidIdentifier("arrowCheckId");
                        return e1 && i.parentPath.scope.push({
                            id: e1,
                            init: P([])
                        }), i.get("body").unshiftContainer("body", d(p(this.hub.addHelper("newArrowCheck"), [
                            O(),
                            f(e1 ? e1.name : r)
                        ]))), i.replaceWith(p(b((0, s.default)(this, !0) || i.node, f("bind")), [
                            e1 ? f(e1.name) : O()
                        ])), i.get("callee.object");
                    }
                    return i;
                }, t.ensureBlock = function() {
                    const e1 = this.get("body"), t = e1.node;
                    if (Array.isArray(e1)) throw new Error("Can't convert array path to a block statement");
                    if (!t) throw new Error("Can't convert node without a body");
                    if (e1.isBlockStatement()) return t;
                    const n = [];
                    let r, i, s = "body";
                    e1.isStatement() ? (i = "body", r = 0, n.push(e1.node)) : (s += ".body.0", this.isFunction() ? (r = "argument", n.push(D(e1.node))) : (r = "expression", n.push(d(e1.node)))), this.node.body = u(n);
                    const a = this.get(s);
                    return e1.setup(a, i ? a.node[i] : a.node, i, r), this.node;
                }, t.toComputedKey = function() {
                    let e1;
                    if (this.isMemberExpression()) e1 = this.node.property;
                    else {
                        if (!this.isProperty() && !this.isMethod()) throw new ReferenceError("todo");
                        e1 = this.node.key;
                    }
                    return this.node.computed || y(e1) && (e1 = C(e1.name)), e1;
                }, t.unwrapFunctionEnvironment = function() {
                    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
                    k(this);
                };
                var r = n(6067), i = n(4705), s = n(2023), a = n(7380);
                const { arrowFunctionExpression: o, assignmentExpression: l, binaryExpression: c, blockStatement: u, callExpression: p, conditionalExpression: h, expressionStatement: d, identifier: f, isIdentifier: y, jsxIdentifier: m, logicalExpression: T, LOGICAL_OPERATORS: g, memberExpression: b, metaProperty: E, numericLiteral: S, objectExpression: P, restElement: x, returnStatement: D, sequenceExpression: A, spreadElement: v, stringLiteral: C, super: w, thisExpression: O, toExpression: I, unaryExpression: N } = r;
                t.arrowFunctionToShadowed = function() {
                    this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
                };
                const F = (0, a.merge)([
                    {
                        CallExpression (e1, { allSuperCalls: t }) {
                            e1.get("callee").isSuper() && t.push(e1);
                        }
                    },
                    i.default
                ]);
                function k(e1, t = !0, n = !0, r = !0) {
                    let i, s = e1.findParent((e1)=>e1.isArrowFunctionExpression() ? (null != i || (i = e1), !1) : e1.isFunction() || e1.isProgram() || e1.isClassProperty({
                            static: !1
                        }) || e1.isClassPrivateProperty({
                            static: !1
                        }));
                    const a = s.isClassMethod({
                        kind: "constructor"
                    });
                    if (s.isClassProperty() || s.isClassPrivateProperty()) if (i) s = i;
                    else {
                        if (!n) throw e1.buildCodeFrameError("Unable to transform arrow inside class property");
                        e1.replaceWith(p(o([], I(e1.node)), [])), s = e1.get("callee"), e1 = s.get("body");
                    }
                    const { thisPaths: u, argumentsPaths: d, newTargetPaths: y, superProps: P, superCalls: D } = function(e1) {
                        const t = [], n = [], r = [], i = [], s = [];
                        return e1.traverse(B, {
                            thisPaths: t,
                            argumentsPaths: n,
                            newTargetPaths: r,
                            superProps: i,
                            superCalls: s
                        }), {
                            thisPaths: t,
                            argumentsPaths: n,
                            newTargetPaths: r,
                            superProps: i,
                            superCalls: s
                        };
                    }(e1);
                    if (a && D.length > 0) {
                        if (!n) throw D[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
                        if (!r) throw D[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
                        const e1 = [];
                        s.traverse(F, {
                            allSuperCalls: e1
                        });
                        const t = function(e1) {
                            return M(e1, "supercall", ()=>{
                                const t = e1.scope.generateUidIdentifier("args");
                                return o([
                                    x(t)
                                ], p(w(), [
                                    v(f(t.name))
                                ]));
                            });
                        }(s);
                        e1.forEach((e1)=>{
                            const n = f(t);
                            n.loc = e1.node.callee.loc, e1.get("callee").replaceWith(n);
                        });
                    }
                    if (d.length > 0) {
                        const e1 = M(s, "arguments", ()=>{
                            const e1 = ()=>f("arguments");
                            return s.scope.path.isProgram() ? h(c("===", N("typeof", e1()), C("undefined")), s.scope.buildUndefinedNode(), e1()) : e1();
                        });
                        d.forEach((t)=>{
                            const n = f(e1);
                            n.loc = t.node.loc, t.replaceWith(n);
                        });
                    }
                    if (y.length > 0) {
                        const e1 = M(s, "newtarget", ()=>E(f("new"), f("target")));
                        y.forEach((t)=>{
                            const n = f(e1);
                            n.loc = t.node.loc, t.replaceWith(n);
                        });
                    }
                    if (P.length > 0) {
                        if (!n) throw P[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
                        P.reduce((e1, t)=>e1.concat(function(e1) {
                                if (e1.parentPath.isAssignmentExpression() && "=" !== e1.parentPath.node.operator) {
                                    const n = e1.parentPath, r = n.node.operator.slice(0, -1), i = n.node.right, s = function(e1) {
                                        return g.includes(e1);
                                    }(r);
                                    if (e1.node.computed) {
                                        const a = e1.scope.generateDeclaredUidIdentifier("tmp"), o = e1.node.object, c = e1.node.property;
                                        n.get("left").replaceWith(b(o, l("=", a, c), !0)), n.get("right").replaceWith(t(s ? "=" : r, b(o, f(a.name), !0), i));
                                    } else {
                                        const a = e1.node.object, o = e1.node.property;
                                        n.get("left").replaceWith(b(a, o)), n.get("right").replaceWith(t(s ? "=" : r, b(a, f(o.name)), i));
                                    }
                                    return s ? n.replaceWith(T(r, n.node.left, n.node.right)) : n.node.operator = "=", [
                                        n.get("left"),
                                        n.get("right").get("left")
                                    ];
                                }
                                if (e1.parentPath.isUpdateExpression()) {
                                    const t = e1.parentPath, n = e1.scope.generateDeclaredUidIdentifier("tmp"), r = e1.node.computed ? e1.scope.generateDeclaredUidIdentifier("prop") : null, i = [
                                        l("=", n, b(e1.node.object, r ? l("=", r, e1.node.property) : e1.node.property, e1.node.computed)),
                                        l("=", b(e1.node.object, r ? f(r.name) : e1.node.property, e1.node.computed), c(e1.parentPath.node.operator[0], f(n.name), S(1)))
                                    ];
                                    return e1.parentPath.node.prefix || i.push(f(n.name)), t.replaceWith(A(i)), [
                                        t.get("expressions.0.right"),
                                        t.get("expressions.1.left")
                                    ];
                                }
                                return [
                                    e1
                                ];
                                "TURBOPACK unreachable";
                                function t(e1, t, n) {
                                    return "=" === e1 ? l("=", t, n) : c(e1, t, n);
                                }
                            }(t)), []).forEach((e1)=>{
                            const t = e1.node.computed ? "" : e1.get("property").node.name, n = e1.parentPath, r = n.isAssignmentExpression({
                                left: e1.node
                            }), i = n.isCallExpression({
                                callee: e1.node
                            }), a = n.isTaggedTemplateExpression({
                                tag: e1.node
                            }), c = function(e1, t, n) {
                                return M(e1, `superprop_${t ? "set" : "get"}:${n || ""}`, ()=>{
                                    const r = [];
                                    let i;
                                    if (n) i = b(w(), f(n));
                                    else {
                                        const t = e1.scope.generateUidIdentifier("prop");
                                        r.unshift(t), i = b(w(), f(t.name), !0);
                                    }
                                    if (t) {
                                        const t = e1.scope.generateUidIdentifier("value");
                                        r.push(t), i = l("=", i, f(t.name));
                                    }
                                    return o(r, i);
                                });
                            }(s, r, t), h = [];
                            if (e1.node.computed && h.push(e1.get("property").node), r) {
                                const e1 = n.node.right;
                                h.push(e1);
                            }
                            const d = p(f(c), h);
                            i ? (n.unshiftContainer("arguments", O()), e1.replaceWith(b(d, f("call"))), u.push(n.get("arguments.0"))) : r ? n.replaceWith(d) : a ? (e1.replaceWith(p(b(d, f("bind"), !1), [
                                O()
                            ])), u.push(e1.get("arguments.0"))) : e1.replaceWith(d);
                        });
                    }
                    let k1;
                    return (u.length > 0 || !t) && (k1 = function(e1, t) {
                        return M(e1, "this", (n)=>{
                            if (!t || !L(e1)) return O();
                            e1.traverse(_, {
                                supers: new WeakSet,
                                thisBinding: n
                            });
                        });
                    }(s, a), (t || a && L(s)) && (u.forEach((e1)=>{
                        const t = e1.isJSX() ? m(k1) : f(k1);
                        t.loc = e1.node.loc, e1.replaceWith(t);
                    }), t || (k1 = null))), {
                        thisBinding: k1,
                        fnPath: e1
                    };
                }
                function L(e1) {
                    return e1.isClassMethod() && !!e1.parentPath.parentPath.node.superClass;
                }
                const _ = (0, a.merge)([
                    {
                        CallExpression (e1, { supers: t, thisBinding: n }) {
                            e1.get("callee").isSuper() && (t.has(e1.node) || (t.add(e1.node), e1.replaceWithMultiple([
                                e1.node,
                                l("=", f(n), f("this"))
                            ])));
                        }
                    },
                    i.default
                ]);
                function M(e1, t, n) {
                    const r = "binding:" + t;
                    let i = e1.getData(r);
                    if (!i) {
                        const s = e1.scope.generateUidIdentifier(t);
                        i = s.name, e1.setData(r, i), e1.scope.push({
                            id: s,
                            init: n(i)
                        });
                    }
                    return i;
                }
                const B = (0, a.merge)([
                    {
                        ThisExpression (e1, { thisPaths: t }) {
                            t.push(e1);
                        },
                        JSXIdentifier (e1, { thisPaths: t }) {
                            "this" === e1.node.name && (e1.parentPath.isJSXMemberExpression({
                                object: e1.node
                            }) || e1.parentPath.isJSXOpeningElement({
                                name: e1.node
                            })) && t.push(e1);
                        },
                        CallExpression (e1, { superCalls: t }) {
                            e1.get("callee").isSuper() && t.push(e1);
                        },
                        MemberExpression (e1, { superProps: t }) {
                            e1.get("object").isSuper() && t.push(e1);
                        },
                        Identifier (e1, { argumentsPaths: t }) {
                            if (!e1.isReferencedIdentifier({
                                name: "arguments"
                            })) return;
                            let n = e1.scope;
                            do {
                                if (n.hasOwnBinding("arguments")) return void n.rename("arguments");
                                if (n.path.isFunction() && !n.path.isArrowFunctionExpression()) break;
                            }while (n = n.parent)
                            t.push(e1);
                        },
                        MetaProperty (e1, { newTargetPaths: t }) {
                            e1.get("meta").isIdentifier({
                                name: "new"
                            }) && e1.get("property").isIdentifier({
                                name: "target"
                            }) && t.push(e1);
                        }
                    },
                    i.default
                ]);
            },
            2822: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.evaluate = function() {
                    const e1 = {
                        confident: !0,
                        deoptPath: null,
                        seen: new Map
                    };
                    let t = l(this, e1);
                    return e1.confident || (t = void 0), {
                        confident: e1.confident,
                        deopt: e1.deoptPath,
                        value: t
                    };
                }, t.evaluateTruthy = function() {
                    const e1 = this.evaluate();
                    if (e1.confident) return !!e1.value;
                };
                const r = [
                    "String",
                    "Number",
                    "Math"
                ], i = [
                    "random"
                ];
                function s(e1) {
                    return r.includes(e1);
                }
                function a(e1, t) {
                    t.confident && (t.deoptPath = e1, t.confident = !1);
                }
                const o = new Map([
                    [
                        "undefined",
                        void 0
                    ],
                    [
                        "Infinity",
                        1 / 0
                    ],
                    [
                        "NaN",
                        NaN
                    ]
                ]);
                function l(e1, t) {
                    const { node: r } = e1, { seen: u } = t;
                    if (u.has(r)) {
                        const n = u.get(r);
                        return n.resolved ? n.value : void a(e1, t);
                    }
                    {
                        const p = {
                            resolved: !1
                        };
                        u.set(r, p);
                        const h = function(e1, t) {
                            if (t.confident) {
                                if (e1.isSequenceExpression()) {
                                    const n = e1.get("expressions");
                                    return l(n[n.length - 1], t);
                                }
                                if (e1.isStringLiteral() || e1.isNumericLiteral() || e1.isBooleanLiteral()) return e1.node.value;
                                if (e1.isNullLiteral()) return null;
                                if (e1.isTemplateLiteral()) return c(e1, e1.node.quasis, t);
                                if (e1.isTaggedTemplateExpression() && e1.get("tag").isMemberExpression()) {
                                    const n = e1.get("tag.object"), { node: { name: r } } = n, i = e1.get("tag.property");
                                    if (n.isIdentifier() && "String" === r && !e1.scope.getBinding(r) && i.isIdentifier() && "raw" === i.node.name) return c(e1, e1.node.quasi.quasis, t, !0);
                                }
                                if (e1.isConditionalExpression()) {
                                    const n = l(e1.get("test"), t);
                                    if (!t.confident) return;
                                    return l(n ? e1.get("consequent") : e1.get("alternate"), t);
                                }
                                if (e1.isExpressionWrapper()) return l(e1.get("expression"), t);
                                if (e1.isMemberExpression() && !e1.parentPath.isCallExpression({
                                    callee: e1.node
                                })) {
                                    const n = e1.get("property"), r = e1.get("object");
                                    if (r.isLiteral()) {
                                        const i = r.node.value, s = typeof i;
                                        let a = null;
                                        if (e1.node.computed) {
                                            if (a = l(n, t), !t.confident) return;
                                        } else n.isIdentifier() && (a = n.node.name);
                                        if (!("number" !== s && "string" !== s || null == a || "number" != typeof a && "string" != typeof a)) return i[a];
                                    }
                                }
                                if (e1.isReferencedIdentifier()) {
                                    const n = e1.scope.getBinding(e1.node.name);
                                    if (n) {
                                        if (n.constantViolations.length > 0 || e1.node.start < n.path.node.end) return void a(n.path, t);
                                        if (n.hasValue) return n.value;
                                    }
                                    const r = e1.node.name;
                                    if (o.has(r)) return n ? void a(n.path, t) : o.get(r);
                                    const i = e1.resolve();
                                    return i === e1 ? void a(e1, t) : l(i, t);
                                }
                                if (e1.isUnaryExpression({
                                    prefix: !0
                                })) {
                                    if ("void" === e1.node.operator) return;
                                    const n = e1.get("argument");
                                    if ("typeof" === e1.node.operator && (n.isFunction() || n.isClass())) return "function";
                                    const r = l(n, t);
                                    if (!t.confident) return;
                                    switch(e1.node.operator){
                                        case "!":
                                            return !r;
                                        case "+":
                                            return +r;
                                        case "-":
                                            return -r;
                                        case "~":
                                            return ~r;
                                        case "typeof":
                                            return typeof r;
                                    }
                                }
                                if (e1.isArrayExpression()) {
                                    const n = [], r = e1.get("elements");
                                    for (const e1 of r){
                                        const r = e1.evaluate();
                                        if (!r.confident) return void a(r.deopt, t);
                                        n.push(r.value);
                                    }
                                    return n;
                                }
                                if (e1.isObjectExpression()) {
                                    const n = {}, r = e1.get("properties");
                                    for (const e1 of r){
                                        if (e1.isObjectMethod() || e1.isSpreadElement()) return void a(e1, t);
                                        const r = e1.get("key");
                                        let i;
                                        if (e1.node.computed) {
                                            if (i = r.evaluate(), !i.confident) return void a(i.deopt, t);
                                            i = i.value;
                                        } else i = r.isIdentifier() ? r.node.name : r.node.value;
                                        let s = e1.get("value").evaluate();
                                        if (!s.confident) return void a(s.deopt, t);
                                        s = s.value, n[i] = s;
                                    }
                                    return n;
                                }
                                if (e1.isLogicalExpression()) {
                                    const n = t.confident, r = l(e1.get("left"), t), i = t.confident;
                                    t.confident = n;
                                    const s = l(e1.get("right"), t), a = t.confident;
                                    switch(e1.node.operator){
                                        case "||":
                                            if (t.confident = i && (!!r || a), !t.confident) return;
                                            return r || s;
                                        case "&&":
                                            if (t.confident = i && (!r || a), !t.confident) return;
                                            return r && s;
                                        case "??":
                                            if (t.confident = i && (null != r || a), !t.confident) return;
                                            return null != r ? r : s;
                                    }
                                }
                                if (e1.isBinaryExpression()) {
                                    const n = l(e1.get("left"), t);
                                    if (!t.confident) return;
                                    const r = l(e1.get("right"), t);
                                    if (!t.confident) return;
                                    switch(e1.node.operator){
                                        case "-":
                                            return n - r;
                                        case "+":
                                            return n + r;
                                        case "/":
                                            return n / r;
                                        case "*":
                                            return n * r;
                                        case "%":
                                            return n % r;
                                        case "**":
                                            return Math.pow(n, r);
                                        case "<":
                                            return n < r;
                                        case ">":
                                            return n > r;
                                        case "<=":
                                            return n <= r;
                                        case ">=":
                                            return n >= r;
                                        case "==":
                                            return n == r;
                                        case "!=":
                                            return n != r;
                                        case "===":
                                            return n === r;
                                        case "!==":
                                            return n !== r;
                                        case "|":
                                            return n | r;
                                        case "&":
                                            return n & r;
                                        case "^":
                                            return n ^ r;
                                        case "<<":
                                            return n << r;
                                        case ">>":
                                            return n >> r;
                                        case ">>>":
                                            return n >>> r;
                                    }
                                }
                                if (e1.isCallExpression()) {
                                    const r = e1.get("callee");
                                    let a, o;
                                    if (r.isIdentifier() && !e1.scope.getBinding(r.node.name) && s(r.node.name) && (o = n.g[r.node.name]), r.isMemberExpression()) {
                                        const e1 = r.get("object"), t = r.get("property");
                                        if (e1.isIdentifier() && t.isIdentifier() && s(e1.node.name) && !function(e1) {
                                            return i.includes(e1);
                                        }(t.node.name) && (a = n.g[e1.node.name], o = a[t.node.name]), e1.isLiteral() && t.isIdentifier()) {
                                            const n = typeof e1.node.value;
                                            "string" !== n && "number" !== n || (a = e1.node.value, o = a[t.node.name]);
                                        }
                                    }
                                    if (o) {
                                        const n = e1.get("arguments").map((e1)=>l(e1, t));
                                        if (!t.confident) return;
                                        return o.apply(a, n);
                                    }
                                }
                                a(e1, t);
                            }
                        }(e1, t);
                        return t.confident && (p.resolved = !0, p.value = h), h;
                    }
                }
                function c(e1, t, n, r = !1) {
                    let i = "", s = 0;
                    const a = e1.isTemplateLiteral() ? e1.get("expressions") : e1.get("quasi.expressions");
                    for (const e1 of t){
                        if (!n.confident) break;
                        i += r ? e1.value.raw : e1.value.cooked;
                        const t = a[s++];
                        t && (i += String(l(t, n)));
                    }
                    if (n.confident) return i;
                }
            },
            5983: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t._getKey = function(e1, t) {
                    const n = this.node, i = n[e1];
                    return Array.isArray(i) ? i.map((s, a)=>r.default.get({
                            listKey: e1,
                            parentPath: this,
                            parent: n,
                            container: i,
                            key: a
                        }).setContext(t)) : r.default.get({
                        parentPath: this,
                        parent: n,
                        container: n,
                        key: e1
                    }).setContext(t);
                }, t._getPattern = function(e1, t) {
                    let n = this;
                    for (const r of e1)n = "." === r ? n.parentPath : Array.isArray(n) ? n[r] : n.get(r, t);
                    return n;
                }, t.get = function(e1, t = !0) {
                    !0 === t && (t = this.context);
                    const n = e1.split(".");
                    return 1 === n.length ? this._getKey(e1, t) : this._getPattern(n, t);
                }, t.getAllNextSiblings = function() {
                    let e1 = this.key, t = this.getSibling(++e1);
                    const n = [];
                    for(; t.node;)n.push(t), t = this.getSibling(++e1);
                    return n;
                }, t.getAllPrevSiblings = function() {
                    let e1 = this.key, t = this.getSibling(--e1);
                    const n = [];
                    for(; t.node;)n.push(t), t = this.getSibling(--e1);
                    return n;
                }, t.getBindingIdentifierPaths = function(e1 = !1, t = !1) {
                    const n = [
                        this
                    ], r = Object.create(null);
                    for(; n.length;){
                        const i = n.shift();
                        if (!i) continue;
                        if (!i.node) continue;
                        const a = s.keys[i.node.type];
                        if (i.isIdentifier()) e1 ? (r[i.node.name] = r[i.node.name] || []).push(i) : r[i.node.name] = i;
                        else if (i.isExportDeclaration()) {
                            const e1 = i.get("declaration");
                            o(e1) && n.push(e1);
                        } else {
                            if (t) {
                                if (i.isFunctionDeclaration()) {
                                    n.push(i.get("id"));
                                    continue;
                                }
                                if (i.isFunctionExpression()) continue;
                            }
                            if (a) for(let e1 = 0; e1 < a.length; e1++){
                                const t = a[e1], r = i.get(t);
                                Array.isArray(r) ? n.push(...r) : r.node && n.push(r);
                            }
                        }
                    }
                    return r;
                }, t.getBindingIdentifiers = function(e1) {
                    return s(this.node, e1);
                }, t.getCompletionRecords = function() {
                    return m(this, {
                        canHaveBreak: !1,
                        shouldPopulateBreak: !1,
                        inCaseClause: !1
                    }).map((e1)=>e1.path);
                }, t.getNextSibling = function() {
                    return this.getSibling(this.key + 1);
                }, t.getOpposite = function() {
                    return "left" === this.key ? this.getSibling("right") : "right" === this.key ? this.getSibling("left") : null;
                }, t.getOuterBindingIdentifierPaths = function(e1 = !1) {
                    return this.getBindingIdentifierPaths(e1, !0);
                }, t.getOuterBindingIdentifiers = function(e1) {
                    return a(this.node, e1);
                }, t.getPrevSibling = function() {
                    return this.getSibling(this.key - 1);
                }, t.getSibling = function(e1) {
                    return r.default.get({
                        parentPath: this.parentPath,
                        parent: this.parent,
                        container: this.container,
                        listKey: this.listKey,
                        key: e1
                    }).setContext(this.context);
                };
                var r = n(763), i = n(6067);
                const { getBindingIdentifiers: s, getOuterBindingIdentifiers: a, isDeclaration: o, numericLiteral: l, unaryExpression: c } = i, u = 0, p = 1;
                function h(e1, t, n) {
                    return e1 && t.push(...m(e1, n)), t;
                }
                function d(e1) {
                    e1.forEach((e1)=>{
                        e1.type = p;
                    });
                }
                function f(e1, t) {
                    e1.forEach((e1)=>{
                        e1.path.isBreakStatement({
                            label: null
                        }) && (t ? e1.path.replaceWith(c("void", l(0))) : e1.path.remove());
                    });
                }
                function y(e1, t) {
                    const n = [];
                    if (t.canHaveBreak) {
                        let r = [];
                        for(let i = 0; i < e1.length; i++){
                            const s = e1[i], a = Object.assign({}, t, {
                                inCaseClause: !1
                            });
                            s.isBlockStatement() && (t.inCaseClause || t.shouldPopulateBreak) ? a.shouldPopulateBreak = !0 : a.shouldPopulateBreak = !1;
                            const o = m(s, a);
                            if (o.length > 0 && o.every((e1)=>e1.type === p)) {
                                r.length > 0 && o.every((e1)=>e1.path.isBreakStatement({
                                        label: null
                                    })) ? (d(r), n.push(...r), r.some((e1)=>e1.path.isDeclaration()) && (n.push(...o), f(o, !0)), f(o, !1)) : (n.push(...o), t.shouldPopulateBreak || f(o, !0));
                                break;
                            }
                            if (i === e1.length - 1) n.push(...o);
                            else {
                                r = [];
                                for(let e1 = 0; e1 < o.length; e1++){
                                    const t = o[e1];
                                    t.type === p && n.push(t), t.type === u && r.push(t);
                                }
                            }
                        }
                    } else if (e1.length) for(let r = e1.length - 1; r >= 0; r--){
                        const i = m(e1[r], t);
                        if (i.length > 1 || 1 === i.length && !i[0].path.isVariableDeclaration()) {
                            n.push(...i);
                            break;
                        }
                    }
                    return n;
                }
                function m(e1, t) {
                    let n = [];
                    if (e1.isIfStatement()) n = h(e1.get("consequent"), n, t), n = h(e1.get("alternate"), n, t);
                    else {
                        if (e1.isDoExpression() || e1.isFor() || e1.isWhile() || e1.isLabeledStatement()) return h(e1.get("body"), n, t);
                        if (e1.isProgram() || e1.isBlockStatement()) return y(e1.get("body"), t);
                        if (e1.isFunction()) return m(e1.get("body"), t);
                        if (e1.isTryStatement()) n = h(e1.get("block"), n, t), n = h(e1.get("handler"), n, t);
                        else {
                            if (e1.isCatchClause()) return h(e1.get("body"), n, t);
                            if (e1.isSwitchStatement()) return function(e1, t, n) {
                                let r = [];
                                for(let i = 0; i < e1.length; i++){
                                    const s = m(e1[i], n), a = [], o = [];
                                    for (const e1 of s)e1.type === u && a.push(e1), e1.type === p && o.push(e1);
                                    a.length && (r = a), t.push(...o);
                                }
                                return t.push(...r), t;
                            }(e1.get("cases"), n, t);
                            if (e1.isSwitchCase()) return y(e1.get("consequent"), {
                                canHaveBreak: !0,
                                shouldPopulateBreak: !1,
                                inCaseClause: !0
                            });
                            e1.isBreakStatement() ? n.push(function(e1) {
                                return {
                                    type: p,
                                    path: e1
                                };
                            }(e1)) : n.push(function(e1) {
                                return {
                                    type: u,
                                    path: e1
                                };
                            }(e1));
                        }
                    }
                    return n;
                }
            },
            763: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = t.SHOULD_STOP = t.SHOULD_SKIP = t.REMOVED = void 0;
                var r = n(8176), i = n(1227), s = n(5686), a = n(200), o = n(6067), l = o, c = n(9446), u = n(7848), p = n(531), h = n(326), d = n(383), f = n(2822), y = n(6309), m = n(4989), T = n(2981), g = n(1319), b = n(4825), E = n(5983), S = n(1801), P = n(8745);
                const { validate: x } = o, D = i("babel");
                t.REMOVED = 1, t.SHOULD_STOP = 2, t.SHOULD_SKIP = 4;
                class A {
                    constructor(e1, t){
                        this.contexts = [], this.state = null, this.opts = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container = null, this.listKey = null, this.key = null, this.node = null, this.type = null, this.parent = t, this.hub = e1, this.data = null, this.context = null, this.scope = null;
                    }
                    static get({ hub: e1, parentPath: t, parent: n, container: r, listKey: i, key: s }) {
                        if (!e1 && t && (e1 = t.hub), !n) throw new Error("To get a node path the parent needs to exist");
                        const a = r[s], o = c.getOrCreateCachedPaths(e1, n);
                        let l = o.get(a);
                        return l || (l = new A(e1, n), a && o.set(a, l)), l.setup(t, r, i, s), l;
                    }
                    getScope(e1) {
                        return this.isScope() ? new a.default(this) : e1;
                    }
                    setData(e1, t) {
                        return null == this.data && (this.data = Object.create(null)), this.data[e1] = t;
                    }
                    getData(e1, t) {
                        null == this.data && (this.data = Object.create(null));
                        let n = this.data[e1];
                        return void 0 === n && void 0 !== t && (n = this.data[e1] = t), n;
                    }
                    hasNode() {
                        return null != this.node;
                    }
                    buildCodeFrameError(e1, t = SyntaxError) {
                        return this.hub.buildError(this.node, e1, t);
                    }
                    traverse(e1, t) {
                        (0, s.default)(this.node, e1, this.scope, t, this);
                    }
                    set(e1, t) {
                        x(this.node, e1, t), this.node[e1] = t;
                    }
                    getPathLocation() {
                        const e1 = [];
                        let t = this;
                        do {
                            let n = t.key;
                            t.inList && (n = `${t.listKey}[${n}]`), e1.unshift(n);
                        }while (t = t.parentPath)
                        return e1.join(".");
                    }
                    debug(e1) {
                        D.enabled && D(`${this.getPathLocation()} ${this.type}: ${e1}`);
                    }
                    toString() {
                        return (0, u.default)(this.node).code;
                    }
                    get inList() {
                        return !!this.listKey;
                    }
                    set inList(e1) {
                        e1 || (this.listKey = null);
                    }
                    get parentKey() {
                        return this.listKey || this.key;
                    }
                    get shouldSkip() {
                        return !!(4 & this._traverseFlags);
                    }
                    set shouldSkip(e1) {
                        e1 ? this._traverseFlags |= 4 : this._traverseFlags &= -5;
                    }
                    get shouldStop() {
                        return !!(2 & this._traverseFlags);
                    }
                    set shouldStop(e1) {
                        e1 ? this._traverseFlags |= 2 : this._traverseFlags &= -3;
                    }
                    get removed() {
                        return !!(1 & this._traverseFlags);
                    }
                    set removed(e1) {
                        e1 ? this._traverseFlags |= 1 : this._traverseFlags &= -2;
                    }
                }
                Object.assign(A.prototype, p, h, d, f, y, m, T, g, b, E, S), A.prototype._guessExecutionStatusRelativeToDifferentFunctions = m._guessExecutionStatusRelativeTo;
                for (const e1 of l.TYPES){
                    const t = `is${e1}`, n = l[t];
                    A.prototype[t] = function(e1) {
                        return n(this.node, e1);
                    }, A.prototype[`assert${e1}`] = function(t) {
                        if (!n(this.node, t)) throw new TypeError(`Expected node path of type ${e1}`);
                    };
                }
                Object.assign(A.prototype, P);
                for (const e1 of Object.keys(r))"_" !== e1[0] && (l.TYPES.includes(e1) || l.TYPES.push(e1));
                var v = A;
                t.default = v;
            },
            326: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t._getTypeAnnotation = function() {
                    const e1 = this.node;
                    if (e1) {
                        if (e1.typeAnnotation) return e1.typeAnnotation;
                        if (!A.has(e1)) {
                            A.add(e1);
                            try {
                                var t;
                                let n = r[e1.type];
                                if (n) return n.call(this, e1);
                                if (n = r[this.parentPath.type], null != (t = n) && t.validParent) return this.parentPath.getTypeAnnotation();
                            } finally{
                                A.delete(e1);
                            }
                        }
                    } else if ("init" === this.key && this.parentPath.isVariableDeclarator()) {
                        const e1 = this.parentPath.parentPath, t = e1.parentPath;
                        return "left" === e1.key && t.isForInStatement() ? x() : "left" === e1.key && t.isForOfStatement() ? s() : D();
                    }
                }, t.baseTypeStrictlyMatches = function(e1) {
                    const t = this.getTypeAnnotation(), n = e1.getTypeAnnotation();
                    return !(a(t) || !u(t)) && n.type === t.type;
                }, t.couldBeBaseType = function(e1) {
                    const t = this.getTypeAnnotation();
                    if (a(t)) return !0;
                    if (S(t)) {
                        for (const n of t.types)if (a(n) || v(e1, n, !0)) return !0;
                        return !1;
                    }
                    return v(e1, t, !0);
                }, t.getTypeAnnotation = function() {
                    let e1 = this.getData("typeAnnotation");
                    return null != e1 || (e1 = this._getTypeAnnotation() || s(), (E(e1) || T(e1)) && (e1 = e1.typeAnnotation), this.setData("typeAnnotation", e1)), e1;
                }, t.isBaseType = function(e1, t) {
                    return v(e1, this.getTypeAnnotation(), t);
                }, t.isGenericType = function(e1) {
                    const t = this.getTypeAnnotation();
                    return !("Array" !== e1 || !(m(t) || o(t) || b(t))) || p(t) && h(t.id, {
                        name: e1
                    }) || g(t) && h(t.typeName, {
                        name: e1
                    });
                };
                var r = n(3239), i = n(6067);
                const { anyTypeAnnotation: s, isAnyTypeAnnotation: a, isArrayTypeAnnotation: o, isBooleanTypeAnnotation: l, isEmptyTypeAnnotation: c, isFlowBaseAnnotation: u, isGenericTypeAnnotation: p, isIdentifier: h, isMixedTypeAnnotation: d, isNumberTypeAnnotation: f, isStringTypeAnnotation: y, isTSArrayType: m, isTSTypeAnnotation: T, isTSTypeReference: g, isTupleTypeAnnotation: b, isTypeAnnotation: E, isUnionTypeAnnotation: S, isVoidTypeAnnotation: P, stringTypeAnnotation: x, voidTypeAnnotation: D } = i, A = new WeakSet;
                function v(e1, t, n) {
                    if ("string" === e1) return y(t);
                    if ("number" === e1) return f(t);
                    if ("boolean" === e1) return l(t);
                    if ("any" === e1) return a(t);
                    if ("mixed" === e1) return d(t);
                    if ("empty" === e1) return c(t);
                    if ("void" === e1) return P(t);
                    if (n) return !1;
                    throw new Error(`Unknown base type ${e1}`);
                }
            },
            475: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1) {
                    if (!this.isReferenced()) return;
                    const t = this.scope.getBinding(e1.name);
                    return t ? t.identifier.typeAnnotation ? t.identifier.typeAnnotation : function(e1, t, n) {
                        const r = [], s = [];
                        let a = c(e1, t, s);
                        const o = p(e1, t, n);
                        if (o) {
                            const t = c(e1, o.ifStatement);
                            a = a.filter((e1)=>t.indexOf(e1) < 0), r.push(o.typeAnnotation);
                        }
                        if (a.length) {
                            a.push(...s);
                            for (const e1 of a)r.push(e1.getTypeAnnotation());
                        }
                        if (r.length) return (0, i.createUnionType)(r);
                    }(t, this, e1.name) : "undefined" === e1.name ? l() : "NaN" === e1.name || "Infinity" === e1.name ? o() : void e1.name;
                };
                var r = n(6067), i = n(5193);
                const { BOOLEAN_NUMBER_BINARY_OPERATORS: s, createTypeAnnotationBasedOnTypeof: a, numberTypeAnnotation: o, voidTypeAnnotation: l } = r;
                function c(e1, t, n) {
                    const r = e1.constantViolations.slice();
                    return r.unshift(e1.path), r.filter((e1)=>{
                        const r = (e1 = e1.resolve())._guessExecutionStatusRelativeTo(t);
                        return n && "unknown" === r && n.push(e1), "before" === r;
                    });
                }
                function u(e1, t) {
                    const n = t.node.operator, r = t.get("right").resolve(), i = t.get("left").resolve();
                    let l, c, u;
                    if (i.isIdentifier({
                        name: e1
                    }) ? l = r : r.isIdentifier({
                        name: e1
                    }) && (l = i), l) return "===" === n ? l.getTypeAnnotation() : s.indexOf(n) >= 0 ? o() : void 0;
                    if ("===" !== n && "==" !== n) return;
                    if (i.isUnaryExpression({
                        operator: "typeof"
                    }) ? (c = i, u = r) : r.isUnaryExpression({
                        operator: "typeof"
                    }) && (c = r, u = i), !c) return;
                    if (!c.get("argument").isIdentifier({
                        name: e1
                    })) return;
                    if (u = u.resolve(), !u.isLiteral()) return;
                    const p = u.node.value;
                    return "string" == typeof p ? a(p) : void 0;
                }
                function p(e1, t, n) {
                    const r = function(e1, t, n) {
                        let r;
                        for(; r = t.parentPath;){
                            if (r.isIfStatement() || r.isConditionalExpression()) {
                                if ("test" === t.key) return;
                                return r;
                            }
                            if (r.isFunction() && r.parentPath.scope.getBinding(n) !== e1) return;
                            t = r;
                        }
                    }(e1, t, n);
                    if (!r) return;
                    const s = [
                        r.get("test")
                    ], a = [];
                    for(let e1 = 0; e1 < s.length; e1++){
                        const t = s[e1];
                        if (t.isLogicalExpression()) "&&" === t.node.operator && (s.push(t.get("left")), s.push(t.get("right")));
                        else if (t.isBinaryExpression()) {
                            const e1 = u(n, t);
                            e1 && a.push(e1);
                        }
                    }
                    return a.length ? {
                        typeAnnotation: (0, i.createUnionType)(a),
                        ifStatement: r
                    } : p(e1, r, n);
                }
            },
            3239: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ArrayExpression = v, t.AssignmentExpression = function() {
                    return this.get("right").getTypeAnnotation();
                }, t.BinaryExpression = function(e1) {
                    const t = e1.operator;
                    if (l.indexOf(t) >= 0) return g();
                    if (a.indexOf(t) >= 0) return d();
                    if ("+" === t) {
                        const e1 = this.get("right"), t = this.get("left");
                        return t.isBaseType("number") && e1.isBaseType("number") ? g() : t.isBaseType("string") || e1.isBaseType("string") ? b() : S([
                            b(),
                            g()
                        ]);
                    }
                }, t.BooleanLiteral = function() {
                    return d();
                }, t.CallExpression = function() {
                    const { callee: e1 } = this.node;
                    return O(e1) ? h(b()) : w(e1) || I(e1) || x(e1, {
                        name: "Array"
                    }) ? h(p()) : N(e1) ? h(E([
                        b(),
                        p()
                    ])) : F(this.get("callee"));
                }, t.ConditionalExpression = function() {
                    const e1 = [
                        this.get("consequent").getTypeAnnotation(),
                        this.get("alternate").getTypeAnnotation()
                    ];
                    return (0, s.createUnionType)(e1);
                }, t.ClassDeclaration = t.ClassExpression = t.FunctionDeclaration = t.ArrowFunctionExpression = t.FunctionExpression = function() {
                    return y(m("Function"));
                }, Object.defineProperty(t, "Identifier", {
                    enumerable: !0,
                    get: function() {
                        return i.default;
                    }
                }), t.LogicalExpression = function() {
                    const e1 = [
                        this.get("left").getTypeAnnotation(),
                        this.get("right").getTypeAnnotation()
                    ];
                    return (0, s.createUnionType)(e1);
                }, t.NewExpression = function(e1) {
                    if ("Identifier" === e1.callee.type) return y(e1.callee);
                }, t.NullLiteral = function() {
                    return T();
                }, t.NumericLiteral = function() {
                    return g();
                }, t.ObjectExpression = function() {
                    return y(m("Object"));
                }, t.ParenthesizedExpression = function() {
                    return this.get("expression").getTypeAnnotation();
                }, t.RegExpLiteral = function() {
                    return y(m("RegExp"));
                }, t.RestElement = C, t.SequenceExpression = function() {
                    return this.get("expressions").pop().getTypeAnnotation();
                }, t.StringLiteral = function() {
                    return b();
                }, t.TSAsExpression = A, t.TSNonNullExpression = function() {
                    return this.get("expression").getTypeAnnotation();
                }, t.TaggedTemplateExpression = function() {
                    return F(this.get("tag"));
                }, t.TemplateLiteral = function() {
                    return b();
                }, t.TypeCastExpression = D, t.UnaryExpression = function(e1) {
                    const t = e1.operator;
                    return "void" === t ? P() : c.indexOf(t) >= 0 ? g() : u.indexOf(t) >= 0 ? b() : o.indexOf(t) >= 0 ? d() : void 0;
                }, t.UpdateExpression = function(e1) {
                    const t = e1.operator;
                    if ("++" === t || "--" === t) return g();
                }, t.VariableDeclarator = function() {
                    if (this.get("id").isIdentifier()) return this.get("init").getTypeAnnotation();
                };
                var r = n(6067), i = n(475), s = n(5193);
                const { BOOLEAN_BINARY_OPERATORS: a, BOOLEAN_UNARY_OPERATORS: o, NUMBER_BINARY_OPERATORS: l, NUMBER_UNARY_OPERATORS: c, STRING_UNARY_OPERATORS: u, anyTypeAnnotation: p, arrayTypeAnnotation: h, booleanTypeAnnotation: d, buildMatchMemberExpression: f, genericTypeAnnotation: y, identifier: m, nullLiteralTypeAnnotation: T, numberTypeAnnotation: g, stringTypeAnnotation: b, tupleTypeAnnotation: E, unionTypeAnnotation: S, voidTypeAnnotation: P, isIdentifier: x } = r;
                function D(e1) {
                    return e1.typeAnnotation;
                }
                function A(e1) {
                    return e1.typeAnnotation;
                }
                function v() {
                    return y(m("Array"));
                }
                function C() {
                    return v();
                }
                D.validParent = !0, A.validParent = !0, C.validParent = !0;
                const w = f("Array.from"), O = f("Object.keys"), I = f("Object.values"), N = f("Object.entries");
                function F(e1) {
                    if ((e1 = e1.resolve()).isFunction()) {
                        const { node: t } = e1;
                        if (t.async) return t.generator ? y(m("AsyncIterator")) : y(m("Promise"));
                        if (t.generator) return y(m("Iterator"));
                        if (e1.node.returnType) return e1.node.returnType;
                    }
                }
            },
            5193: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.createUnionType = function(e1) {
                    return o(e1[0]) ? i ? i(e1) : a(e1) : s ? s(e1) : void 0;
                };
                var r = n(6067);
                const { createFlowUnionType: i, createTSUnionType: s, createUnionTypeAnnotation: a, isFlowType: o, isTSType: l } = r;
            },
            4989: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t._guessExecutionStatusRelativeTo = function(e1) {
                    return b(this, e1, new Map);
                }, t._resolve = function(e1, t) {
                    if (!(t && t.indexOf(this) >= 0)) if ((t = t || []).push(this), this.isVariableDeclarator()) {
                        if (this.get("id").isIdentifier()) return this.get("init").resolve(e1, t);
                    } else if (this.isReferencedIdentifier()) {
                        const n = this.scope.getBinding(this.node.name);
                        if (!n) return;
                        if (!n.constant) return;
                        if ("module" === n.kind) return;
                        if (n.path !== this) {
                            const r = n.path.resolve(e1, t);
                            if (this.find((e1)=>e1.node === r.node)) return;
                            return r;
                        }
                    } else {
                        if (this.isTypeCastExpression()) return this.get("expression").resolve(e1, t);
                        if (e1 && this.isMemberExpression()) {
                            const n = this.toComputedKey();
                            if (!c(n)) return;
                            const r = n.value, i = this.get("object").resolve(e1, t);
                            if (i.isObjectExpression()) {
                                const n = i.get("properties");
                                for (const i of n){
                                    if (!i.isProperty()) continue;
                                    const n = i.get("key");
                                    let s = i.isnt("computed") && n.isIdentifier({
                                        name: r
                                    });
                                    if (s = s || n.isLiteral({
                                        value: r
                                    }), s) return i.get("value").resolve(e1, t);
                                }
                            } else if (i.isArrayExpression() && !isNaN(+r)) {
                                const n = i.get("elements")[r];
                                if (n) return n.resolve(e1, t);
                            }
                        }
                    }
                }, t.canHaveVariableDeclarationOrExpression = function() {
                    return ("init" === this.key || "left" === this.key) && this.parentPath.isFor();
                }, t.canSwapBetweenExpressionAndStatement = function(e1) {
                    return !("body" !== this.key || !this.parentPath.isArrowFunctionExpression()) && (this.isExpression() ? a(e1) : !!this.isBlockStatement() && o(e1));
                }, t.equals = function(e1, t) {
                    return this.node[e1] === t;
                }, t.getSource = function() {
                    const e1 = this.node;
                    if (e1.end) {
                        const t = this.hub.getCode();
                        if (t) return t.slice(e1.start, e1.end);
                    }
                    return "";
                }, t.has = d, t.is = void 0, t.isCompletionRecord = function(e1) {
                    let t = this, n = !0;
                    do {
                        const { type: r, container: i } = t;
                        if (!n && (t.isFunction() || "StaticBlock" === r)) return !!e1;
                        if (n = !1, Array.isArray(i) && t.key !== i.length - 1) return !1;
                    }while ((t = t.parentPath) && !t.isProgram() && !t.isDoExpression())
                    return !0;
                }, t.isConstantExpression = function() {
                    if (this.isIdentifier()) {
                        const e1 = this.scope.getBinding(this.node.name);
                        return !!e1 && e1.constant;
                    }
                    if (this.isLiteral()) return !this.isRegExpLiteral() && (!this.isTemplateLiteral() || this.get("expressions").every((e1)=>e1.isConstantExpression()));
                    if (this.isUnaryExpression()) return "void" === this.node.operator && this.get("argument").isConstantExpression();
                    if (this.isBinaryExpression()) {
                        const { operator: e1 } = this.node;
                        return "in" !== e1 && "instanceof" !== e1 && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
                    }
                    return !1;
                }, t.isInStrictMode = function() {
                    return !!(this.isProgram() ? this : this.parentPath).find((e1)=>{
                        if (e1.isProgram({
                            sourceType: "module"
                        })) return !0;
                        if (e1.isClass()) return !0;
                        if (e1.isArrowFunctionExpression() && !e1.get("body").isBlockStatement()) return !1;
                        let t;
                        if (e1.isFunction()) t = e1.node.body;
                        else {
                            if (!e1.isProgram()) return !1;
                            t = e1.node;
                        }
                        for (const e1 of t.directives)if ("use strict" === e1.value.value) return !0;
                    });
                }, t.isNodeType = function(e1) {
                    return p(this.type, e1);
                }, t.isStatementOrBlock = function() {
                    return !this.parentPath.isLabeledStatement() && !a(this.container) && i.includes(this.key);
                }, t.isStatic = function() {
                    return this.scope.isStatic(this.node);
                }, t.isnt = function(e1) {
                    return !this.has(e1);
                }, t.matchesPattern = function(e1, t) {
                    return h(this.node, e1, t);
                }, t.referencesImport = function(e1, t) {
                    if (!this.isReferencedIdentifier()) {
                        if (this.isJSXMemberExpression() && this.node.property.name === t || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? u(this.node.property, {
                            value: t
                        }) : this.node.property.name === t)) {
                            const t = this.get("object");
                            return t.isReferencedIdentifier() && t.referencesImport(e1, "*");
                        }
                        return !1;
                    }
                    const n = this.scope.getBinding(this.node.name);
                    if (!n || "module" !== n.kind) return !1;
                    const r = n.path, i = r.parentPath;
                    return !!i.isImportDeclaration() && i.node.source.value === e1 && (!t || !(!r.isImportDefaultSpecifier() || "default" !== t) || !(!r.isImportNamespaceSpecifier() || "*" !== t) || !(!r.isImportSpecifier() || !l(r.node.imported, {
                        name: t
                    })));
                }, t.resolve = function(e1, t) {
                    return this._resolve(e1, t) || this;
                }, t.willIMaybeExecuteBefore = function(e1) {
                    return "after" !== this._guessExecutionStatusRelativeTo(e1);
                };
                var r = n(6067);
                const { STATEMENT_OR_BLOCK_KEYS: i, VISITOR_KEYS: s, isBlockStatement: a, isExpression: o, isIdentifier: l, isLiteral: c, isStringLiteral: u, isType: p, matchesPattern: h } = r;
                function d(e1) {
                    const t = this.node && this.node[e1];
                    return t && Array.isArray(t) ? !!t.length : !!t;
                }
                const f = d;
                function y(e1) {
                    return e1.isProgram() ? e1 : (e1.parentPath.scope.getFunctionParent() || e1.parentPath.scope.getProgramParent()).path;
                }
                function m(e1, t) {
                    switch(e1){
                        case "LogicalExpression":
                        case "AssignmentPattern":
                            return "right" === t;
                        case "ConditionalExpression":
                        case "IfStatement":
                            return "consequent" === t || "alternate" === t;
                        case "WhileStatement":
                        case "DoWhileStatement":
                        case "ForInStatement":
                        case "ForOfStatement":
                            return "body" === t;
                        case "ForStatement":
                            return "body" === t || "update" === t;
                        case "SwitchStatement":
                            return "cases" === t;
                        case "TryStatement":
                            return "handler" === t;
                        case "OptionalMemberExpression":
                            return "property" === t;
                        case "OptionalCallExpression":
                            return "arguments" === t;
                        default:
                            return !1;
                    }
                }
                function T(e1, t) {
                    for(let n = 0; n < t; n++){
                        const t = e1[n];
                        if (m(t.parent.type, t.parentKey)) return !0;
                    }
                    return !1;
                }
                t.is = f;
                const g = Symbol();
                function b(e1, t, n) {
                    const r = {
                        this: y(e1),
                        target: y(t)
                    };
                    if (r.target.node !== r.this.node) return function(e1, t, n) {
                        let r, i = n.get(e1.node);
                        if (i) {
                            if (r = i.get(t.node)) return r === g ? "unknown" : r;
                        } else n.set(e1.node, i = new Map);
                        i.set(t.node, g);
                        const s = function(e1, t, n) {
                            if (!t.isFunctionDeclaration()) return "before" === b(e1, t, n) ? "before" : "unknown";
                            if (t.parentPath.isExportDeclaration()) return "unknown";
                            const r = t.scope.getBinding(t.node.id.name);
                            if (!r.references) return "before";
                            const i = r.referencePaths;
                            let s;
                            for (const r of i){
                                if (r.find((e1)=>e1.node === t.node)) continue;
                                if ("callee" !== r.key || !r.parentPath.isCallExpression()) return "unknown";
                                const i = b(e1, r, n);
                                if (s && s !== i) return "unknown";
                                s = i;
                            }
                            return s;
                        }(e1, t, n);
                        return i.set(t.node, s), s;
                    }(e1, r.target, n);
                    const i = {
                        target: t.getAncestry(),
                        this: e1.getAncestry()
                    };
                    if (i.target.indexOf(e1) >= 0) return "after";
                    if (i.this.indexOf(t) >= 0) return "before";
                    let a;
                    const o = {
                        target: 0,
                        this: 0
                    };
                    for(; !a && o.this < i.this.length;){
                        const e1 = i.this[o.this];
                        o.target = i.target.indexOf(e1), o.target >= 0 ? a = e1 : o.this++;
                    }
                    if (!a) throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
                    if (T(i.this, o.this - 1) || T(i.target, o.target - 1)) return "unknown";
                    const l = {
                        this: i.this[o.this - 1],
                        target: i.target[o.target - 1]
                    };
                    if (l.target.listKey && l.this.listKey && l.target.container === l.this.container) return l.target.key > l.this.key ? "before" : "after";
                    const c = s[a.type], u = c.indexOf(l.this.parentKey);
                    return c.indexOf(l.target.parentKey) > u ? "before" : "after";
                }
            },
            6698: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var r = n(6067), i = r;
                const { react: s } = r, { cloneNode: a, jsxExpressionContainer: o, variableDeclaration: l, variableDeclarator: c } = i, u = {
                    ReferencedIdentifier (e1, t) {
                        if (e1.isJSXIdentifier() && s.isCompatTag(e1.node.name) && !e1.parentPath.isJSXMemberExpression()) return;
                        if ("this" === e1.node.name) {
                            let n = e1.scope;
                            do {
                                if (n.path.isFunction() && !n.path.isArrowFunctionExpression()) break;
                            }while (n = n.parent)
                            n && t.breakOnScopePaths.push(n.path);
                        }
                        const n = e1.scope.getBinding(e1.node.name);
                        if (n) {
                            for (const r of n.constantViolations)if (r.scope !== n.path.scope) return t.mutableBinding = !0, void e1.stop();
                            n === t.scope.getBinding(e1.node.name) && (t.bindings[e1.node.name] = n);
                        }
                    }
                };
                t.default = class {
                    constructor(e1, t){
                        this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = !1, this.scopes = [], this.scope = t, this.path = e1, this.attachAfter = !1;
                    }
                    isCompatibleScope(e1) {
                        for (const t of Object.keys(this.bindings)){
                            const n = this.bindings[t];
                            if (!e1.bindingIdentifierEquals(t, n.identifier)) return !1;
                        }
                        return !0;
                    }
                    getCompatibleScopes() {
                        let e1 = this.path.scope;
                        do {
                            if (!this.isCompatibleScope(e1)) break;
                            if (this.scopes.push(e1), this.breakOnScopePaths.indexOf(e1.path) >= 0) break;
                        }while (e1 = e1.parent)
                    }
                    getAttachmentPath() {
                        let e1 = this._getAttachmentPath();
                        if (!e1) return;
                        let t = e1.scope;
                        if (t.path === e1 && (t = e1.scope.parent), t.path.isProgram() || t.path.isFunction()) for (const n of Object.keys(this.bindings)){
                            if (!t.hasOwnBinding(n)) continue;
                            const r = this.bindings[n];
                            if ("param" !== r.kind && "params" !== r.path.parentKey && this.getAttachmentParentForPath(r.path).key >= e1.key) {
                                this.attachAfter = !0, e1 = r.path;
                                for (const t of r.constantViolations)this.getAttachmentParentForPath(t).key > e1.key && (e1 = t);
                            }
                        }
                        return e1;
                    }
                    _getAttachmentPath() {
                        const e1 = this.scopes.pop();
                        if (e1) {
                            if (e1.path.isFunction()) {
                                if (!this.hasOwnParamBindings(e1)) return this.getNextScopeAttachmentParent();
                                {
                                    if (this.scope === e1) return;
                                    const t = e1.path.get("body").get("body");
                                    for(let e1 = 0; e1 < t.length; e1++)if (!t[e1].node._blockHoist) return t[e1];
                                }
                            } else if (e1.path.isProgram()) return this.getNextScopeAttachmentParent();
                        }
                    }
                    getNextScopeAttachmentParent() {
                        const e1 = this.scopes.pop();
                        if (e1) return this.getAttachmentParentForPath(e1.path);
                    }
                    getAttachmentParentForPath(e1) {
                        do {
                            if (!e1.parentPath || Array.isArray(e1.container) && e1.isStatement()) return e1;
                        }while (e1 = e1.parentPath)
                    }
                    hasOwnParamBindings(e1) {
                        for (const t of Object.keys(this.bindings)){
                            if (!e1.hasOwnBinding(t)) continue;
                            const n = this.bindings[t];
                            if ("param" === n.kind && n.constant) return !0;
                        }
                        return !1;
                    }
                    run() {
                        if (this.path.traverse(u, this), this.mutableBinding) return;
                        this.getCompatibleScopes();
                        const e1 = this.getAttachmentPath();
                        if (!e1) return;
                        if (e1.getFunctionParent() === this.path.getFunctionParent()) return;
                        let t = e1.scope.generateUidIdentifier("ref");
                        const n = c(t, this.path.node), r = this.attachAfter ? "insertAfter" : "insertBefore", [i] = e1[r]([
                            e1.isVariableDeclarator() ? n : l("var", [
                                n
                            ])
                        ]), s = this.path.parentPath;
                        return s.isJSXElement() && this.path.container === s.node.children && (t = o(t)), this.path.replaceWith(a(t)), e1.isVariableDeclarator() ? i.get("init") : i.get("declarations.0.init");
                    }
                };
            },
            308: (e1, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.hooks = void 0, t.hooks = [
                    function(e1, t) {
                        if ("test" === e1.key && (t.isWhile() || t.isSwitchCase()) || "declaration" === e1.key && t.isExportDeclaration() || "body" === e1.key && t.isLabeledStatement() || "declarations" === e1.listKey && t.isVariableDeclaration() && 1 === t.node.declarations.length || "expression" === e1.key && t.isExpressionStatement()) return t.remove(), !0;
                    },
                    function(e1, t) {
                        if (t.isSequenceExpression() && 1 === t.node.expressions.length) return t.replaceWith(t.node.expressions[0]), !0;
                    },
                    function(e1, t) {
                        if (t.isBinary()) return "left" === e1.key ? t.replaceWith(t.node.right) : t.replaceWith(t.node.left), !0;
                    },
                    function(e1, t) {
                        if (t.isIfStatement() && "consequent" === e1.key || "body" === e1.key && (t.isLoop() || t.isArrowFunctionExpression())) return e1.replaceWith({
                            type: "BlockStatement",
                            body: []
                        }), !0;
                    }
                ];
            },
            8745: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.isBindingIdentifier = function() {
                    const { node: e1, parent: t } = this, n = this.parentPath.parent;
                    return p(e1) && i(e1, t, n);
                }, t.isBlockScoped = function() {
                    return s(this.node);
                }, t.isExpression = function() {
                    return this.isIdentifier() ? this.isReferencedIdentifier() : o(this.node);
                }, t.isFlow = function() {
                    const { node: e1 } = this;
                    return !(!l(e1) && (h(e1) ? "type" !== e1.importKind && "typeof" !== e1.importKind : a(e1) ? "type" !== e1.exportKind : !d(e1) || "type" !== e1.importKind && "typeof" !== e1.importKind));
                }, t.isForAwaitStatement = function() {
                    return D(this.node, {
                        await: !0
                    });
                }, t.isGenerated = function() {
                    return !this.isUser();
                }, t.isPure = function(e1) {
                    return this.scope.isPure(this.node, e1);
                }, t.isReferenced = function() {
                    return g(this.node, this.parent);
                }, t.isReferencedIdentifier = function(e1) {
                    const { node: t, parent: n } = this;
                    if (!p(t, e1) && !y(n, e1)) {
                        if (!f(t, e1)) return !1;
                        if (A(t.name)) return !1;
                    }
                    return g(t, n, this.parentPath.parent);
                }, t.isReferencedMemberExpression = function() {
                    const { node: e1, parent: t } = this;
                    return m(e1) && g(e1, t);
                }, t.isRestProperty = function() {
                    return T(this.node) && this.parentPath && this.parentPath.isObjectPattern();
                }, t.isScope = function() {
                    return b(this.node, this.parent);
                }, t.isSpreadProperty = function() {
                    return T(this.node) && this.parentPath && this.parentPath.isObjectExpression();
                }, t.isStatement = function() {
                    const { node: e1, parent: t } = this;
                    if (E(e1)) {
                        if (P(e1)) {
                            if (u(t, {
                                left: e1
                            })) return !1;
                            if (c(t, {
                                init: e1
                            })) return !1;
                        }
                        return !0;
                    }
                    return !1;
                }, t.isUser = function() {
                    return this.node && !!this.node.loc;
                }, t.isVar = function() {
                    return S(this.node);
                };
                var r = n(6067);
                const { isBinding: i, isBlockScoped: s, isExportDeclaration: a, isExpression: o, isFlow: l, isForStatement: c, isForXStatement: u, isIdentifier: p, isImportDeclaration: h, isImportSpecifier: d, isJSXIdentifier: f, isJSXMemberExpression: y, isMemberExpression: m, isRestElement: T, isReferenced: g, isScope: b, isStatement: E, isVar: S, isVariableDeclaration: P, react: x, isForOfStatement: D } = r, { isCompatTag: A } = x;
                t.isExistentialTypeParam = function() {
                    throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
                }, t.isNumericLiteralTypeAnnotation = function() {
                    throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
                };
            },
            8176: (e1, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.Var = t.User = t.Statement = t.SpreadProperty = t.Scope = t.RestProperty = t.ReferencedMemberExpression = t.ReferencedIdentifier = t.Referenced = t.Pure = t.NumericLiteralTypeAnnotation = t.Generated = t.ForAwaitStatement = t.Flow = t.Expression = t.ExistentialTypeParam = t.BlockScoped = t.BindingIdentifier = void 0, t.ReferencedIdentifier = [
                    "Identifier",
                    "JSXIdentifier"
                ], t.ReferencedMemberExpression = [
                    "MemberExpression"
                ], t.BindingIdentifier = [
                    "Identifier"
                ], t.Statement = [
                    "Statement"
                ], t.Expression = [
                    "Expression"
                ], t.Scope = [
                    "Scopable",
                    "Pattern"
                ], t.Referenced = null, t.BlockScoped = null, t.Var = [
                    "VariableDeclaration"
                ], t.User = null, t.Generated = null, t.Pure = null, t.Flow = [
                    "Flow",
                    "ImportDeclaration",
                    "ExportDeclaration",
                    "ImportSpecifier"
                ], t.RestProperty = [
                    "RestElement"
                ], t.SpreadProperty = [
                    "RestElement"
                ], t.ExistentialTypeParam = [
                    "ExistsTypeAnnotation"
                ], t.NumericLiteralTypeAnnotation = [
                    "NumberLiteralTypeAnnotation"
                ], t.ForAwaitStatement = [
                    "ForOfStatement"
                ];
            },
            4825: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t._containerInsert = function(e1, t) {
                    this.updateSiblingKeys(e1, t.length);
                    const n = [];
                    this.container.splice(e1, 0, ...t);
                    for(let i = 0; i < t.length; i++){
                        var r;
                        const t = e1 + i, s = this.getSibling(t);
                        n.push(s), null != (r = this.context) && r.queue && s.pushContext(this.context);
                    }
                    const i = this._getQueueContexts();
                    for (const e1 of n){
                        e1.setScope(), e1.debug("Inserted.");
                        for (const t of i)t.maybeQueue(e1, !0);
                    }
                    return n;
                }, t._containerInsertAfter = function(e1) {
                    return this._containerInsert(this.key + 1, e1);
                }, t._containerInsertBefore = function(e1) {
                    return this._containerInsert(this.key, e1);
                }, t._verifyNodeList = function(e1) {
                    if (!e1) return [];
                    Array.isArray(e1) || (e1 = [
                        e1
                    ]);
                    for(let t = 0; t < e1.length; t++){
                        const n = e1[t];
                        let r;
                        if (n ? "object" != typeof n ? r = "contains a non-object node" : n.type ? n instanceof s.default && (r = "has a NodePath when it expected a raw object") : r = "without a type" : r = "has falsy node", r) {
                            const e1 = Array.isArray(n) ? "array" : typeof n;
                            throw new Error(`Node list ${r} with the index of ${t} and type of ${e1}`);
                        }
                    }
                    return e1;
                }, t.hoist = function(e1 = this.scope) {
                    return new i.default(this, e1).run();
                }, t.insertAfter = function(e1) {
                    if (this._assertUnremoved(), this.isSequenceExpression()) return P(this.get("expressions")).insertAfter(e1);
                    const t = this._verifyNodeList(e1), { parentPath: n, parent: r } = this;
                    if (n.isExpressionStatement() || n.isLabeledStatement() || m(r) || n.isExportDefaultDeclaration() && this.isDeclaration()) return n.insertAfter(t.map((e1)=>T(e1) ? d(e1) : e1));
                    if (this.isNodeType("Expression") && !this.isJSXElement() && !n.isJSXElement() || n.isForStatement() && "init" === this.key) {
                        if (this.node) {
                            const e1 = this.node;
                            let { scope: r } = this;
                            if (r.path.isPattern()) return l(e1), this.replaceWith(p(o([], e1), [])), this.get("callee.body").insertAfter(t), [
                                this
                            ];
                            if (x(this)) t.unshift(e1);
                            else if (y(e1) && E(e1.callee)) t.unshift(e1), t.push(S());
                            else if (function(e1, t) {
                                if (!f(e1) || !g(e1.left)) return !1;
                                const n = t.getBlockParent();
                                return n.hasOwnBinding(e1.left.name) && n.getOwnBinding(e1.left.name).constantViolations.length <= 1;
                            }(e1, r)) t.unshift(e1), t.push(h(e1.left));
                            else if (r.isPure(e1, !0)) t.push(e1);
                            else {
                                n.isMethod({
                                    computed: !0,
                                    key: e1
                                }) && (r = r.parent);
                                const i = r.generateDeclaredUidIdentifier();
                                t.unshift(d(c("=", h(i), e1))), t.push(d(h(i)));
                            }
                        }
                        return this.replaceExpressionWithStatements(t);
                    }
                    if (Array.isArray(this.container)) return this._containerInsertAfter(t);
                    if (this.isStatementOrBlock()) {
                        const e1 = this.node, n = e1 && (!this.isExpressionStatement() || null != e1.expression);
                        return this.replaceWith(u(n ? [
                            e1
                        ] : [])), this.pushContainer("body", t);
                    }
                    throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
                }, t.insertBefore = function(e1) {
                    this._assertUnremoved();
                    const t = this._verifyNodeList(e1), { parentPath: n, parent: r } = this;
                    if (n.isExpressionStatement() || n.isLabeledStatement() || m(r) || n.isExportDefaultDeclaration() && this.isDeclaration()) return n.insertBefore(t);
                    if (this.isNodeType("Expression") && !this.isJSXElement() || n.isForStatement() && "init" === this.key) return this.node && t.push(this.node), this.replaceExpressionWithStatements(t);
                    if (Array.isArray(this.container)) return this._containerInsertBefore(t);
                    if (this.isStatementOrBlock()) {
                        const e1 = this.node, n = e1 && (!this.isExpressionStatement() || null != e1.expression);
                        return this.replaceWith(u(n ? [
                            e1
                        ] : [])), this.unshiftContainer("body", t);
                    }
                    throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
                }, t.pushContainer = function(e1, t) {
                    this._assertUnremoved();
                    const n = this._verifyNodeList(t), r = this.node[e1];
                    return s.default.get({
                        parentPath: this,
                        parent: this.node,
                        container: r,
                        listKey: e1,
                        key: r.length
                    }).setContext(this.context).replaceWithMultiple(n);
                }, t.unshiftContainer = function(e1, t) {
                    return this._assertUnremoved(), t = this._verifyNodeList(t), s.default.get({
                        parentPath: this,
                        parent: this.node,
                        container: this.node[e1],
                        listKey: e1,
                        key: 0
                    }).setContext(this.context)._containerInsertBefore(t);
                }, t.updateSiblingKeys = function(e1, t) {
                    if (!this.parent) return;
                    const n = (0, r.getCachedPaths)(this.hub, this.parent) || [];
                    for (const [, r] of n)"number" == typeof r.key && r.key >= e1 && (r.key += t);
                };
                var r = n(9446), i = n(6698), s = n(763), a = n(6067);
                const { arrowFunctionExpression: o, assertExpression: l, assignmentExpression: c, blockStatement: u, callExpression: p, cloneNode: h, expressionStatement: d, isAssignmentExpression: f, isCallExpression: y, isExportNamedDeclaration: m, isExpression: T, isIdentifier: g, isSequenceExpression: b, isSuper: E, thisExpression: S } = a, P = (e1)=>e1[e1.length - 1];
                function x(e1) {
                    return b(e1.parent) && (P(e1.parent.expressions) !== e1.node || x(e1.parentPath));
                }
            },
            1319: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t._assertUnremoved = function() {
                    if (this.removed) throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
                }, t._callRemovalHooks = function() {
                    for (const e1 of r.hooks)if (e1(this, this.parentPath)) return !0;
                }, t._markRemoved = function() {
                    this._traverseFlags |= s.SHOULD_SKIP | s.REMOVED, this.parent && (0, i.getCachedPaths)(this.hub, this.parent).delete(this.node), this.node = null;
                }, t._remove = function() {
                    Array.isArray(this.container) ? (this.container.splice(this.key, 1), this.updateSiblingKeys(this.key, -1)) : this._replaceWith(null);
                }, t._removeFromScope = function() {
                    const e1 = this.getBindingIdentifiers();
                    Object.keys(e1).forEach((e1)=>this.scope.removeBinding(e1));
                }, t.remove = function() {
                    var e1;
                    this._assertUnremoved(), this.resync(), null != (e1 = this.opts) && e1.noScope || this._removeFromScope(), this._callRemovalHooks() || (this.shareCommentsWithSiblings(), this._remove()), this._markRemoved();
                };
                var r = n(308), i = n(9446), s = n(763);
            },
            383: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t._replaceWith = function(e1) {
                    var t;
                    if (!this.container) throw new ReferenceError("Container is falsy");
                    this.inList ? w(this.parent, this.key, [
                        e1
                    ]) : w(this.parent, this.key, e1), this.debug(`Replace with ${null == e1 ? void 0 : e1.type}`), null == (t = (0, a.getCachedPaths)(this.hub, this.parent)) || t.set(e1, this).delete(this.node), this.node = this.container[this.key] = e1;
                }, t.replaceExpressionWithStatements = function(e1) {
                    this.resync();
                    const t = C(e1, this.scope);
                    if (t) return this.replaceWith(t)[0].get("expressions");
                    const n = this.getFunctionParent(), r = null == n ? void 0 : n.is("async"), s = null == n ? void 0 : n.is("generator"), a = p([], f(e1));
                    this.replaceWith(y(a, []));
                    const o = this.get("callee");
                    (0, c.default)(o.get("body"), (e1)=>{
                        this.scope.push({
                            id: e1
                        });
                    }, "var");
                    const l = this.get("callee").getCompletionRecords();
                    for (const e1 of l){
                        if (!e1.isExpressionStatement()) continue;
                        const t = e1.findParent((e1)=>e1.isLoop());
                        if (t) {
                            let n = t.getData("expressionReplacementReturnUid");
                            n ? n = g(n.name) : (n = o.scope.generateDeclaredUidIdentifier("ret"), o.get("body").pushContainer("body", v(m(n))), t.setData("expressionReplacementReturnUid", n)), e1.get("expression").replaceWith(h("=", m(n), e1.node.expression));
                        } else e1.replaceWith(v(e1.node.expression));
                    }
                    o.arrowFunctionToExpression();
                    const T = o, b = r && i.default.hasType(this.get("callee.body").node, "AwaitExpression", u), E = s && i.default.hasType(this.get("callee.body").node, "YieldExpression", u);
                    return b && (T.set("async", !0), E || this.replaceWith(d(this.node))), E && (T.set("generator", !0), this.replaceWith(O(this.node, !0))), T.get("body.body");
                }, t.replaceInline = function(e1) {
                    if (this.resync(), Array.isArray(e1)) {
                        if (Array.isArray(this.container)) {
                            e1 = this._verifyNodeList(e1);
                            const t = this._containerInsertAfter(e1);
                            return this.remove(), t;
                        }
                        return this.replaceWithMultiple(e1);
                    }
                    return this.replaceWith(e1);
                }, t.replaceWith = function(e1) {
                    if (this.resync(), this.removed) throw new Error("You can't replace this node, we've already removed it");
                    let t = e1 instanceof s.default ? e1.node : e1;
                    if (!t) throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
                    if (this.node === t) return [
                        this
                    ];
                    if (this.isProgram() && !x(t)) throw new Error("You can only replace a Program root node with another Program node");
                    if (Array.isArray(t)) throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
                    if ("string" == typeof t) throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
                    let n = "";
                    if (this.isNodeType("Statement") && P(t) && (this.canHaveVariableDeclarationOrExpression() || this.canSwapBetweenExpressionAndStatement(t) || this.parentPath.isExportDefaultDeclaration() || (t = T(t), n = "expression")), this.isNodeType("Expression") && D(t) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(t)) return this.replaceExpressionWithStatements([
                        t
                    ]);
                    const r = this.node;
                    return r && (S(t, r), A(r)), this._replaceWith(t), this.type = t.type, this.setScope(), this.requeue(), [
                        n ? this.get(n) : this
                    ];
                }, t.replaceWithMultiple = function(e1) {
                    var t;
                    this.resync(), e1 = this._verifyNodeList(e1), b(e1[0], this.node), E(e1[e1.length - 1], this.node), null == (t = (0, a.getCachedPaths)(this.hub, this.parent)) || t.delete(this.node), this.node = this.container[this.key] = null;
                    const n = this.insertAfter(e1);
                    return this.node ? this.requeue() : this.remove(), n;
                }, t.replaceWithSourceString = function(e1) {
                    let t;
                    this.resync();
                    try {
                        e1 = `(${e1})`, t = (0, o.parse)(e1);
                    } catch (t) {
                        const n = t.loc;
                        throw n && (t.message += " - make sure this is an expression.\n" + (0, r.codeFrameColumns)(e1, {
                            start: {
                                line: n.line,
                                column: n.column + 1
                            }
                        }), t.code = "BABEL_REPLACE_SOURCE_ERROR"), t;
                    }
                    const n = t.program.body[0].expression;
                    return i.default.removeProperties(n), this.replaceWith(n);
                };
                var r = n(4704), i = n(5686), s = n(763), a = n(9446), o = n(7191), l = n(6067), c = n(7438);
                const { FUNCTION_TYPES: u, arrowFunctionExpression: p, assignmentExpression: h, awaitExpression: d, blockStatement: f, callExpression: y, cloneNode: m, expressionStatement: T, identifier: g, inheritLeadingComments: b, inheritTrailingComments: E, inheritsComments: S, isExpression: P, isProgram: x, isStatement: D, removeComments: A, returnStatement: v, toSequenceExpression: C, validate: w, yieldExpression: O } = l;
            },
            8670: (e1, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0, t.default = class {
                    constructor({ identifier: e1, scope: t, path: n, kind: r }){
                        this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = !0, this.referencePaths = [], this.referenced = !1, this.references = 0, this.identifier = e1, this.scope = t, this.path = n, this.kind = r, "var" !== r && "hoisted" !== r || !function(e1) {
                            for(let { parentPath: t, key: n } = e1; t; { parentPath: t, key: n } = t){
                                if (t.isFunctionParent()) return !1;
                                if (t.isWhile() || t.isForXStatement() || t.isForStatement() && "body" === n) return !0;
                            }
                            return !1;
                        }(n) || this.reassign(n), this.clearValue();
                    }
                    deoptValue() {
                        this.clearValue(), this.hasDeoptedValue = !0;
                    }
                    setValue(e1) {
                        this.hasDeoptedValue || (this.hasValue = !0, this.value = e1);
                    }
                    clearValue() {
                        this.hasDeoptedValue = !1, this.hasValue = !1, this.value = null;
                    }
                    reassign(e1) {
                        this.constant = !1, -1 === this.constantViolations.indexOf(e1) && this.constantViolations.push(e1);
                    }
                    reference(e1) {
                        -1 === this.referencePaths.indexOf(e1) && (this.referenced = !0, this.references++, this.referencePaths.push(e1));
                    }
                    dereference() {
                        this.references--, this.referenced = !!this.references;
                    }
                };
            },
            200: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var r = n(6426), i = n(5686), s = n(8670), a = n(1272), o = n(6067), l = o, c = n(9446), u = n(7380);
                const { NOT_LOCAL_BINDING: p, callExpression: h, cloneNode: d, getBindingIdentifiers: f, identifier: y, isArrayExpression: m, isBinary: T, isClass: g, isClassBody: b, isClassDeclaration: E, isExportAllDeclaration: S, isExportDefaultDeclaration: P, isExportNamedDeclaration: x, isFunctionDeclaration: D, isIdentifier: A, isImportDeclaration: v, isLiteral: C, isMethod: w, isModuleSpecifier: O, isNullLiteral: I, isObjectExpression: N, isProperty: F, isPureish: k, isRegExpLiteral: L, isSuper: _, isTaggedTemplateExpression: M, isTemplateLiteral: B, isThisExpression: j, isUnaryExpression: R, isVariableDeclaration: U, matchesPattern: V, memberExpression: K, numericLiteral: W, toIdentifier: X, unaryExpression: Y, variableDeclaration: q, variableDeclarator: H, isRecordExpression: J, isTupleExpression: $, isObjectProperty: G, isTopicReference: z, isMetaProperty: Q, isPrivateName: Z, isExportDeclaration: ee } = o;
                function te(e1, t) {
                    switch(null == e1 ? void 0 : e1.type){
                        default:
                            var n;
                            if (v(e1) || ee(e1)) if ((S(e1) || x(e1) || v(e1)) && e1.source) te(e1.source, t);
                            else if ((x(e1) || v(e1)) && null != (n = e1.specifiers) && n.length) for (const n of e1.specifiers)te(n, t);
                            else (P(e1) || x(e1)) && e1.declaration && te(e1.declaration, t);
                            else O(e1) ? te(e1.local, t) : !C(e1) || I(e1) || L(e1) || B(e1) || t.push(e1.value);
                            break;
                        case "MemberExpression":
                        case "OptionalMemberExpression":
                        case "JSXMemberExpression":
                            te(e1.object, t), te(e1.property, t);
                            break;
                        case "Identifier":
                        case "JSXIdentifier":
                            t.push(e1.name);
                            break;
                        case "CallExpression":
                        case "OptionalCallExpression":
                        case "NewExpression":
                            te(e1.callee, t);
                            break;
                        case "ObjectExpression":
                        case "ObjectPattern":
                            for (const n of e1.properties)te(n, t);
                            break;
                        case "SpreadElement":
                        case "RestElement":
                        case "UnaryExpression":
                        case "UpdateExpression":
                            te(e1.argument, t);
                            break;
                        case "ObjectProperty":
                        case "ObjectMethod":
                        case "ClassProperty":
                        case "ClassMethod":
                        case "ClassPrivateProperty":
                        case "ClassPrivateMethod":
                            te(e1.key, t);
                            break;
                        case "ThisExpression":
                            t.push("this");
                            break;
                        case "Super":
                            t.push("super");
                            break;
                        case "Import":
                            t.push("import");
                            break;
                        case "DoExpression":
                            t.push("do");
                            break;
                        case "YieldExpression":
                            t.push("yield"), te(e1.argument, t);
                            break;
                        case "AwaitExpression":
                            t.push("await"), te(e1.argument, t);
                            break;
                        case "AssignmentExpression":
                            te(e1.left, t);
                            break;
                        case "VariableDeclarator":
                        case "FunctionExpression":
                        case "FunctionDeclaration":
                        case "ClassExpression":
                        case "ClassDeclaration":
                        case "PrivateName":
                            te(e1.id, t);
                            break;
                        case "ParenthesizedExpression":
                            te(e1.expression, t);
                            break;
                        case "MetaProperty":
                            te(e1.meta, t), te(e1.property, t);
                            break;
                        case "JSXElement":
                            te(e1.openingElement, t);
                            break;
                        case "JSXOpeningElement":
                            te(e1.name, t);
                            break;
                        case "JSXFragment":
                            te(e1.openingFragment, t);
                            break;
                        case "JSXOpeningFragment":
                            t.push("Fragment");
                            break;
                        case "JSXNamespacedName":
                            te(e1.namespace, t), te(e1.name, t);
                    }
                }
                const ne = {
                    ForStatement (e1) {
                        const t = e1.get("init");
                        if (t.isVar()) {
                            const { scope: n } = e1;
                            (n.getFunctionParent() || n.getProgramParent()).registerBinding("var", t);
                        }
                    },
                    Declaration (e1) {
                        e1.isBlockScoped() || e1.isImportDeclaration() || e1.isExportDeclaration() || (e1.scope.getFunctionParent() || e1.scope.getProgramParent()).registerDeclaration(e1);
                    },
                    ImportDeclaration (e1) {
                        e1.scope.getBlockParent().registerDeclaration(e1);
                    },
                    ReferencedIdentifier (e1, t) {
                        t.references.push(e1);
                    },
                    ForXStatement (e1, t) {
                        const n = e1.get("left");
                        if (n.isPattern() || n.isIdentifier()) t.constantViolations.push(e1);
                        else if (n.isVar()) {
                            const { scope: t } = e1;
                            (t.getFunctionParent() || t.getProgramParent()).registerBinding("var", n);
                        }
                    },
                    ExportDeclaration: {
                        exit (e1) {
                            const { node: t, scope: n } = e1;
                            if (S(t)) return;
                            const r = t.declaration;
                            if (E(r) || D(r)) {
                                const t = r.id;
                                if (!t) return;
                                const i = n.getBinding(t.name);
                                null == i || i.reference(e1);
                            } else if (U(r)) for (const t of r.declarations)for (const r of Object.keys(f(t))){
                                const t = n.getBinding(r);
                                null == t || t.reference(e1);
                            }
                        }
                    },
                    LabeledStatement (e1) {
                        e1.scope.getBlockParent().registerDeclaration(e1);
                    },
                    AssignmentExpression (e1, t) {
                        t.assignments.push(e1);
                    },
                    UpdateExpression (e1, t) {
                        t.constantViolations.push(e1);
                    },
                    UnaryExpression (e1, t) {
                        "delete" === e1.node.operator && t.constantViolations.push(e1);
                    },
                    BlockScoped (e1) {
                        let t = e1.scope;
                        if (t.path === e1 && (t = t.parent), t.getBlockParent().registerDeclaration(e1), e1.isClassDeclaration() && e1.node.id) {
                            const t = e1.node.id.name;
                            e1.scope.bindings[t] = e1.scope.parent.getBinding(t);
                        }
                    },
                    CatchClause (e1) {
                        e1.scope.registerBinding("let", e1);
                    },
                    Function (e1) {
                        const t = e1.get("params");
                        for (const n of t)e1.scope.registerBinding("param", n);
                        e1.isFunctionExpression() && e1.has("id") && !e1.get("id").node[p] && e1.scope.registerBinding("local", e1.get("id"), e1);
                    },
                    ClassExpression (e1) {
                        e1.has("id") && !e1.get("id").node[p] && e1.scope.registerBinding("local", e1);
                    }
                };
                let re = 0;
                class ie {
                    constructor(e1){
                        this.uid = void 0, this.path = void 0, this.block = void 0, this.labels = void 0, this.inited = void 0, this.bindings = void 0, this.references = void 0, this.globals = void 0, this.uids = void 0, this.data = void 0, this.crawling = void 0;
                        const { node: t } = e1, n = c.scope.get(t);
                        if ((null == n ? void 0 : n.path) === e1) return n;
                        c.scope.set(t, this), this.uid = re++, this.block = t, this.path = e1, this.labels = new Map, this.inited = !1;
                    }
                    get parent() {
                        var e1;
                        let t, n = this.path;
                        do {
                            const e1 = "key" === n.key || "decorators" === n.listKey;
                            n = n.parentPath, e1 && n.isMethod() && (n = n.parentPath), n && n.isScope() && (t = n);
                        }while (n && !t)
                        return null == (e1 = t) ? void 0 : e1.scope;
                    }
                    get parentBlock() {
                        return this.path.parent;
                    }
                    get hub() {
                        return this.path.hub;
                    }
                    traverse(e1, t, n) {
                        (0, i.default)(e1, t, this, n, this.path);
                    }
                    generateDeclaredUidIdentifier(e1) {
                        const t = this.generateUidIdentifier(e1);
                        return this.push({
                            id: t
                        }), d(t);
                    }
                    generateUidIdentifier(e1) {
                        return y(this.generateUid(e1));
                    }
                    generateUid(e1 = "temp") {
                        let t;
                        e1 = X(e1).replace(/^_+/, "").replace(/[0-9]+$/g, "");
                        let n = 1;
                        do {
                            t = this._generateUid(e1, n), n++;
                        }while (this.hasLabel(t) || this.hasBinding(t) || this.hasGlobal(t) || this.hasReference(t))
                        const r = this.getProgramParent();
                        return r.references[t] = !0, r.uids[t] = !0, t;
                    }
                    _generateUid(e1, t) {
                        let n = e1;
                        return t > 1 && (n += t), `_${n}`;
                    }
                    generateUidBasedOnNode(e1, t) {
                        const n = [];
                        te(e1, n);
                        let r = n.join("$");
                        return r = r.replace(/^_/, "") || t || "ref", this.generateUid(r.slice(0, 20));
                    }
                    generateUidIdentifierBasedOnNode(e1, t) {
                        return y(this.generateUidBasedOnNode(e1, t));
                    }
                    isStatic(e1) {
                        if (j(e1) || _(e1) || z(e1)) return !0;
                        if (A(e1)) {
                            const t = this.getBinding(e1.name);
                            return t ? t.constant : this.hasBinding(e1.name);
                        }
                        return !1;
                    }
                    maybeGenerateMemoised(e1, t) {
                        if (this.isStatic(e1)) return null;
                        {
                            const n = this.generateUidIdentifierBasedOnNode(e1);
                            return t ? n : (this.push({
                                id: n
                            }), d(n));
                        }
                    }
                    checkBlockScopedCollisions(e1, t, n, r) {
                        if ("param" !== t && "local" !== e1.kind && ("let" === t || "let" === e1.kind || "const" === e1.kind || "module" === e1.kind || "param" === e1.kind && "const" === t)) throw this.hub.buildError(r, `Duplicate declaration "${n}"`, TypeError);
                    }
                    rename(e1, t) {
                        const n = this.getBinding(e1);
                        n && (t || (t = this.generateUidIdentifier(e1).name), new r.default(n, e1, t).rename(arguments[2]));
                    }
                    _renameFromMap(e1, t, n, r) {
                        e1[t] && (e1[n] = r, e1[t] = null);
                    }
                    dump() {
                        const e1 = "-".repeat(60);
                        console.log(e1);
                        let t = this;
                        do {
                            console.log("#", t.block.type);
                            for (const e1 of Object.keys(t.bindings)){
                                const n = t.bindings[e1];
                                console.log(" -", e1, {
                                    constant: n.constant,
                                    references: n.references,
                                    violations: n.constantViolations.length,
                                    kind: n.kind
                                });
                            }
                        }while (t = t.parent)
                        console.log(e1);
                    }
                    toArray(e1, t, n) {
                        if (A(e1)) {
                            const t = this.getBinding(e1.name);
                            if (null != t && t.constant && t.path.isGenericType("Array")) return e1;
                        }
                        if (m(e1)) return e1;
                        if (A(e1, {
                            name: "arguments"
                        })) return h(K(K(K(y("Array"), y("prototype")), y("slice")), y("call")), [
                            e1
                        ]);
                        let r;
                        const i = [
                            e1
                        ];
                        return !0 === t ? r = "toConsumableArray" : "number" == typeof t ? (i.push(W(t)), r = "slicedToArray") : r = "toArray", n && (i.unshift(this.hub.addHelper(r)), r = "maybeArrayLike"), h(this.hub.addHelper(r), i);
                    }
                    hasLabel(e1) {
                        return !!this.getLabel(e1);
                    }
                    getLabel(e1) {
                        return this.labels.get(e1);
                    }
                    registerLabel(e1) {
                        this.labels.set(e1.node.label.name, e1);
                    }
                    registerDeclaration(e1) {
                        if (e1.isLabeledStatement()) this.registerLabel(e1);
                        else if (e1.isFunctionDeclaration()) this.registerBinding("hoisted", e1.get("id"), e1);
                        else if (e1.isVariableDeclaration()) {
                            const t = e1.get("declarations"), { kind: n } = e1.node;
                            for (const e1 of t)this.registerBinding("using" === n || "await using" === n ? "const" : n, e1);
                        } else if (e1.isClassDeclaration()) {
                            if (e1.node.declare) return;
                            this.registerBinding("let", e1);
                        } else if (e1.isImportDeclaration()) {
                            const t = "type" === e1.node.importKind || "typeof" === e1.node.importKind, n = e1.get("specifiers");
                            for (const e1 of n){
                                const n = t || e1.isImportSpecifier() && ("type" === e1.node.importKind || "typeof" === e1.node.importKind);
                                this.registerBinding(n ? "unknown" : "module", e1);
                            }
                        } else if (e1.isExportDeclaration()) {
                            const t = e1.get("declaration");
                            (t.isClassDeclaration() || t.isFunctionDeclaration() || t.isVariableDeclaration()) && this.registerDeclaration(t);
                        } else this.registerBinding("unknown", e1);
                    }
                    buildUndefinedNode() {
                        return Y("void", W(0), !0);
                    }
                    registerConstantViolation(e1) {
                        const t = e1.getBindingIdentifiers();
                        for (const r of Object.keys(t)){
                            var n;
                            null == (n = this.getBinding(r)) || n.reassign(e1);
                        }
                    }
                    registerBinding(e1, t, n = t) {
                        if (!e1) throw new ReferenceError("no `kind`");
                        if (t.isVariableDeclaration()) {
                            const n = t.get("declarations");
                            for (const t of n)this.registerBinding(e1, t);
                            return;
                        }
                        const r = this.getProgramParent(), i = t.getOuterBindingIdentifiers(!0);
                        for (const t of Object.keys(i)){
                            r.references[t] = !0;
                            for (const r of i[t]){
                                const i = this.getOwnBinding(t);
                                if (i) {
                                    if (i.identifier === r) continue;
                                    this.checkBlockScopedCollisions(i, e1, t, r);
                                }
                                i ? this.registerConstantViolation(n) : this.bindings[t] = new s.default({
                                    identifier: r,
                                    scope: this,
                                    path: n,
                                    kind: e1
                                });
                            }
                        }
                    }
                    addGlobal(e1) {
                        this.globals[e1.name] = e1;
                    }
                    hasUid(e1) {
                        let t = this;
                        do {
                            if (t.uids[e1]) return !0;
                        }while (t = t.parent)
                        return !1;
                    }
                    hasGlobal(e1) {
                        let t = this;
                        do {
                            if (t.globals[e1]) return !0;
                        }while (t = t.parent)
                        return !1;
                    }
                    hasReference(e1) {
                        return !!this.getProgramParent().references[e1];
                    }
                    isPure(e1, t) {
                        if (A(e1)) {
                            const n = this.getBinding(e1.name);
                            return !!n && (!t || n.constant);
                        }
                        if (j(e1) || Q(e1) || z(e1) || Z(e1)) return !0;
                        var n, r, i;
                        if (g(e1)) return !(e1.superClass && !this.isPure(e1.superClass, t)) && !((null == (n = e1.decorators) ? void 0 : n.length) > 0) && this.isPure(e1.body, t);
                        if (b(e1)) {
                            for (const n of e1.body)if (!this.isPure(n, t)) return !1;
                            return !0;
                        }
                        if (T(e1)) return this.isPure(e1.left, t) && this.isPure(e1.right, t);
                        if (m(e1) || $(e1)) {
                            for (const n of e1.elements)if (null !== n && !this.isPure(n, t)) return !1;
                            return !0;
                        }
                        if (N(e1) || J(e1)) {
                            for (const n of e1.properties)if (!this.isPure(n, t)) return !1;
                            return !0;
                        }
                        if (w(e1)) return !(e1.computed && !this.isPure(e1.key, t) || (null == (r = e1.decorators) ? void 0 : r.length) > 0);
                        if (F(e1)) return !(e1.computed && !this.isPure(e1.key, t) || (null == (i = e1.decorators) ? void 0 : i.length) > 0 || (G(e1) || e1.static) && null !== e1.value && !this.isPure(e1.value, t));
                        if (R(e1)) return this.isPure(e1.argument, t);
                        if (M(e1)) return V(e1.tag, "String.raw") && !this.hasBinding("String", !0) && this.isPure(e1.quasi, t);
                        if (B(e1)) {
                            for (const n of e1.expressions)if (!this.isPure(n, t)) return !1;
                            return !0;
                        }
                        return k(e1);
                    }
                    setData(e1, t) {
                        return this.data[e1] = t;
                    }
                    getData(e1) {
                        let t = this;
                        do {
                            const n = t.data[e1];
                            if (null != n) return n;
                        }while (t = t.parent)
                    }
                    removeData(e1) {
                        let t = this;
                        do {
                            null != t.data[e1] && (t.data[e1] = null);
                        }while (t = t.parent)
                    }
                    init() {
                        this.inited || (this.inited = !0, this.crawl());
                    }
                    crawl() {
                        const e1 = this.path;
                        this.references = Object.create(null), this.bindings = Object.create(null), this.globals = Object.create(null), this.uids = Object.create(null), this.data = Object.create(null);
                        const t = this.getProgramParent();
                        if (t.crawling) return;
                        const n = {
                            references: [],
                            constantViolations: [],
                            assignments: []
                        };
                        if (this.crawling = !0, "Program" !== e1.type && (0, u.isExplodedVisitor)(ne)) {
                            for (const t of ne.enter)t.call(n, e1, n);
                            const t = ne[e1.type];
                            if (t) for (const r of t.enter)r.call(n, e1, n);
                        }
                        e1.traverse(ne, n), this.crawling = !1;
                        for (const e1 of n.assignments){
                            const n = e1.getBindingIdentifiers();
                            for (const r of Object.keys(n))e1.scope.getBinding(r) || t.addGlobal(n[r]);
                            e1.scope.registerConstantViolation(e1);
                        }
                        for (const e1 of n.references){
                            const n = e1.scope.getBinding(e1.node.name);
                            n ? n.reference(e1) : t.addGlobal(e1.node);
                        }
                        for (const e1 of n.constantViolations)e1.scope.registerConstantViolation(e1);
                    }
                    push(e1) {
                        let t = this.path;
                        t.isPattern() ? t = this.getPatternParent().path : t.isBlockStatement() || t.isProgram() || (t = this.getBlockParent().path), t.isSwitchStatement() && (t = (this.getFunctionParent() || this.getProgramParent()).path);
                        const { init: n, unique: r, kind: i = "var", id: s } = e1;
                        if (!n && !r && ("var" === i || "let" === i) && t.isFunction() && !t.node.name && l.isCallExpression(t.parent, {
                            callee: t.node
                        }) && t.parent.arguments.length <= t.node.params.length && l.isIdentifier(s)) return t.pushContainer("params", s), void t.scope.registerBinding("param", t.get("params")[t.node.params.length - 1]);
                        (t.isLoop() || t.isCatchClause() || t.isFunction()) && (t.ensureBlock(), t = t.get("body"));
                        const a = null == e1._blockHoist ? 2 : e1._blockHoist, o = `declaration:${i}:${a}`;
                        let c = !r && t.getData(o);
                        if (!c) {
                            const e1 = q(i, []);
                            e1._blockHoist = a, [c] = t.unshiftContainer("body", [
                                e1
                            ]), r || t.setData(o, c);
                        }
                        const u = H(s, n), p = c.node.declarations.push(u);
                        t.scope.registerBinding(i, c.get("declarations")[p - 1]);
                    }
                    getProgramParent() {
                        let e1 = this;
                        do {
                            if (e1.path.isProgram()) return e1;
                        }while (e1 = e1.parent)
                        throw new Error("Couldn't find a Program");
                    }
                    getFunctionParent() {
                        let e1 = this;
                        do {
                            if (e1.path.isFunctionParent()) return e1;
                        }while (e1 = e1.parent)
                        return null;
                    }
                    getBlockParent() {
                        let e1 = this;
                        do {
                            if (e1.path.isBlockParent()) return e1;
                        }while (e1 = e1.parent)
                        throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
                    }
                    getPatternParent() {
                        let e1 = this;
                        do {
                            if (!e1.path.isPattern()) return e1.getBlockParent();
                        }while (e1 = e1.parent.parent)
                        throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
                    }
                    getAllBindings() {
                        const e1 = Object.create(null);
                        let t = this;
                        do {
                            for (const n of Object.keys(t.bindings))n in e1 == 0 && (e1[n] = t.bindings[n]);
                            t = t.parent;
                        }while (t)
                        return e1;
                    }
                    getAllBindingsOfKind(...e1) {
                        const t = Object.create(null);
                        for (const n of e1){
                            let e1 = this;
                            do {
                                for (const r of Object.keys(e1.bindings)){
                                    const i = e1.bindings[r];
                                    i.kind === n && (t[r] = i);
                                }
                                e1 = e1.parent;
                            }while (e1)
                        }
                        return t;
                    }
                    bindingIdentifierEquals(e1, t) {
                        return this.getBindingIdentifier(e1) === t;
                    }
                    getBinding(e1) {
                        let t, n = this;
                        do {
                            const i = n.getOwnBinding(e1);
                            var r;
                            if (i) {
                                if (null == (r = t) || !r.isPattern() || "param" === i.kind || "local" === i.kind) return i;
                            } else if (!i && "arguments" === e1 && n.path.isFunction() && !n.path.isArrowFunctionExpression()) break;
                            t = n.path;
                        }while (n = n.parent)
                    }
                    getOwnBinding(e1) {
                        return this.bindings[e1];
                    }
                    getBindingIdentifier(e1) {
                        var t;
                        return null == (t = this.getBinding(e1)) ? void 0 : t.identifier;
                    }
                    getOwnBindingIdentifier(e1) {
                        const t = this.bindings[e1];
                        return null == t ? void 0 : t.identifier;
                    }
                    hasOwnBinding(e1) {
                        return !!this.getOwnBinding(e1);
                    }
                    hasBinding(e1, t) {
                        var n, r, i;
                        return !(!e1 || !this.hasOwnBinding(e1) && ("boolean" == typeof t && (t = {
                            noGlobals: t
                        }), !this.parentHasBinding(e1, t) && (null != (n = t) && n.noUids || !this.hasUid(e1)) && (null != (r = t) && r.noGlobals || !ie.globals.includes(e1)) && (null != (i = t) && i.noGlobals || !ie.contextVariables.includes(e1))));
                    }
                    parentHasBinding(e1, t) {
                        var n;
                        return null == (n = this.parent) ? void 0 : n.hasBinding(e1, t);
                    }
                    moveBindingTo(e1, t) {
                        const n = this.getBinding(e1);
                        n && (n.scope.removeOwnBinding(e1), n.scope = t, t.bindings[e1] = n);
                    }
                    removeOwnBinding(e1) {
                        delete this.bindings[e1];
                    }
                    removeBinding(e1) {
                        var t;
                        null == (t = this.getBinding(e1)) || t.scope.removeOwnBinding(e1);
                        let n = this;
                        do {
                            n.uids[e1] && (n.uids[e1] = !1);
                        }while (n = n.parent)
                    }
                }
                t.default = ie, ie.globals = Object.keys(a.builtin), ie.contextVariables = [
                    "arguments",
                    "undefined",
                    "Infinity",
                    "NaN"
                ];
            },
            6426: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var r = n(3472), i = n(6067), s = n(4705), a = n(9432), o = n(7380);
                const l = {
                    ReferencedIdentifier ({ node: e1 }, t) {
                        e1.name === t.oldName && (e1.name = t.newName);
                    },
                    Scope (e1, t) {
                        e1.scope.bindingIdentifierEquals(t.oldName, t.binding.identifier) || (e1.skip(), e1.isMethod() && (0, s.requeueComputedKeyAndDecorators)(e1));
                    },
                    ObjectProperty ({ node: e1, scope: t }, n) {
                        const { name: r } = e1.key;
                        var i;
                        !e1.shorthand || r !== n.oldName && r !== n.newName || t.getBindingIdentifier(r) !== n.binding.identifier || (e1.shorthand = !1, null != (i = e1.extra) && i.shorthand && (e1.extra.shorthand = !1));
                    },
                    "AssignmentExpression|Declaration|VariableDeclarator" (e1, t) {
                        if (e1.isVariableDeclaration()) return;
                        const n = e1.getOuterBindingIdentifiers();
                        for(const e1 in n)e1 === t.oldName && (n[e1].name = t.newName);
                    }
                };
                t.default = class {
                    constructor(e1, t, n){
                        this.newName = n, this.oldName = t, this.binding = e1;
                    }
                    maybeConvertFromExportDeclaration(e1) {
                        const t = e1.parentPath;
                        if (t.isExportDeclaration()) {
                            if (t.isExportDefaultDeclaration()) {
                                const { declaration: e1 } = t.node;
                                if (i.isDeclaration(e1) && !e1.id) return;
                            }
                            t.isExportAllDeclaration() || (0, r.default)(t);
                        }
                    }
                    maybeConvertFromClassFunctionDeclaration(e1) {
                        return e1;
                    }
                    maybeConvertFromClassFunctionExpression(e1) {
                        return e1;
                    }
                    rename() {
                        const { binding: e1, oldName: t, newName: n } = this, { scope: r, path: i } = e1, s = i.find((e1)=>e1.isDeclaration() || e1.isFunctionExpression() || e1.isClassExpression());
                        s && s.getOuterBindingIdentifiers()[t] === e1.identifier && this.maybeConvertFromExportDeclaration(s);
                        const c = arguments[0] || r.block;
                        (0, a.traverseNode)(c, (0, o.explode)(l), r, this, r.path, {
                            discriminant: !0
                        }), arguments[0] || (r.removeOwnBinding(t), r.bindings[n] = e1, this.binding.identifier.name = n), s && (this.maybeConvertFromClassFunctionDeclaration(i), this.maybeConvertFromClassFunctionExpression(i));
                    }
                };
            },
            9432: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.traverseNode = function(e1, t, n, i, a, o, l) {
                    const c = s[e1.type];
                    if (!c) return !1;
                    const u = new r.default(n, t, i, a);
                    if (l) return (null == o || !o[a.parentKey]) && u.visitQueue([
                        a
                    ]);
                    for (const t of c)if ((null == o || !o[t]) && u.visit(e1, t)) return !0;
                    return !1;
                };
                var r = n(4165), i = n(6067);
                const { VISITOR_KEYS: s } = i;
            },
            7380: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.explode = p, t.isExplodedVisitor = u, t.merge = function(e1, t = [], n) {
                    const r = {};
                    for(let i = 0; i < e1.length; i++){
                        const s = p(e1[i]), a = t[i];
                        let o = s;
                        (a || n) && (o = f(o, a, n)), g(r, o);
                        for (const e1 of Object.keys(s)){
                            if (T(e1)) continue;
                            let t = s[e1];
                            (a || n) && (t = f(t, a, n)), g(r[e1] || (r[e1] = {}), t);
                        }
                    }
                    return r;
                }, t.verify = h;
                var r = n(8176), i = n(6067);
                const { DEPRECATED_KEYS: s, DEPRECATED_ALIASES: a, FLIPPED_ALIAS_KEYS: o, TYPES: l, __internal__deprecationWarning: c } = i;
                function u(e1) {
                    return null == e1 ? void 0 : e1._exploded;
                }
                function p(e1) {
                    if (u(e1)) return e1;
                    e1._exploded = !0;
                    for (const t of Object.keys(e1)){
                        if (T(t)) continue;
                        const n = t.split("|");
                        if (1 === n.length) continue;
                        const r = e1[t];
                        delete e1[t];
                        for (const t of n)e1[t] = r;
                    }
                    h(e1), delete e1.__esModule, function(e1) {
                        for (const t of Object.keys(e1)){
                            if (T(t)) continue;
                            const n = e1[t];
                            "function" == typeof n && (e1[t] = {
                                enter: n
                            });
                        }
                    }(e1), y(e1);
                    for (const t of Object.keys(e1)){
                        if (T(t)) continue;
                        if (!(t in r)) continue;
                        const n = e1[t];
                        for (const e1 of Object.keys(n))n[e1] = m(t, n[e1]);
                        delete e1[t];
                        const i = r[t];
                        if (null !== i) for (const t of i)e1[t] ? g(e1[t], n) : e1[t] = n;
                        else g(e1, n);
                    }
                    for (const t of Object.keys(e1)){
                        if (T(t)) continue;
                        let n = o[t];
                        if (t in s) {
                            const e1 = s[t];
                            c(t, e1, "Visitor "), n = [
                                e1
                            ];
                        } else if (t in a) {
                            const e1 = a[t];
                            c(t, e1, "Visitor "), n = o[e1];
                        }
                        if (!n) continue;
                        const r = e1[t];
                        delete e1[t];
                        for (const t of n){
                            const n = e1[t];
                            n ? g(n, r) : e1[t] = Object.assign({}, r);
                        }
                    }
                    for (const t of Object.keys(e1))T(t) || y(e1[t]);
                    return e1;
                }
                function h(e1) {
                    if (!e1._verified) {
                        if ("function" == typeof e1) throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
                        for (const t of Object.keys(e1)){
                            if ("enter" !== t && "exit" !== t || d(t, e1[t]), T(t)) continue;
                            if (l.indexOf(t) < 0) throw new Error(`You gave us a visitor for the node type ${t} but it's not a valid type`);
                            const n = e1[t];
                            if ("object" == typeof n) for (const e1 of Object.keys(n)){
                                if ("enter" !== e1 && "exit" !== e1) throw new Error(`You passed \`traverse()\` a visitor object with the property ${t} that has the invalid property ${e1}`);
                                d(`${t}.${e1}`, n[e1]);
                            }
                        }
                        e1._verified = !0;
                    }
                }
                function d(e1, t) {
                    const n = [].concat(t);
                    for (const t of n)if ("function" != typeof t) throw new TypeError(`Non-function found defined in ${e1} with type ${typeof t}`);
                }
                function f(e1, t, n) {
                    const r = {};
                    for (const i of [
                        "enter",
                        "exit"
                    ]){
                        let s = e1[i];
                        Array.isArray(s) && (s = s.map(function(e1) {
                            let r = e1;
                            return t && (r = function(n) {
                                e1.call(t, n, t);
                            }), n && (r = n(null == t ? void 0 : t.key, i, r)), r !== e1 && (r.toString = ()=>e1.toString()), r;
                        }), r[i] = s);
                    }
                    return r;
                }
                function y(e1) {
                    e1.enter && !Array.isArray(e1.enter) && (e1.enter = [
                        e1.enter
                    ]), e1.exit && !Array.isArray(e1.exit) && (e1.exit = [
                        e1.exit
                    ]);
                }
                function m(e1, t) {
                    const n = function(n) {
                        if (n[`is${e1}`]()) return t.apply(this, arguments);
                    };
                    return n.toString = ()=>t.toString(), n;
                }
                function T(e1) {
                    return "_" === e1[0] || "enter" === e1 || "exit" === e1 || "shouldSkip" === e1 || "denylist" === e1 || "noScope" === e1 || "skipKeys" === e1 || "blacklist" === e1;
                }
                function g(e1, t) {
                    for (const n of [
                        "enter",
                        "exit"
                    ])t[n] && (e1[n] = [].concat(e1[n] || [], t[n]));
                }
            },
            391: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1) {
                    if (!(0, r.default)(e1)) {
                        var t;
                        const n = null != (t = null == e1 ? void 0 : e1.type) ? t : JSON.stringify(e1);
                        throw new TypeError(`Not a valid node of type "${n}"`);
                    }
                };
                var r = n(4814);
            },
            163: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.assertAccessor = function(e1, t) {
                    s("Accessor", e1, t);
                }, t.assertAnyTypeAnnotation = function(e1, t) {
                    s("AnyTypeAnnotation", e1, t);
                }, t.assertArgumentPlaceholder = function(e1, t) {
                    s("ArgumentPlaceholder", e1, t);
                }, t.assertArrayExpression = function(e1, t) {
                    s("ArrayExpression", e1, t);
                }, t.assertArrayPattern = function(e1, t) {
                    s("ArrayPattern", e1, t);
                }, t.assertArrayTypeAnnotation = function(e1, t) {
                    s("ArrayTypeAnnotation", e1, t);
                }, t.assertArrowFunctionExpression = function(e1, t) {
                    s("ArrowFunctionExpression", e1, t);
                }, t.assertAssignmentExpression = function(e1, t) {
                    s("AssignmentExpression", e1, t);
                }, t.assertAssignmentPattern = function(e1, t) {
                    s("AssignmentPattern", e1, t);
                }, t.assertAwaitExpression = function(e1, t) {
                    s("AwaitExpression", e1, t);
                }, t.assertBigIntLiteral = function(e1, t) {
                    s("BigIntLiteral", e1, t);
                }, t.assertBinary = function(e1, t) {
                    s("Binary", e1, t);
                }, t.assertBinaryExpression = function(e1, t) {
                    s("BinaryExpression", e1, t);
                }, t.assertBindExpression = function(e1, t) {
                    s("BindExpression", e1, t);
                }, t.assertBlock = function(e1, t) {
                    s("Block", e1, t);
                }, t.assertBlockParent = function(e1, t) {
                    s("BlockParent", e1, t);
                }, t.assertBlockStatement = function(e1, t) {
                    s("BlockStatement", e1, t);
                }, t.assertBooleanLiteral = function(e1, t) {
                    s("BooleanLiteral", e1, t);
                }, t.assertBooleanLiteralTypeAnnotation = function(e1, t) {
                    s("BooleanLiteralTypeAnnotation", e1, t);
                }, t.assertBooleanTypeAnnotation = function(e1, t) {
                    s("BooleanTypeAnnotation", e1, t);
                }, t.assertBreakStatement = function(e1, t) {
                    s("BreakStatement", e1, t);
                }, t.assertCallExpression = function(e1, t) {
                    s("CallExpression", e1, t);
                }, t.assertCatchClause = function(e1, t) {
                    s("CatchClause", e1, t);
                }, t.assertClass = function(e1, t) {
                    s("Class", e1, t);
                }, t.assertClassAccessorProperty = function(e1, t) {
                    s("ClassAccessorProperty", e1, t);
                }, t.assertClassBody = function(e1, t) {
                    s("ClassBody", e1, t);
                }, t.assertClassDeclaration = function(e1, t) {
                    s("ClassDeclaration", e1, t);
                }, t.assertClassExpression = function(e1, t) {
                    s("ClassExpression", e1, t);
                }, t.assertClassImplements = function(e1, t) {
                    s("ClassImplements", e1, t);
                }, t.assertClassMethod = function(e1, t) {
                    s("ClassMethod", e1, t);
                }, t.assertClassPrivateMethod = function(e1, t) {
                    s("ClassPrivateMethod", e1, t);
                }, t.assertClassPrivateProperty = function(e1, t) {
                    s("ClassPrivateProperty", e1, t);
                }, t.assertClassProperty = function(e1, t) {
                    s("ClassProperty", e1, t);
                }, t.assertCompletionStatement = function(e1, t) {
                    s("CompletionStatement", e1, t);
                }, t.assertConditional = function(e1, t) {
                    s("Conditional", e1, t);
                }, t.assertConditionalExpression = function(e1, t) {
                    s("ConditionalExpression", e1, t);
                }, t.assertContinueStatement = function(e1, t) {
                    s("ContinueStatement", e1, t);
                }, t.assertDebuggerStatement = function(e1, t) {
                    s("DebuggerStatement", e1, t);
                }, t.assertDecimalLiteral = function(e1, t) {
                    s("DecimalLiteral", e1, t);
                }, t.assertDeclaration = function(e1, t) {
                    s("Declaration", e1, t);
                }, t.assertDeclareClass = function(e1, t) {
                    s("DeclareClass", e1, t);
                }, t.assertDeclareExportAllDeclaration = function(e1, t) {
                    s("DeclareExportAllDeclaration", e1, t);
                }, t.assertDeclareExportDeclaration = function(e1, t) {
                    s("DeclareExportDeclaration", e1, t);
                }, t.assertDeclareFunction = function(e1, t) {
                    s("DeclareFunction", e1, t);
                }, t.assertDeclareInterface = function(e1, t) {
                    s("DeclareInterface", e1, t);
                }, t.assertDeclareModule = function(e1, t) {
                    s("DeclareModule", e1, t);
                }, t.assertDeclareModuleExports = function(e1, t) {
                    s("DeclareModuleExports", e1, t);
                }, t.assertDeclareOpaqueType = function(e1, t) {
                    s("DeclareOpaqueType", e1, t);
                }, t.assertDeclareTypeAlias = function(e1, t) {
                    s("DeclareTypeAlias", e1, t);
                }, t.assertDeclareVariable = function(e1, t) {
                    s("DeclareVariable", e1, t);
                }, t.assertDeclaredPredicate = function(e1, t) {
                    s("DeclaredPredicate", e1, t);
                }, t.assertDecorator = function(e1, t) {
                    s("Decorator", e1, t);
                }, t.assertDirective = function(e1, t) {
                    s("Directive", e1, t);
                }, t.assertDirectiveLiteral = function(e1, t) {
                    s("DirectiveLiteral", e1, t);
                }, t.assertDoExpression = function(e1, t) {
                    s("DoExpression", e1, t);
                }, t.assertDoWhileStatement = function(e1, t) {
                    s("DoWhileStatement", e1, t);
                }, t.assertEmptyStatement = function(e1, t) {
                    s("EmptyStatement", e1, t);
                }, t.assertEmptyTypeAnnotation = function(e1, t) {
                    s("EmptyTypeAnnotation", e1, t);
                }, t.assertEnumBody = function(e1, t) {
                    s("EnumBody", e1, t);
                }, t.assertEnumBooleanBody = function(e1, t) {
                    s("EnumBooleanBody", e1, t);
                }, t.assertEnumBooleanMember = function(e1, t) {
                    s("EnumBooleanMember", e1, t);
                }, t.assertEnumDeclaration = function(e1, t) {
                    s("EnumDeclaration", e1, t);
                }, t.assertEnumDefaultedMember = function(e1, t) {
                    s("EnumDefaultedMember", e1, t);
                }, t.assertEnumMember = function(e1, t) {
                    s("EnumMember", e1, t);
                }, t.assertEnumNumberBody = function(e1, t) {
                    s("EnumNumberBody", e1, t);
                }, t.assertEnumNumberMember = function(e1, t) {
                    s("EnumNumberMember", e1, t);
                }, t.assertEnumStringBody = function(e1, t) {
                    s("EnumStringBody", e1, t);
                }, t.assertEnumStringMember = function(e1, t) {
                    s("EnumStringMember", e1, t);
                }, t.assertEnumSymbolBody = function(e1, t) {
                    s("EnumSymbolBody", e1, t);
                }, t.assertExistsTypeAnnotation = function(e1, t) {
                    s("ExistsTypeAnnotation", e1, t);
                }, t.assertExportAllDeclaration = function(e1, t) {
                    s("ExportAllDeclaration", e1, t);
                }, t.assertExportDeclaration = function(e1, t) {
                    s("ExportDeclaration", e1, t);
                }, t.assertExportDefaultDeclaration = function(e1, t) {
                    s("ExportDefaultDeclaration", e1, t);
                }, t.assertExportDefaultSpecifier = function(e1, t) {
                    s("ExportDefaultSpecifier", e1, t);
                }, t.assertExportNamedDeclaration = function(e1, t) {
                    s("ExportNamedDeclaration", e1, t);
                }, t.assertExportNamespaceSpecifier = function(e1, t) {
                    s("ExportNamespaceSpecifier", e1, t);
                }, t.assertExportSpecifier = function(e1, t) {
                    s("ExportSpecifier", e1, t);
                }, t.assertExpression = function(e1, t) {
                    s("Expression", e1, t);
                }, t.assertExpressionStatement = function(e1, t) {
                    s("ExpressionStatement", e1, t);
                }, t.assertExpressionWrapper = function(e1, t) {
                    s("ExpressionWrapper", e1, t);
                }, t.assertFile = function(e1, t) {
                    s("File", e1, t);
                }, t.assertFlow = function(e1, t) {
                    s("Flow", e1, t);
                }, t.assertFlowBaseAnnotation = function(e1, t) {
                    s("FlowBaseAnnotation", e1, t);
                }, t.assertFlowDeclaration = function(e1, t) {
                    s("FlowDeclaration", e1, t);
                }, t.assertFlowPredicate = function(e1, t) {
                    s("FlowPredicate", e1, t);
                }, t.assertFlowType = function(e1, t) {
                    s("FlowType", e1, t);
                }, t.assertFor = function(e1, t) {
                    s("For", e1, t);
                }, t.assertForInStatement = function(e1, t) {
                    s("ForInStatement", e1, t);
                }, t.assertForOfStatement = function(e1, t) {
                    s("ForOfStatement", e1, t);
                }, t.assertForStatement = function(e1, t) {
                    s("ForStatement", e1, t);
                }, t.assertForXStatement = function(e1, t) {
                    s("ForXStatement", e1, t);
                }, t.assertFunction = function(e1, t) {
                    s("Function", e1, t);
                }, t.assertFunctionDeclaration = function(e1, t) {
                    s("FunctionDeclaration", e1, t);
                }, t.assertFunctionExpression = function(e1, t) {
                    s("FunctionExpression", e1, t);
                }, t.assertFunctionParent = function(e1, t) {
                    s("FunctionParent", e1, t);
                }, t.assertFunctionTypeAnnotation = function(e1, t) {
                    s("FunctionTypeAnnotation", e1, t);
                }, t.assertFunctionTypeParam = function(e1, t) {
                    s("FunctionTypeParam", e1, t);
                }, t.assertGenericTypeAnnotation = function(e1, t) {
                    s("GenericTypeAnnotation", e1, t);
                }, t.assertIdentifier = function(e1, t) {
                    s("Identifier", e1, t);
                }, t.assertIfStatement = function(e1, t) {
                    s("IfStatement", e1, t);
                }, t.assertImmutable = function(e1, t) {
                    s("Immutable", e1, t);
                }, t.assertImport = function(e1, t) {
                    s("Import", e1, t);
                }, t.assertImportAttribute = function(e1, t) {
                    s("ImportAttribute", e1, t);
                }, t.assertImportDeclaration = function(e1, t) {
                    s("ImportDeclaration", e1, t);
                }, t.assertImportDefaultSpecifier = function(e1, t) {
                    s("ImportDefaultSpecifier", e1, t);
                }, t.assertImportNamespaceSpecifier = function(e1, t) {
                    s("ImportNamespaceSpecifier", e1, t);
                }, t.assertImportOrExportDeclaration = function(e1, t) {
                    s("ImportOrExportDeclaration", e1, t);
                }, t.assertImportSpecifier = function(e1, t) {
                    s("ImportSpecifier", e1, t);
                }, t.assertIndexedAccessType = function(e1, t) {
                    s("IndexedAccessType", e1, t);
                }, t.assertInferredPredicate = function(e1, t) {
                    s("InferredPredicate", e1, t);
                }, t.assertInterfaceDeclaration = function(e1, t) {
                    s("InterfaceDeclaration", e1, t);
                }, t.assertInterfaceExtends = function(e1, t) {
                    s("InterfaceExtends", e1, t);
                }, t.assertInterfaceTypeAnnotation = function(e1, t) {
                    s("InterfaceTypeAnnotation", e1, t);
                }, t.assertInterpreterDirective = function(e1, t) {
                    s("InterpreterDirective", e1, t);
                }, t.assertIntersectionTypeAnnotation = function(e1, t) {
                    s("IntersectionTypeAnnotation", e1, t);
                }, t.assertJSX = function(e1, t) {
                    s("JSX", e1, t);
                }, t.assertJSXAttribute = function(e1, t) {
                    s("JSXAttribute", e1, t);
                }, t.assertJSXClosingElement = function(e1, t) {
                    s("JSXClosingElement", e1, t);
                }, t.assertJSXClosingFragment = function(e1, t) {
                    s("JSXClosingFragment", e1, t);
                }, t.assertJSXElement = function(e1, t) {
                    s("JSXElement", e1, t);
                }, t.assertJSXEmptyExpression = function(e1, t) {
                    s("JSXEmptyExpression", e1, t);
                }, t.assertJSXExpressionContainer = function(e1, t) {
                    s("JSXExpressionContainer", e1, t);
                }, t.assertJSXFragment = function(e1, t) {
                    s("JSXFragment", e1, t);
                }, t.assertJSXIdentifier = function(e1, t) {
                    s("JSXIdentifier", e1, t);
                }, t.assertJSXMemberExpression = function(e1, t) {
                    s("JSXMemberExpression", e1, t);
                }, t.assertJSXNamespacedName = function(e1, t) {
                    s("JSXNamespacedName", e1, t);
                }, t.assertJSXOpeningElement = function(e1, t) {
                    s("JSXOpeningElement", e1, t);
                }, t.assertJSXOpeningFragment = function(e1, t) {
                    s("JSXOpeningFragment", e1, t);
                }, t.assertJSXSpreadAttribute = function(e1, t) {
                    s("JSXSpreadAttribute", e1, t);
                }, t.assertJSXSpreadChild = function(e1, t) {
                    s("JSXSpreadChild", e1, t);
                }, t.assertJSXText = function(e1, t) {
                    s("JSXText", e1, t);
                }, t.assertLVal = function(e1, t) {
                    s("LVal", e1, t);
                }, t.assertLabeledStatement = function(e1, t) {
                    s("LabeledStatement", e1, t);
                }, t.assertLiteral = function(e1, t) {
                    s("Literal", e1, t);
                }, t.assertLogicalExpression = function(e1, t) {
                    s("LogicalExpression", e1, t);
                }, t.assertLoop = function(e1, t) {
                    s("Loop", e1, t);
                }, t.assertMemberExpression = function(e1, t) {
                    s("MemberExpression", e1, t);
                }, t.assertMetaProperty = function(e1, t) {
                    s("MetaProperty", e1, t);
                }, t.assertMethod = function(e1, t) {
                    s("Method", e1, t);
                }, t.assertMiscellaneous = function(e1, t) {
                    s("Miscellaneous", e1, t);
                }, t.assertMixedTypeAnnotation = function(e1, t) {
                    s("MixedTypeAnnotation", e1, t);
                }, t.assertModuleDeclaration = function(e1, t) {
                    (0, i.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), s("ModuleDeclaration", e1, t);
                }, t.assertModuleExpression = function(e1, t) {
                    s("ModuleExpression", e1, t);
                }, t.assertModuleSpecifier = function(e1, t) {
                    s("ModuleSpecifier", e1, t);
                }, t.assertNewExpression = function(e1, t) {
                    s("NewExpression", e1, t);
                }, t.assertNoop = function(e1, t) {
                    s("Noop", e1, t);
                }, t.assertNullLiteral = function(e1, t) {
                    s("NullLiteral", e1, t);
                }, t.assertNullLiteralTypeAnnotation = function(e1, t) {
                    s("NullLiteralTypeAnnotation", e1, t);
                }, t.assertNullableTypeAnnotation = function(e1, t) {
                    s("NullableTypeAnnotation", e1, t);
                }, t.assertNumberLiteral = function(e1, t) {
                    (0, i.default)("assertNumberLiteral", "assertNumericLiteral"), s("NumberLiteral", e1, t);
                }, t.assertNumberLiteralTypeAnnotation = function(e1, t) {
                    s("NumberLiteralTypeAnnotation", e1, t);
                }, t.assertNumberTypeAnnotation = function(e1, t) {
                    s("NumberTypeAnnotation", e1, t);
                }, t.assertNumericLiteral = function(e1, t) {
                    s("NumericLiteral", e1, t);
                }, t.assertObjectExpression = function(e1, t) {
                    s("ObjectExpression", e1, t);
                }, t.assertObjectMember = function(e1, t) {
                    s("ObjectMember", e1, t);
                }, t.assertObjectMethod = function(e1, t) {
                    s("ObjectMethod", e1, t);
                }, t.assertObjectPattern = function(e1, t) {
                    s("ObjectPattern", e1, t);
                }, t.assertObjectProperty = function(e1, t) {
                    s("ObjectProperty", e1, t);
                }, t.assertObjectTypeAnnotation = function(e1, t) {
                    s("ObjectTypeAnnotation", e1, t);
                }, t.assertObjectTypeCallProperty = function(e1, t) {
                    s("ObjectTypeCallProperty", e1, t);
                }, t.assertObjectTypeIndexer = function(e1, t) {
                    s("ObjectTypeIndexer", e1, t);
                }, t.assertObjectTypeInternalSlot = function(e1, t) {
                    s("ObjectTypeInternalSlot", e1, t);
                }, t.assertObjectTypeProperty = function(e1, t) {
                    s("ObjectTypeProperty", e1, t);
                }, t.assertObjectTypeSpreadProperty = function(e1, t) {
                    s("ObjectTypeSpreadProperty", e1, t);
                }, t.assertOpaqueType = function(e1, t) {
                    s("OpaqueType", e1, t);
                }, t.assertOptionalCallExpression = function(e1, t) {
                    s("OptionalCallExpression", e1, t);
                }, t.assertOptionalIndexedAccessType = function(e1, t) {
                    s("OptionalIndexedAccessType", e1, t);
                }, t.assertOptionalMemberExpression = function(e1, t) {
                    s("OptionalMemberExpression", e1, t);
                }, t.assertParenthesizedExpression = function(e1, t) {
                    s("ParenthesizedExpression", e1, t);
                }, t.assertPattern = function(e1, t) {
                    s("Pattern", e1, t);
                }, t.assertPatternLike = function(e1, t) {
                    s("PatternLike", e1, t);
                }, t.assertPipelineBareFunction = function(e1, t) {
                    s("PipelineBareFunction", e1, t);
                }, t.assertPipelinePrimaryTopicReference = function(e1, t) {
                    s("PipelinePrimaryTopicReference", e1, t);
                }, t.assertPipelineTopicExpression = function(e1, t) {
                    s("PipelineTopicExpression", e1, t);
                }, t.assertPlaceholder = function(e1, t) {
                    s("Placeholder", e1, t);
                }, t.assertPrivate = function(e1, t) {
                    s("Private", e1, t);
                }, t.assertPrivateName = function(e1, t) {
                    s("PrivateName", e1, t);
                }, t.assertProgram = function(e1, t) {
                    s("Program", e1, t);
                }, t.assertProperty = function(e1, t) {
                    s("Property", e1, t);
                }, t.assertPureish = function(e1, t) {
                    s("Pureish", e1, t);
                }, t.assertQualifiedTypeIdentifier = function(e1, t) {
                    s("QualifiedTypeIdentifier", e1, t);
                }, t.assertRecordExpression = function(e1, t) {
                    s("RecordExpression", e1, t);
                }, t.assertRegExpLiteral = function(e1, t) {
                    s("RegExpLiteral", e1, t);
                }, t.assertRegexLiteral = function(e1, t) {
                    (0, i.default)("assertRegexLiteral", "assertRegExpLiteral"), s("RegexLiteral", e1, t);
                }, t.assertRestElement = function(e1, t) {
                    s("RestElement", e1, t);
                }, t.assertRestProperty = function(e1, t) {
                    (0, i.default)("assertRestProperty", "assertRestElement"), s("RestProperty", e1, t);
                }, t.assertReturnStatement = function(e1, t) {
                    s("ReturnStatement", e1, t);
                }, t.assertScopable = function(e1, t) {
                    s("Scopable", e1, t);
                }, t.assertSequenceExpression = function(e1, t) {
                    s("SequenceExpression", e1, t);
                }, t.assertSpreadElement = function(e1, t) {
                    s("SpreadElement", e1, t);
                }, t.assertSpreadProperty = function(e1, t) {
                    (0, i.default)("assertSpreadProperty", "assertSpreadElement"), s("SpreadProperty", e1, t);
                }, t.assertStandardized = function(e1, t) {
                    s("Standardized", e1, t);
                }, t.assertStatement = function(e1, t) {
                    s("Statement", e1, t);
                }, t.assertStaticBlock = function(e1, t) {
                    s("StaticBlock", e1, t);
                }, t.assertStringLiteral = function(e1, t) {
                    s("StringLiteral", e1, t);
                }, t.assertStringLiteralTypeAnnotation = function(e1, t) {
                    s("StringLiteralTypeAnnotation", e1, t);
                }, t.assertStringTypeAnnotation = function(e1, t) {
                    s("StringTypeAnnotation", e1, t);
                }, t.assertSuper = function(e1, t) {
                    s("Super", e1, t);
                }, t.assertSwitchCase = function(e1, t) {
                    s("SwitchCase", e1, t);
                }, t.assertSwitchStatement = function(e1, t) {
                    s("SwitchStatement", e1, t);
                }, t.assertSymbolTypeAnnotation = function(e1, t) {
                    s("SymbolTypeAnnotation", e1, t);
                }, t.assertTSAnyKeyword = function(e1, t) {
                    s("TSAnyKeyword", e1, t);
                }, t.assertTSArrayType = function(e1, t) {
                    s("TSArrayType", e1, t);
                }, t.assertTSAsExpression = function(e1, t) {
                    s("TSAsExpression", e1, t);
                }, t.assertTSBaseType = function(e1, t) {
                    s("TSBaseType", e1, t);
                }, t.assertTSBigIntKeyword = function(e1, t) {
                    s("TSBigIntKeyword", e1, t);
                }, t.assertTSBooleanKeyword = function(e1, t) {
                    s("TSBooleanKeyword", e1, t);
                }, t.assertTSCallSignatureDeclaration = function(e1, t) {
                    s("TSCallSignatureDeclaration", e1, t);
                }, t.assertTSConditionalType = function(e1, t) {
                    s("TSConditionalType", e1, t);
                }, t.assertTSConstructSignatureDeclaration = function(e1, t) {
                    s("TSConstructSignatureDeclaration", e1, t);
                }, t.assertTSConstructorType = function(e1, t) {
                    s("TSConstructorType", e1, t);
                }, t.assertTSDeclareFunction = function(e1, t) {
                    s("TSDeclareFunction", e1, t);
                }, t.assertTSDeclareMethod = function(e1, t) {
                    s("TSDeclareMethod", e1, t);
                }, t.assertTSEntityName = function(e1, t) {
                    s("TSEntityName", e1, t);
                }, t.assertTSEnumDeclaration = function(e1, t) {
                    s("TSEnumDeclaration", e1, t);
                }, t.assertTSEnumMember = function(e1, t) {
                    s("TSEnumMember", e1, t);
                }, t.assertTSExportAssignment = function(e1, t) {
                    s("TSExportAssignment", e1, t);
                }, t.assertTSExpressionWithTypeArguments = function(e1, t) {
                    s("TSExpressionWithTypeArguments", e1, t);
                }, t.assertTSExternalModuleReference = function(e1, t) {
                    s("TSExternalModuleReference", e1, t);
                }, t.assertTSFunctionType = function(e1, t) {
                    s("TSFunctionType", e1, t);
                }, t.assertTSImportEqualsDeclaration = function(e1, t) {
                    s("TSImportEqualsDeclaration", e1, t);
                }, t.assertTSImportType = function(e1, t) {
                    s("TSImportType", e1, t);
                }, t.assertTSIndexSignature = function(e1, t) {
                    s("TSIndexSignature", e1, t);
                }, t.assertTSIndexedAccessType = function(e1, t) {
                    s("TSIndexedAccessType", e1, t);
                }, t.assertTSInferType = function(e1, t) {
                    s("TSInferType", e1, t);
                }, t.assertTSInstantiationExpression = function(e1, t) {
                    s("TSInstantiationExpression", e1, t);
                }, t.assertTSInterfaceBody = function(e1, t) {
                    s("TSInterfaceBody", e1, t);
                }, t.assertTSInterfaceDeclaration = function(e1, t) {
                    s("TSInterfaceDeclaration", e1, t);
                }, t.assertTSIntersectionType = function(e1, t) {
                    s("TSIntersectionType", e1, t);
                }, t.assertTSIntrinsicKeyword = function(e1, t) {
                    s("TSIntrinsicKeyword", e1, t);
                }, t.assertTSLiteralType = function(e1, t) {
                    s("TSLiteralType", e1, t);
                }, t.assertTSMappedType = function(e1, t) {
                    s("TSMappedType", e1, t);
                }, t.assertTSMethodSignature = function(e1, t) {
                    s("TSMethodSignature", e1, t);
                }, t.assertTSModuleBlock = function(e1, t) {
                    s("TSModuleBlock", e1, t);
                }, t.assertTSModuleDeclaration = function(e1, t) {
                    s("TSModuleDeclaration", e1, t);
                }, t.assertTSNamedTupleMember = function(e1, t) {
                    s("TSNamedTupleMember", e1, t);
                }, t.assertTSNamespaceExportDeclaration = function(e1, t) {
                    s("TSNamespaceExportDeclaration", e1, t);
                }, t.assertTSNeverKeyword = function(e1, t) {
                    s("TSNeverKeyword", e1, t);
                }, t.assertTSNonNullExpression = function(e1, t) {
                    s("TSNonNullExpression", e1, t);
                }, t.assertTSNullKeyword = function(e1, t) {
                    s("TSNullKeyword", e1, t);
                }, t.assertTSNumberKeyword = function(e1, t) {
                    s("TSNumberKeyword", e1, t);
                }, t.assertTSObjectKeyword = function(e1, t) {
                    s("TSObjectKeyword", e1, t);
                }, t.assertTSOptionalType = function(e1, t) {
                    s("TSOptionalType", e1, t);
                }, t.assertTSParameterProperty = function(e1, t) {
                    s("TSParameterProperty", e1, t);
                }, t.assertTSParenthesizedType = function(e1, t) {
                    s("TSParenthesizedType", e1, t);
                }, t.assertTSPropertySignature = function(e1, t) {
                    s("TSPropertySignature", e1, t);
                }, t.assertTSQualifiedName = function(e1, t) {
                    s("TSQualifiedName", e1, t);
                }, t.assertTSRestType = function(e1, t) {
                    s("TSRestType", e1, t);
                }, t.assertTSSatisfiesExpression = function(e1, t) {
                    s("TSSatisfiesExpression", e1, t);
                }, t.assertTSStringKeyword = function(e1, t) {
                    s("TSStringKeyword", e1, t);
                }, t.assertTSSymbolKeyword = function(e1, t) {
                    s("TSSymbolKeyword", e1, t);
                }, t.assertTSThisType = function(e1, t) {
                    s("TSThisType", e1, t);
                }, t.assertTSTupleType = function(e1, t) {
                    s("TSTupleType", e1, t);
                }, t.assertTSType = function(e1, t) {
                    s("TSType", e1, t);
                }, t.assertTSTypeAliasDeclaration = function(e1, t) {
                    s("TSTypeAliasDeclaration", e1, t);
                }, t.assertTSTypeAnnotation = function(e1, t) {
                    s("TSTypeAnnotation", e1, t);
                }, t.assertTSTypeAssertion = function(e1, t) {
                    s("TSTypeAssertion", e1, t);
                }, t.assertTSTypeElement = function(e1, t) {
                    s("TSTypeElement", e1, t);
                }, t.assertTSTypeLiteral = function(e1, t) {
                    s("TSTypeLiteral", e1, t);
                }, t.assertTSTypeOperator = function(e1, t) {
                    s("TSTypeOperator", e1, t);
                }, t.assertTSTypeParameter = function(e1, t) {
                    s("TSTypeParameter", e1, t);
                }, t.assertTSTypeParameterDeclaration = function(e1, t) {
                    s("TSTypeParameterDeclaration", e1, t);
                }, t.assertTSTypeParameterInstantiation = function(e1, t) {
                    s("TSTypeParameterInstantiation", e1, t);
                }, t.assertTSTypePredicate = function(e1, t) {
                    s("TSTypePredicate", e1, t);
                }, t.assertTSTypeQuery = function(e1, t) {
                    s("TSTypeQuery", e1, t);
                }, t.assertTSTypeReference = function(e1, t) {
                    s("TSTypeReference", e1, t);
                }, t.assertTSUndefinedKeyword = function(e1, t) {
                    s("TSUndefinedKeyword", e1, t);
                }, t.assertTSUnionType = function(e1, t) {
                    s("TSUnionType", e1, t);
                }, t.assertTSUnknownKeyword = function(e1, t) {
                    s("TSUnknownKeyword", e1, t);
                }, t.assertTSVoidKeyword = function(e1, t) {
                    s("TSVoidKeyword", e1, t);
                }, t.assertTaggedTemplateExpression = function(e1, t) {
                    s("TaggedTemplateExpression", e1, t);
                }, t.assertTemplateElement = function(e1, t) {
                    s("TemplateElement", e1, t);
                }, t.assertTemplateLiteral = function(e1, t) {
                    s("TemplateLiteral", e1, t);
                }, t.assertTerminatorless = function(e1, t) {
                    s("Terminatorless", e1, t);
                }, t.assertThisExpression = function(e1, t) {
                    s("ThisExpression", e1, t);
                }, t.assertThisTypeAnnotation = function(e1, t) {
                    s("ThisTypeAnnotation", e1, t);
                }, t.assertThrowStatement = function(e1, t) {
                    s("ThrowStatement", e1, t);
                }, t.assertTopicReference = function(e1, t) {
                    s("TopicReference", e1, t);
                }, t.assertTryStatement = function(e1, t) {
                    s("TryStatement", e1, t);
                }, t.assertTupleExpression = function(e1, t) {
                    s("TupleExpression", e1, t);
                }, t.assertTupleTypeAnnotation = function(e1, t) {
                    s("TupleTypeAnnotation", e1, t);
                }, t.assertTypeAlias = function(e1, t) {
                    s("TypeAlias", e1, t);
                }, t.assertTypeAnnotation = function(e1, t) {
                    s("TypeAnnotation", e1, t);
                }, t.assertTypeCastExpression = function(e1, t) {
                    s("TypeCastExpression", e1, t);
                }, t.assertTypeParameter = function(e1, t) {
                    s("TypeParameter", e1, t);
                }, t.assertTypeParameterDeclaration = function(e1, t) {
                    s("TypeParameterDeclaration", e1, t);
                }, t.assertTypeParameterInstantiation = function(e1, t) {
                    s("TypeParameterInstantiation", e1, t);
                }, t.assertTypeScript = function(e1, t) {
                    s("TypeScript", e1, t);
                }, t.assertTypeofTypeAnnotation = function(e1, t) {
                    s("TypeofTypeAnnotation", e1, t);
                }, t.assertUnaryExpression = function(e1, t) {
                    s("UnaryExpression", e1, t);
                }, t.assertUnaryLike = function(e1, t) {
                    s("UnaryLike", e1, t);
                }, t.assertUnionTypeAnnotation = function(e1, t) {
                    s("UnionTypeAnnotation", e1, t);
                }, t.assertUpdateExpression = function(e1, t) {
                    s("UpdateExpression", e1, t);
                }, t.assertUserWhitespacable = function(e1, t) {
                    s("UserWhitespacable", e1, t);
                }, t.assertV8IntrinsicIdentifier = function(e1, t) {
                    s("V8IntrinsicIdentifier", e1, t);
                }, t.assertVariableDeclaration = function(e1, t) {
                    s("VariableDeclaration", e1, t);
                }, t.assertVariableDeclarator = function(e1, t) {
                    s("VariableDeclarator", e1, t);
                }, t.assertVariance = function(e1, t) {
                    s("Variance", e1, t);
                }, t.assertVoidTypeAnnotation = function(e1, t) {
                    s("VoidTypeAnnotation", e1, t);
                }, t.assertWhile = function(e1, t) {
                    s("While", e1, t);
                }, t.assertWhileStatement = function(e1, t) {
                    s("WhileStatement", e1, t);
                }, t.assertWithStatement = function(e1, t) {
                    s("WithStatement", e1, t);
                }, t.assertYieldExpression = function(e1, t) {
                    s("YieldExpression", e1, t);
                };
                var r = n(5171), i = n(4619);
                function s(e1, t, n) {
                    if (!(0, r.default)(e1, t, n)) throw new Error(`Expected type "${e1}" with option ${JSON.stringify(n)}, but instead got "${t.type}".`);
                }
            },
            7625: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1) {
                    const t = (0, i.default)(e1);
                    return 1 === t.length ? t[0] : (0, r.unionTypeAnnotation)(t);
                };
                var r = n(1411), i = n(8874);
            },
            5976: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var r = n(1411);
                t.default = function(e1) {
                    switch(e1){
                        case "string":
                            return (0, r.stringTypeAnnotation)();
                        case "number":
                            return (0, r.numberTypeAnnotation)();
                        case "undefined":
                            return (0, r.voidTypeAnnotation)();
                        case "boolean":
                            return (0, r.booleanTypeAnnotation)();
                        case "function":
                            return (0, r.genericTypeAnnotation)((0, r.identifier)("Function"));
                        case "object":
                            return (0, r.genericTypeAnnotation)((0, r.identifier)("Object"));
                        case "symbol":
                            return (0, r.genericTypeAnnotation)((0, r.identifier)("Symbol"));
                        case "bigint":
                            return (0, r.anyTypeAnnotation)();
                    }
                    throw new Error("Invalid typeof value: " + e1);
                };
            },
            1411: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.anyTypeAnnotation = function() {
                    return {
                        type: "AnyTypeAnnotation"
                    };
                }, t.argumentPlaceholder = function() {
                    return {
                        type: "ArgumentPlaceholder"
                    };
                }, t.arrayExpression = function(e1 = []) {
                    return (0, r.default)({
                        type: "ArrayExpression",
                        elements: e1
                    });
                }, t.arrayPattern = function(e1) {
                    return (0, r.default)({
                        type: "ArrayPattern",
                        elements: e1
                    });
                }, t.arrayTypeAnnotation = function(e1) {
                    return (0, r.default)({
                        type: "ArrayTypeAnnotation",
                        elementType: e1
                    });
                }, t.arrowFunctionExpression = function(e1, t, n = !1) {
                    return (0, r.default)({
                        type: "ArrowFunctionExpression",
                        params: e1,
                        body: t,
                        async: n,
                        expression: null
                    });
                }, t.assignmentExpression = function(e1, t, n) {
                    return (0, r.default)({
                        type: "AssignmentExpression",
                        operator: e1,
                        left: t,
                        right: n
                    });
                }, t.assignmentPattern = function(e1, t) {
                    return (0, r.default)({
                        type: "AssignmentPattern",
                        left: e1,
                        right: t
                    });
                }, t.awaitExpression = function(e1) {
                    return (0, r.default)({
                        type: "AwaitExpression",
                        argument: e1
                    });
                }, t.bigIntLiteral = function(e1) {
                    return (0, r.default)({
                        type: "BigIntLiteral",
                        value: e1
                    });
                }, t.binaryExpression = function(e1, t, n) {
                    return (0, r.default)({
                        type: "BinaryExpression",
                        operator: e1,
                        left: t,
                        right: n
                    });
                }, t.bindExpression = function(e1, t) {
                    return (0, r.default)({
                        type: "BindExpression",
                        object: e1,
                        callee: t
                    });
                }, t.blockStatement = function(e1, t = []) {
                    return (0, r.default)({
                        type: "BlockStatement",
                        body: e1,
                        directives: t
                    });
                }, t.booleanLiteral = function(e1) {
                    return (0, r.default)({
                        type: "BooleanLiteral",
                        value: e1
                    });
                }, t.booleanLiteralTypeAnnotation = function(e1) {
                    return (0, r.default)({
                        type: "BooleanLiteralTypeAnnotation",
                        value: e1
                    });
                }, t.booleanTypeAnnotation = function() {
                    return {
                        type: "BooleanTypeAnnotation"
                    };
                }, t.breakStatement = function(e1 = null) {
                    return (0, r.default)({
                        type: "BreakStatement",
                        label: e1
                    });
                }, t.callExpression = function(e1, t) {
                    return (0, r.default)({
                        type: "CallExpression",
                        callee: e1,
                        arguments: t
                    });
                }, t.catchClause = function(e1 = null, t) {
                    return (0, r.default)({
                        type: "CatchClause",
                        param: e1,
                        body: t
                    });
                }, t.classAccessorProperty = function(e1, t = null, n = null, i = null, s = !1, a = !1) {
                    return (0, r.default)({
                        type: "ClassAccessorProperty",
                        key: e1,
                        value: t,
                        typeAnnotation: n,
                        decorators: i,
                        computed: s,
                        static: a
                    });
                }, t.classBody = function(e1) {
                    return (0, r.default)({
                        type: "ClassBody",
                        body: e1
                    });
                }, t.classDeclaration = function(e1, t = null, n, i = null) {
                    return (0, r.default)({
                        type: "ClassDeclaration",
                        id: e1,
                        superClass: t,
                        body: n,
                        decorators: i
                    });
                }, t.classExpression = function(e1 = null, t = null, n, i = null) {
                    return (0, r.default)({
                        type: "ClassExpression",
                        id: e1,
                        superClass: t,
                        body: n,
                        decorators: i
                    });
                }, t.classImplements = function(e1, t = null) {
                    return (0, r.default)({
                        type: "ClassImplements",
                        id: e1,
                        typeParameters: t
                    });
                }, t.classMethod = function(e1 = "method", t, n, i, s = !1, a = !1, o = !1, l = !1) {
                    return (0, r.default)({
                        type: "ClassMethod",
                        kind: e1,
                        key: t,
                        params: n,
                        body: i,
                        computed: s,
                        static: a,
                        generator: o,
                        async: l
                    });
                }, t.classPrivateMethod = function(e1 = "method", t, n, i, s = !1) {
                    return (0, r.default)({
                        type: "ClassPrivateMethod",
                        kind: e1,
                        key: t,
                        params: n,
                        body: i,
                        static: s
                    });
                }, t.classPrivateProperty = function(e1, t = null, n = null, i = !1) {
                    return (0, r.default)({
                        type: "ClassPrivateProperty",
                        key: e1,
                        value: t,
                        decorators: n,
                        static: i
                    });
                }, t.classProperty = function(e1, t = null, n = null, i = null, s = !1, a = !1) {
                    return (0, r.default)({
                        type: "ClassProperty",
                        key: e1,
                        value: t,
                        typeAnnotation: n,
                        decorators: i,
                        computed: s,
                        static: a
                    });
                }, t.conditionalExpression = function(e1, t, n) {
                    return (0, r.default)({
                        type: "ConditionalExpression",
                        test: e1,
                        consequent: t,
                        alternate: n
                    });
                }, t.continueStatement = function(e1 = null) {
                    return (0, r.default)({
                        type: "ContinueStatement",
                        label: e1
                    });
                }, t.debuggerStatement = function() {
                    return {
                        type: "DebuggerStatement"
                    };
                }, t.decimalLiteral = function(e1) {
                    return (0, r.default)({
                        type: "DecimalLiteral",
                        value: e1
                    });
                }, t.declareClass = function(e1, t = null, n = null, i) {
                    return (0, r.default)({
                        type: "DeclareClass",
                        id: e1,
                        typeParameters: t,
                        extends: n,
                        body: i
                    });
                }, t.declareExportAllDeclaration = function(e1) {
                    return (0, r.default)({
                        type: "DeclareExportAllDeclaration",
                        source: e1
                    });
                }, t.declareExportDeclaration = function(e1 = null, t = null, n = null) {
                    return (0, r.default)({
                        type: "DeclareExportDeclaration",
                        declaration: e1,
                        specifiers: t,
                        source: n
                    });
                }, t.declareFunction = function(e1) {
                    return (0, r.default)({
                        type: "DeclareFunction",
                        id: e1
                    });
                }, t.declareInterface = function(e1, t = null, n = null, i) {
                    return (0, r.default)({
                        type: "DeclareInterface",
                        id: e1,
                        typeParameters: t,
                        extends: n,
                        body: i
                    });
                }, t.declareModule = function(e1, t, n = null) {
                    return (0, r.default)({
                        type: "DeclareModule",
                        id: e1,
                        body: t,
                        kind: n
                    });
                }, t.declareModuleExports = function(e1) {
                    return (0, r.default)({
                        type: "DeclareModuleExports",
                        typeAnnotation: e1
                    });
                }, t.declareOpaqueType = function(e1, t = null, n = null) {
                    return (0, r.default)({
                        type: "DeclareOpaqueType",
                        id: e1,
                        typeParameters: t,
                        supertype: n
                    });
                }, t.declareTypeAlias = function(e1, t = null, n) {
                    return (0, r.default)({
                        type: "DeclareTypeAlias",
                        id: e1,
                        typeParameters: t,
                        right: n
                    });
                }, t.declareVariable = function(e1) {
                    return (0, r.default)({
                        type: "DeclareVariable",
                        id: e1
                    });
                }, t.declaredPredicate = function(e1) {
                    return (0, r.default)({
                        type: "DeclaredPredicate",
                        value: e1
                    });
                }, t.decorator = function(e1) {
                    return (0, r.default)({
                        type: "Decorator",
                        expression: e1
                    });
                }, t.directive = function(e1) {
                    return (0, r.default)({
                        type: "Directive",
                        value: e1
                    });
                }, t.directiveLiteral = function(e1) {
                    return (0, r.default)({
                        type: "DirectiveLiteral",
                        value: e1
                    });
                }, t.doExpression = function(e1, t = !1) {
                    return (0, r.default)({
                        type: "DoExpression",
                        body: e1,
                        async: t
                    });
                }, t.doWhileStatement = function(e1, t) {
                    return (0, r.default)({
                        type: "DoWhileStatement",
                        test: e1,
                        body: t
                    });
                }, t.emptyStatement = function() {
                    return {
                        type: "EmptyStatement"
                    };
                }, t.emptyTypeAnnotation = function() {
                    return {
                        type: "EmptyTypeAnnotation"
                    };
                }, t.enumBooleanBody = function(e1) {
                    return (0, r.default)({
                        type: "EnumBooleanBody",
                        members: e1,
                        explicitType: null,
                        hasUnknownMembers: null
                    });
                }, t.enumBooleanMember = function(e1) {
                    return (0, r.default)({
                        type: "EnumBooleanMember",
                        id: e1,
                        init: null
                    });
                }, t.enumDeclaration = function(e1, t) {
                    return (0, r.default)({
                        type: "EnumDeclaration",
                        id: e1,
                        body: t
                    });
                }, t.enumDefaultedMember = function(e1) {
                    return (0, r.default)({
                        type: "EnumDefaultedMember",
                        id: e1
                    });
                }, t.enumNumberBody = function(e1) {
                    return (0, r.default)({
                        type: "EnumNumberBody",
                        members: e1,
                        explicitType: null,
                        hasUnknownMembers: null
                    });
                }, t.enumNumberMember = function(e1, t) {
                    return (0, r.default)({
                        type: "EnumNumberMember",
                        id: e1,
                        init: t
                    });
                }, t.enumStringBody = function(e1) {
                    return (0, r.default)({
                        type: "EnumStringBody",
                        members: e1,
                        explicitType: null,
                        hasUnknownMembers: null
                    });
                }, t.enumStringMember = function(e1, t) {
                    return (0, r.default)({
                        type: "EnumStringMember",
                        id: e1,
                        init: t
                    });
                }, t.enumSymbolBody = function(e1) {
                    return (0, r.default)({
                        type: "EnumSymbolBody",
                        members: e1,
                        hasUnknownMembers: null
                    });
                }, t.existsTypeAnnotation = function() {
                    return {
                        type: "ExistsTypeAnnotation"
                    };
                }, t.exportAllDeclaration = function(e1) {
                    return (0, r.default)({
                        type: "ExportAllDeclaration",
                        source: e1
                    });
                }, t.exportDefaultDeclaration = function(e1) {
                    return (0, r.default)({
                        type: "ExportDefaultDeclaration",
                        declaration: e1
                    });
                }, t.exportDefaultSpecifier = function(e1) {
                    return (0, r.default)({
                        type: "ExportDefaultSpecifier",
                        exported: e1
                    });
                }, t.exportNamedDeclaration = function(e1 = null, t = [], n = null) {
                    return (0, r.default)({
                        type: "ExportNamedDeclaration",
                        declaration: e1,
                        specifiers: t,
                        source: n
                    });
                }, t.exportNamespaceSpecifier = function(e1) {
                    return (0, r.default)({
                        type: "ExportNamespaceSpecifier",
                        exported: e1
                    });
                }, t.exportSpecifier = function(e1, t) {
                    return (0, r.default)({
                        type: "ExportSpecifier",
                        local: e1,
                        exported: t
                    });
                }, t.expressionStatement = function(e1) {
                    return (0, r.default)({
                        type: "ExpressionStatement",
                        expression: e1
                    });
                }, t.file = function(e1, t = null, n = null) {
                    return (0, r.default)({
                        type: "File",
                        program: e1,
                        comments: t,
                        tokens: n
                    });
                }, t.forInStatement = function(e1, t, n) {
                    return (0, r.default)({
                        type: "ForInStatement",
                        left: e1,
                        right: t,
                        body: n
                    });
                }, t.forOfStatement = function(e1, t, n, i = !1) {
                    return (0, r.default)({
                        type: "ForOfStatement",
                        left: e1,
                        right: t,
                        body: n,
                        await: i
                    });
                }, t.forStatement = function(e1 = null, t = null, n = null, i) {
                    return (0, r.default)({
                        type: "ForStatement",
                        init: e1,
                        test: t,
                        update: n,
                        body: i
                    });
                }, t.functionDeclaration = function(e1 = null, t, n, i = !1, s = !1) {
                    return (0, r.default)({
                        type: "FunctionDeclaration",
                        id: e1,
                        params: t,
                        body: n,
                        generator: i,
                        async: s
                    });
                }, t.functionExpression = function(e1 = null, t, n, i = !1, s = !1) {
                    return (0, r.default)({
                        type: "FunctionExpression",
                        id: e1,
                        params: t,
                        body: n,
                        generator: i,
                        async: s
                    });
                }, t.functionTypeAnnotation = function(e1 = null, t, n = null, i) {
                    return (0, r.default)({
                        type: "FunctionTypeAnnotation",
                        typeParameters: e1,
                        params: t,
                        rest: n,
                        returnType: i
                    });
                }, t.functionTypeParam = function(e1 = null, t) {
                    return (0, r.default)({
                        type: "FunctionTypeParam",
                        name: e1,
                        typeAnnotation: t
                    });
                }, t.genericTypeAnnotation = function(e1, t = null) {
                    return (0, r.default)({
                        type: "GenericTypeAnnotation",
                        id: e1,
                        typeParameters: t
                    });
                }, t.identifier = function(e1) {
                    return (0, r.default)({
                        type: "Identifier",
                        name: e1
                    });
                }, t.ifStatement = function(e1, t, n = null) {
                    return (0, r.default)({
                        type: "IfStatement",
                        test: e1,
                        consequent: t,
                        alternate: n
                    });
                }, t.import = function() {
                    return {
                        type: "Import"
                    };
                }, t.importAttribute = function(e1, t) {
                    return (0, r.default)({
                        type: "ImportAttribute",
                        key: e1,
                        value: t
                    });
                }, t.importDeclaration = function(e1, t) {
                    return (0, r.default)({
                        type: "ImportDeclaration",
                        specifiers: e1,
                        source: t
                    });
                }, t.importDefaultSpecifier = function(e1) {
                    return (0, r.default)({
                        type: "ImportDefaultSpecifier",
                        local: e1
                    });
                }, t.importNamespaceSpecifier = function(e1) {
                    return (0, r.default)({
                        type: "ImportNamespaceSpecifier",
                        local: e1
                    });
                }, t.importSpecifier = function(e1, t) {
                    return (0, r.default)({
                        type: "ImportSpecifier",
                        local: e1,
                        imported: t
                    });
                }, t.indexedAccessType = function(e1, t) {
                    return (0, r.default)({
                        type: "IndexedAccessType",
                        objectType: e1,
                        indexType: t
                    });
                }, t.inferredPredicate = function() {
                    return {
                        type: "InferredPredicate"
                    };
                }, t.interfaceDeclaration = function(e1, t = null, n = null, i) {
                    return (0, r.default)({
                        type: "InterfaceDeclaration",
                        id: e1,
                        typeParameters: t,
                        extends: n,
                        body: i
                    });
                }, t.interfaceExtends = function(e1, t = null) {
                    return (0, r.default)({
                        type: "InterfaceExtends",
                        id: e1,
                        typeParameters: t
                    });
                }, t.interfaceTypeAnnotation = function(e1 = null, t) {
                    return (0, r.default)({
                        type: "InterfaceTypeAnnotation",
                        extends: e1,
                        body: t
                    });
                }, t.interpreterDirective = function(e1) {
                    return (0, r.default)({
                        type: "InterpreterDirective",
                        value: e1
                    });
                }, t.intersectionTypeAnnotation = function(e1) {
                    return (0, r.default)({
                        type: "IntersectionTypeAnnotation",
                        types: e1
                    });
                }, t.jSXAttribute = t.jsxAttribute = function(e1, t = null) {
                    return (0, r.default)({
                        type: "JSXAttribute",
                        name: e1,
                        value: t
                    });
                }, t.jSXClosingElement = t.jsxClosingElement = function(e1) {
                    return (0, r.default)({
                        type: "JSXClosingElement",
                        name: e1
                    });
                }, t.jSXClosingFragment = t.jsxClosingFragment = function() {
                    return {
                        type: "JSXClosingFragment"
                    };
                }, t.jSXElement = t.jsxElement = function(e1, t = null, n, i = null) {
                    return (0, r.default)({
                        type: "JSXElement",
                        openingElement: e1,
                        closingElement: t,
                        children: n,
                        selfClosing: i
                    });
                }, t.jSXEmptyExpression = t.jsxEmptyExpression = function() {
                    return {
                        type: "JSXEmptyExpression"
                    };
                }, t.jSXExpressionContainer = t.jsxExpressionContainer = function(e1) {
                    return (0, r.default)({
                        type: "JSXExpressionContainer",
                        expression: e1
                    });
                }, t.jSXFragment = t.jsxFragment = function(e1, t, n) {
                    return (0, r.default)({
                        type: "JSXFragment",
                        openingFragment: e1,
                        closingFragment: t,
                        children: n
                    });
                }, t.jSXIdentifier = t.jsxIdentifier = function(e1) {
                    return (0, r.default)({
                        type: "JSXIdentifier",
                        name: e1
                    });
                }, t.jSXMemberExpression = t.jsxMemberExpression = function(e1, t) {
                    return (0, r.default)({
                        type: "JSXMemberExpression",
                        object: e1,
                        property: t
                    });
                }, t.jSXNamespacedName = t.jsxNamespacedName = function(e1, t) {
                    return (0, r.default)({
                        type: "JSXNamespacedName",
                        namespace: e1,
                        name: t
                    });
                }, t.jSXOpeningElement = t.jsxOpeningElement = function(e1, t, n = !1) {
                    return (0, r.default)({
                        type: "JSXOpeningElement",
                        name: e1,
                        attributes: t,
                        selfClosing: n
                    });
                }, t.jSXOpeningFragment = t.jsxOpeningFragment = function() {
                    return {
                        type: "JSXOpeningFragment"
                    };
                }, t.jSXSpreadAttribute = t.jsxSpreadAttribute = function(e1) {
                    return (0, r.default)({
                        type: "JSXSpreadAttribute",
                        argument: e1
                    });
                }, t.jSXSpreadChild = t.jsxSpreadChild = function(e1) {
                    return (0, r.default)({
                        type: "JSXSpreadChild",
                        expression: e1
                    });
                }, t.jSXText = t.jsxText = function(e1) {
                    return (0, r.default)({
                        type: "JSXText",
                        value: e1
                    });
                }, t.labeledStatement = function(e1, t) {
                    return (0, r.default)({
                        type: "LabeledStatement",
                        label: e1,
                        body: t
                    });
                }, t.logicalExpression = function(e1, t, n) {
                    return (0, r.default)({
                        type: "LogicalExpression",
                        operator: e1,
                        left: t,
                        right: n
                    });
                }, t.memberExpression = function(e1, t, n = !1, i = null) {
                    return (0, r.default)({
                        type: "MemberExpression",
                        object: e1,
                        property: t,
                        computed: n,
                        optional: i
                    });
                }, t.metaProperty = function(e1, t) {
                    return (0, r.default)({
                        type: "MetaProperty",
                        meta: e1,
                        property: t
                    });
                }, t.mixedTypeAnnotation = function() {
                    return {
                        type: "MixedTypeAnnotation"
                    };
                }, t.moduleExpression = function(e1) {
                    return (0, r.default)({
                        type: "ModuleExpression",
                        body: e1
                    });
                }, t.newExpression = function(e1, t) {
                    return (0, r.default)({
                        type: "NewExpression",
                        callee: e1,
                        arguments: t
                    });
                }, t.noop = function() {
                    return {
                        type: "Noop"
                    };
                }, t.nullLiteral = function() {
                    return {
                        type: "NullLiteral"
                    };
                }, t.nullLiteralTypeAnnotation = function() {
                    return {
                        type: "NullLiteralTypeAnnotation"
                    };
                }, t.nullableTypeAnnotation = function(e1) {
                    return (0, r.default)({
                        type: "NullableTypeAnnotation",
                        typeAnnotation: e1
                    });
                }, t.numberLiteral = function(e1) {
                    return (0, i.default)("NumberLiteral", "NumericLiteral", "The node type "), s(e1);
                }, t.numberLiteralTypeAnnotation = function(e1) {
                    return (0, r.default)({
                        type: "NumberLiteralTypeAnnotation",
                        value: e1
                    });
                }, t.numberTypeAnnotation = function() {
                    return {
                        type: "NumberTypeAnnotation"
                    };
                }, t.numericLiteral = s, t.objectExpression = function(e1) {
                    return (0, r.default)({
                        type: "ObjectExpression",
                        properties: e1
                    });
                }, t.objectMethod = function(e1 = "method", t, n, i, s = !1, a = !1, o = !1) {
                    return (0, r.default)({
                        type: "ObjectMethod",
                        kind: e1,
                        key: t,
                        params: n,
                        body: i,
                        computed: s,
                        generator: a,
                        async: o
                    });
                }, t.objectPattern = function(e1) {
                    return (0, r.default)({
                        type: "ObjectPattern",
                        properties: e1
                    });
                }, t.objectProperty = function(e1, t, n = !1, i = !1, s = null) {
                    return (0, r.default)({
                        type: "ObjectProperty",
                        key: e1,
                        value: t,
                        computed: n,
                        shorthand: i,
                        decorators: s
                    });
                }, t.objectTypeAnnotation = function(e1, t = [], n = [], i = [], s = !1) {
                    return (0, r.default)({
                        type: "ObjectTypeAnnotation",
                        properties: e1,
                        indexers: t,
                        callProperties: n,
                        internalSlots: i,
                        exact: s
                    });
                }, t.objectTypeCallProperty = function(e1) {
                    return (0, r.default)({
                        type: "ObjectTypeCallProperty",
                        value: e1,
                        static: null
                    });
                }, t.objectTypeIndexer = function(e1 = null, t, n, i = null) {
                    return (0, r.default)({
                        type: "ObjectTypeIndexer",
                        id: e1,
                        key: t,
                        value: n,
                        variance: i,
                        static: null
                    });
                }, t.objectTypeInternalSlot = function(e1, t, n, i, s) {
                    return (0, r.default)({
                        type: "ObjectTypeInternalSlot",
                        id: e1,
                        value: t,
                        optional: n,
                        static: i,
                        method: s
                    });
                }, t.objectTypeProperty = function(e1, t, n = null) {
                    return (0, r.default)({
                        type: "ObjectTypeProperty",
                        key: e1,
                        value: t,
                        variance: n,
                        kind: null,
                        method: null,
                        optional: null,
                        proto: null,
                        static: null
                    });
                }, t.objectTypeSpreadProperty = function(e1) {
                    return (0, r.default)({
                        type: "ObjectTypeSpreadProperty",
                        argument: e1
                    });
                }, t.opaqueType = function(e1, t = null, n = null, i) {
                    return (0, r.default)({
                        type: "OpaqueType",
                        id: e1,
                        typeParameters: t,
                        supertype: n,
                        impltype: i
                    });
                }, t.optionalCallExpression = function(e1, t, n) {
                    return (0, r.default)({
                        type: "OptionalCallExpression",
                        callee: e1,
                        arguments: t,
                        optional: n
                    });
                }, t.optionalIndexedAccessType = function(e1, t) {
                    return (0, r.default)({
                        type: "OptionalIndexedAccessType",
                        objectType: e1,
                        indexType: t,
                        optional: null
                    });
                }, t.optionalMemberExpression = function(e1, t, n = !1, i) {
                    return (0, r.default)({
                        type: "OptionalMemberExpression",
                        object: e1,
                        property: t,
                        computed: n,
                        optional: i
                    });
                }, t.parenthesizedExpression = function(e1) {
                    return (0, r.default)({
                        type: "ParenthesizedExpression",
                        expression: e1
                    });
                }, t.pipelineBareFunction = function(e1) {
                    return (0, r.default)({
                        type: "PipelineBareFunction",
                        callee: e1
                    });
                }, t.pipelinePrimaryTopicReference = function() {
                    return {
                        type: "PipelinePrimaryTopicReference"
                    };
                }, t.pipelineTopicExpression = function(e1) {
                    return (0, r.default)({
                        type: "PipelineTopicExpression",
                        expression: e1
                    });
                }, t.placeholder = function(e1, t) {
                    return (0, r.default)({
                        type: "Placeholder",
                        expectedNode: e1,
                        name: t
                    });
                }, t.privateName = function(e1) {
                    return (0, r.default)({
                        type: "PrivateName",
                        id: e1
                    });
                }, t.program = function(e1, t = [], n = "script", i = null) {
                    return (0, r.default)({
                        type: "Program",
                        body: e1,
                        directives: t,
                        sourceType: n,
                        interpreter: i,
                        sourceFile: null
                    });
                }, t.qualifiedTypeIdentifier = function(e1, t) {
                    return (0, r.default)({
                        type: "QualifiedTypeIdentifier",
                        id: e1,
                        qualification: t
                    });
                }, t.recordExpression = function(e1) {
                    return (0, r.default)({
                        type: "RecordExpression",
                        properties: e1
                    });
                }, t.regExpLiteral = a, t.regexLiteral = function(e1, t = "") {
                    return (0, i.default)("RegexLiteral", "RegExpLiteral", "The node type "), a(e1, t);
                }, t.restElement = o, t.restProperty = function(e1) {
                    return (0, i.default)("RestProperty", "RestElement", "The node type "), o(e1);
                }, t.returnStatement = function(e1 = null) {
                    return (0, r.default)({
                        type: "ReturnStatement",
                        argument: e1
                    });
                }, t.sequenceExpression = function(e1) {
                    return (0, r.default)({
                        type: "SequenceExpression",
                        expressions: e1
                    });
                }, t.spreadElement = l, t.spreadProperty = function(e1) {
                    return (0, i.default)("SpreadProperty", "SpreadElement", "The node type "), l(e1);
                }, t.staticBlock = function(e1) {
                    return (0, r.default)({
                        type: "StaticBlock",
                        body: e1
                    });
                }, t.stringLiteral = function(e1) {
                    return (0, r.default)({
                        type: "StringLiteral",
                        value: e1
                    });
                }, t.stringLiteralTypeAnnotation = function(e1) {
                    return (0, r.default)({
                        type: "StringLiteralTypeAnnotation",
                        value: e1
                    });
                }, t.stringTypeAnnotation = function() {
                    return {
                        type: "StringTypeAnnotation"
                    };
                }, t.super = function() {
                    return {
                        type: "Super"
                    };
                }, t.switchCase = function(e1 = null, t) {
                    return (0, r.default)({
                        type: "SwitchCase",
                        test: e1,
                        consequent: t
                    });
                }, t.switchStatement = function(e1, t) {
                    return (0, r.default)({
                        type: "SwitchStatement",
                        discriminant: e1,
                        cases: t
                    });
                }, t.symbolTypeAnnotation = function() {
                    return {
                        type: "SymbolTypeAnnotation"
                    };
                }, t.taggedTemplateExpression = function(e1, t) {
                    return (0, r.default)({
                        type: "TaggedTemplateExpression",
                        tag: e1,
                        quasi: t
                    });
                }, t.templateElement = function(e1, t = !1) {
                    return (0, r.default)({
                        type: "TemplateElement",
                        value: e1,
                        tail: t
                    });
                }, t.templateLiteral = function(e1, t) {
                    return (0, r.default)({
                        type: "TemplateLiteral",
                        quasis: e1,
                        expressions: t
                    });
                }, t.thisExpression = function() {
                    return {
                        type: "ThisExpression"
                    };
                }, t.thisTypeAnnotation = function() {
                    return {
                        type: "ThisTypeAnnotation"
                    };
                }, t.throwStatement = function(e1) {
                    return (0, r.default)({
                        type: "ThrowStatement",
                        argument: e1
                    });
                }, t.topicReference = function() {
                    return {
                        type: "TopicReference"
                    };
                }, t.tryStatement = function(e1, t = null, n = null) {
                    return (0, r.default)({
                        type: "TryStatement",
                        block: e1,
                        handler: t,
                        finalizer: n
                    });
                }, t.tSAnyKeyword = t.tsAnyKeyword = function() {
                    return {
                        type: "TSAnyKeyword"
                    };
                }, t.tSArrayType = t.tsArrayType = function(e1) {
                    return (0, r.default)({
                        type: "TSArrayType",
                        elementType: e1
                    });
                }, t.tSAsExpression = t.tsAsExpression = function(e1, t) {
                    return (0, r.default)({
                        type: "TSAsExpression",
                        expression: e1,
                        typeAnnotation: t
                    });
                }, t.tSBigIntKeyword = t.tsBigIntKeyword = function() {
                    return {
                        type: "TSBigIntKeyword"
                    };
                }, t.tSBooleanKeyword = t.tsBooleanKeyword = function() {
                    return {
                        type: "TSBooleanKeyword"
                    };
                }, t.tSCallSignatureDeclaration = t.tsCallSignatureDeclaration = function(e1 = null, t, n = null) {
                    return (0, r.default)({
                        type: "TSCallSignatureDeclaration",
                        typeParameters: e1,
                        parameters: t,
                        typeAnnotation: n
                    });
                }, t.tSConditionalType = t.tsConditionalType = function(e1, t, n, i) {
                    return (0, r.default)({
                        type: "TSConditionalType",
                        checkType: e1,
                        extendsType: t,
                        trueType: n,
                        falseType: i
                    });
                }, t.tSConstructSignatureDeclaration = t.tsConstructSignatureDeclaration = function(e1 = null, t, n = null) {
                    return (0, r.default)({
                        type: "TSConstructSignatureDeclaration",
                        typeParameters: e1,
                        parameters: t,
                        typeAnnotation: n
                    });
                }, t.tSConstructorType = t.tsConstructorType = function(e1 = null, t, n = null) {
                    return (0, r.default)({
                        type: "TSConstructorType",
                        typeParameters: e1,
                        parameters: t,
                        typeAnnotation: n
                    });
                }, t.tSDeclareFunction = t.tsDeclareFunction = function(e1 = null, t = null, n, i = null) {
                    return (0, r.default)({
                        type: "TSDeclareFunction",
                        id: e1,
                        typeParameters: t,
                        params: n,
                        returnType: i
                    });
                }, t.tSDeclareMethod = t.tsDeclareMethod = function(e1 = null, t, n = null, i, s = null) {
                    return (0, r.default)({
                        type: "TSDeclareMethod",
                        decorators: e1,
                        key: t,
                        typeParameters: n,
                        params: i,
                        returnType: s
                    });
                }, t.tSEnumDeclaration = t.tsEnumDeclaration = function(e1, t) {
                    return (0, r.default)({
                        type: "TSEnumDeclaration",
                        id: e1,
                        members: t
                    });
                }, t.tSEnumMember = t.tsEnumMember = function(e1, t = null) {
                    return (0, r.default)({
                        type: "TSEnumMember",
                        id: e1,
                        initializer: t
                    });
                }, t.tSExportAssignment = t.tsExportAssignment = function(e1) {
                    return (0, r.default)({
                        type: "TSExportAssignment",
                        expression: e1
                    });
                }, t.tSExpressionWithTypeArguments = t.tsExpressionWithTypeArguments = function(e1, t = null) {
                    return (0, r.default)({
                        type: "TSExpressionWithTypeArguments",
                        expression: e1,
                        typeParameters: t
                    });
                }, t.tSExternalModuleReference = t.tsExternalModuleReference = function(e1) {
                    return (0, r.default)({
                        type: "TSExternalModuleReference",
                        expression: e1
                    });
                }, t.tSFunctionType = t.tsFunctionType = function(e1 = null, t, n = null) {
                    return (0, r.default)({
                        type: "TSFunctionType",
                        typeParameters: e1,
                        parameters: t,
                        typeAnnotation: n
                    });
                }, t.tSImportEqualsDeclaration = t.tsImportEqualsDeclaration = function(e1, t) {
                    return (0, r.default)({
                        type: "TSImportEqualsDeclaration",
                        id: e1,
                        moduleReference: t,
                        isExport: null
                    });
                }, t.tSImportType = t.tsImportType = function(e1, t = null, n = null) {
                    return (0, r.default)({
                        type: "TSImportType",
                        argument: e1,
                        qualifier: t,
                        typeParameters: n
                    });
                }, t.tSIndexSignature = t.tsIndexSignature = function(e1, t = null) {
                    return (0, r.default)({
                        type: "TSIndexSignature",
                        parameters: e1,
                        typeAnnotation: t
                    });
                }, t.tSIndexedAccessType = t.tsIndexedAccessType = function(e1, t) {
                    return (0, r.default)({
                        type: "TSIndexedAccessType",
                        objectType: e1,
                        indexType: t
                    });
                }, t.tSInferType = t.tsInferType = function(e1) {
                    return (0, r.default)({
                        type: "TSInferType",
                        typeParameter: e1
                    });
                }, t.tSInstantiationExpression = t.tsInstantiationExpression = function(e1, t = null) {
                    return (0, r.default)({
                        type: "TSInstantiationExpression",
                        expression: e1,
                        typeParameters: t
                    });
                }, t.tSInterfaceBody = t.tsInterfaceBody = function(e1) {
                    return (0, r.default)({
                        type: "TSInterfaceBody",
                        body: e1
                    });
                }, t.tSInterfaceDeclaration = t.tsInterfaceDeclaration = function(e1, t = null, n = null, i) {
                    return (0, r.default)({
                        type: "TSInterfaceDeclaration",
                        id: e1,
                        typeParameters: t,
                        extends: n,
                        body: i
                    });
                }, t.tSIntersectionType = t.tsIntersectionType = function(e1) {
                    return (0, r.default)({
                        type: "TSIntersectionType",
                        types: e1
                    });
                }, t.tSIntrinsicKeyword = t.tsIntrinsicKeyword = function() {
                    return {
                        type: "TSIntrinsicKeyword"
                    };
                }, t.tSLiteralType = t.tsLiteralType = function(e1) {
                    return (0, r.default)({
                        type: "TSLiteralType",
                        literal: e1
                    });
                }, t.tSMappedType = t.tsMappedType = function(e1, t = null, n = null) {
                    return (0, r.default)({
                        type: "TSMappedType",
                        typeParameter: e1,
                        typeAnnotation: t,
                        nameType: n
                    });
                }, t.tSMethodSignature = t.tsMethodSignature = function(e1, t = null, n, i = null) {
                    return (0, r.default)({
                        type: "TSMethodSignature",
                        key: e1,
                        typeParameters: t,
                        parameters: n,
                        typeAnnotation: i,
                        kind: null
                    });
                }, t.tSModuleBlock = t.tsModuleBlock = function(e1) {
                    return (0, r.default)({
                        type: "TSModuleBlock",
                        body: e1
                    });
                }, t.tSModuleDeclaration = t.tsModuleDeclaration = function(e1, t) {
                    return (0, r.default)({
                        type: "TSModuleDeclaration",
                        id: e1,
                        body: t
                    });
                }, t.tSNamedTupleMember = t.tsNamedTupleMember = function(e1, t, n = !1) {
                    return (0, r.default)({
                        type: "TSNamedTupleMember",
                        label: e1,
                        elementType: t,
                        optional: n
                    });
                }, t.tSNamespaceExportDeclaration = t.tsNamespaceExportDeclaration = function(e1) {
                    return (0, r.default)({
                        type: "TSNamespaceExportDeclaration",
                        id: e1
                    });
                }, t.tSNeverKeyword = t.tsNeverKeyword = function() {
                    return {
                        type: "TSNeverKeyword"
                    };
                }, t.tSNonNullExpression = t.tsNonNullExpression = function(e1) {
                    return (0, r.default)({
                        type: "TSNonNullExpression",
                        expression: e1
                    });
                }, t.tSNullKeyword = t.tsNullKeyword = function() {
                    return {
                        type: "TSNullKeyword"
                    };
                }, t.tSNumberKeyword = t.tsNumberKeyword = function() {
                    return {
                        type: "TSNumberKeyword"
                    };
                }, t.tSObjectKeyword = t.tsObjectKeyword = function() {
                    return {
                        type: "TSObjectKeyword"
                    };
                }, t.tSOptionalType = t.tsOptionalType = function(e1) {
                    return (0, r.default)({
                        type: "TSOptionalType",
                        typeAnnotation: e1
                    });
                }, t.tSParameterProperty = t.tsParameterProperty = function(e1) {
                    return (0, r.default)({
                        type: "TSParameterProperty",
                        parameter: e1
                    });
                }, t.tSParenthesizedType = t.tsParenthesizedType = function(e1) {
                    return (0, r.default)({
                        type: "TSParenthesizedType",
                        typeAnnotation: e1
                    });
                }, t.tSPropertySignature = t.tsPropertySignature = function(e1, t = null, n = null) {
                    return (0, r.default)({
                        type: "TSPropertySignature",
                        key: e1,
                        typeAnnotation: t,
                        initializer: n,
                        kind: null
                    });
                }, t.tSQualifiedName = t.tsQualifiedName = function(e1, t) {
                    return (0, r.default)({
                        type: "TSQualifiedName",
                        left: e1,
                        right: t
                    });
                }, t.tSRestType = t.tsRestType = function(e1) {
                    return (0, r.default)({
                        type: "TSRestType",
                        typeAnnotation: e1
                    });
                }, t.tSSatisfiesExpression = t.tsSatisfiesExpression = function(e1, t) {
                    return (0, r.default)({
                        type: "TSSatisfiesExpression",
                        expression: e1,
                        typeAnnotation: t
                    });
                }, t.tSStringKeyword = t.tsStringKeyword = function() {
                    return {
                        type: "TSStringKeyword"
                    };
                }, t.tSSymbolKeyword = t.tsSymbolKeyword = function() {
                    return {
                        type: "TSSymbolKeyword"
                    };
                }, t.tSThisType = t.tsThisType = function() {
                    return {
                        type: "TSThisType"
                    };
                }, t.tSTupleType = t.tsTupleType = function(e1) {
                    return (0, r.default)({
                        type: "TSTupleType",
                        elementTypes: e1
                    });
                }, t.tSTypeAliasDeclaration = t.tsTypeAliasDeclaration = function(e1, t = null, n) {
                    return (0, r.default)({
                        type: "TSTypeAliasDeclaration",
                        id: e1,
                        typeParameters: t,
                        typeAnnotation: n
                    });
                }, t.tSTypeAnnotation = t.tsTypeAnnotation = function(e1) {
                    return (0, r.default)({
                        type: "TSTypeAnnotation",
                        typeAnnotation: e1
                    });
                }, t.tSTypeAssertion = t.tsTypeAssertion = function(e1, t) {
                    return (0, r.default)({
                        type: "TSTypeAssertion",
                        typeAnnotation: e1,
                        expression: t
                    });
                }, t.tSTypeLiteral = t.tsTypeLiteral = function(e1) {
                    return (0, r.default)({
                        type: "TSTypeLiteral",
                        members: e1
                    });
                }, t.tSTypeOperator = t.tsTypeOperator = function(e1) {
                    return (0, r.default)({
                        type: "TSTypeOperator",
                        typeAnnotation: e1,
                        operator: null
                    });
                }, t.tSTypeParameter = t.tsTypeParameter = function(e1 = null, t = null, n) {
                    return (0, r.default)({
                        type: "TSTypeParameter",
                        constraint: e1,
                        default: t,
                        name: n
                    });
                }, t.tSTypeParameterDeclaration = t.tsTypeParameterDeclaration = function(e1) {
                    return (0, r.default)({
                        type: "TSTypeParameterDeclaration",
                        params: e1
                    });
                }, t.tSTypeParameterInstantiation = t.tsTypeParameterInstantiation = function(e1) {
                    return (0, r.default)({
                        type: "TSTypeParameterInstantiation",
                        params: e1
                    });
                }, t.tSTypePredicate = t.tsTypePredicate = function(e1, t = null, n = null) {
                    return (0, r.default)({
                        type: "TSTypePredicate",
                        parameterName: e1,
                        typeAnnotation: t,
                        asserts: n
                    });
                }, t.tSTypeQuery = t.tsTypeQuery = function(e1, t = null) {
                    return (0, r.default)({
                        type: "TSTypeQuery",
                        exprName: e1,
                        typeParameters: t
                    });
                }, t.tSTypeReference = t.tsTypeReference = function(e1, t = null) {
                    return (0, r.default)({
                        type: "TSTypeReference",
                        typeName: e1,
                        typeParameters: t
                    });
                }, t.tSUndefinedKeyword = t.tsUndefinedKeyword = function() {
                    return {
                        type: "TSUndefinedKeyword"
                    };
                }, t.tSUnionType = t.tsUnionType = function(e1) {
                    return (0, r.default)({
                        type: "TSUnionType",
                        types: e1
                    });
                }, t.tSUnknownKeyword = t.tsUnknownKeyword = function() {
                    return {
                        type: "TSUnknownKeyword"
                    };
                }, t.tSVoidKeyword = t.tsVoidKeyword = function() {
                    return {
                        type: "TSVoidKeyword"
                    };
                }, t.tupleExpression = function(e1 = []) {
                    return (0, r.default)({
                        type: "TupleExpression",
                        elements: e1
                    });
                }, t.tupleTypeAnnotation = function(e1) {
                    return (0, r.default)({
                        type: "TupleTypeAnnotation",
                        types: e1
                    });
                }, t.typeAlias = function(e1, t = null, n) {
                    return (0, r.default)({
                        type: "TypeAlias",
                        id: e1,
                        typeParameters: t,
                        right: n
                    });
                }, t.typeAnnotation = function(e1) {
                    return (0, r.default)({
                        type: "TypeAnnotation",
                        typeAnnotation: e1
                    });
                }, t.typeCastExpression = function(e1, t) {
                    return (0, r.default)({
                        type: "TypeCastExpression",
                        expression: e1,
                        typeAnnotation: t
                    });
                }, t.typeParameter = function(e1 = null, t = null, n = null) {
                    return (0, r.default)({
                        type: "TypeParameter",
                        bound: e1,
                        default: t,
                        variance: n,
                        name: null
                    });
                }, t.typeParameterDeclaration = function(e1) {
                    return (0, r.default)({
                        type: "TypeParameterDeclaration",
                        params: e1
                    });
                }, t.typeParameterInstantiation = function(e1) {
                    return (0, r.default)({
                        type: "TypeParameterInstantiation",
                        params: e1
                    });
                }, t.typeofTypeAnnotation = function(e1) {
                    return (0, r.default)({
                        type: "TypeofTypeAnnotation",
                        argument: e1
                    });
                }, t.unaryExpression = function(e1, t, n = !0) {
                    return (0, r.default)({
                        type: "UnaryExpression",
                        operator: e1,
                        argument: t,
                        prefix: n
                    });
                }, t.unionTypeAnnotation = function(e1) {
                    return (0, r.default)({
                        type: "UnionTypeAnnotation",
                        types: e1
                    });
                }, t.updateExpression = function(e1, t, n = !1) {
                    return (0, r.default)({
                        type: "UpdateExpression",
                        operator: e1,
                        argument: t,
                        prefix: n
                    });
                }, t.v8IntrinsicIdentifier = function(e1) {
                    return (0, r.default)({
                        type: "V8IntrinsicIdentifier",
                        name: e1
                    });
                }, t.variableDeclaration = function(e1, t) {
                    return (0, r.default)({
                        type: "VariableDeclaration",
                        kind: e1,
                        declarations: t
                    });
                }, t.variableDeclarator = function(e1, t = null) {
                    return (0, r.default)({
                        type: "VariableDeclarator",
                        id: e1,
                        init: t
                    });
                }, t.variance = function(e1) {
                    return (0, r.default)({
                        type: "Variance",
                        kind: e1
                    });
                }, t.voidTypeAnnotation = function() {
                    return {
                        type: "VoidTypeAnnotation"
                    };
                }, t.whileStatement = function(e1, t) {
                    return (0, r.default)({
                        type: "WhileStatement",
                        test: e1,
                        body: t
                    });
                }, t.withStatement = function(e1, t) {
                    return (0, r.default)({
                        type: "WithStatement",
                        object: e1,
                        body: t
                    });
                }, t.yieldExpression = function(e1 = null, t = !1) {
                    return (0, r.default)({
                        type: "YieldExpression",
                        argument: e1,
                        delegate: t
                    });
                };
                var r = n(6505), i = n(4619);
                function s(e1) {
                    return (0, r.default)({
                        type: "NumericLiteral",
                        value: e1
                    });
                }
                function a(e1, t = "") {
                    return (0, r.default)({
                        type: "RegExpLiteral",
                        pattern: e1,
                        flags: t
                    });
                }
                function o(e1) {
                    return (0, r.default)({
                        type: "RestElement",
                        argument: e1
                    });
                }
                function l(e1) {
                    return (0, r.default)({
                        type: "SpreadElement",
                        argument: e1
                    });
                }
            },
            9470: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), Object.defineProperty(t, "AnyTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return r.anyTypeAnnotation;
                    }
                }), Object.defineProperty(t, "ArgumentPlaceholder", {
                    enumerable: !0,
                    get: function() {
                        return r.argumentPlaceholder;
                    }
                }), Object.defineProperty(t, "ArrayExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.arrayExpression;
                    }
                }), Object.defineProperty(t, "ArrayPattern", {
                    enumerable: !0,
                    get: function() {
                        return r.arrayPattern;
                    }
                }), Object.defineProperty(t, "ArrayTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return r.arrayTypeAnnotation;
                    }
                }), Object.defineProperty(t, "ArrowFunctionExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.arrowFunctionExpression;
                    }
                }), Object.defineProperty(t, "AssignmentExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.assignmentExpression;
                    }
                }), Object.defineProperty(t, "AssignmentPattern", {
                    enumerable: !0,
                    get: function() {
                        return r.assignmentPattern;
                    }
                }), Object.defineProperty(t, "AwaitExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.awaitExpression;
                    }
                }), Object.defineProperty(t, "BigIntLiteral", {
                    enumerable: !0,
                    get: function() {
                        return r.bigIntLiteral;
                    }
                }), Object.defineProperty(t, "BinaryExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.binaryExpression;
                    }
                }), Object.defineProperty(t, "BindExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.bindExpression;
                    }
                }), Object.defineProperty(t, "BlockStatement", {
                    enumerable: !0,
                    get: function() {
                        return r.blockStatement;
                    }
                }), Object.defineProperty(t, "BooleanLiteral", {
                    enumerable: !0,
                    get: function() {
                        return r.booleanLiteral;
                    }
                }), Object.defineProperty(t, "BooleanLiteralTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return r.booleanLiteralTypeAnnotation;
                    }
                }), Object.defineProperty(t, "BooleanTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return r.booleanTypeAnnotation;
                    }
                }), Object.defineProperty(t, "BreakStatement", {
                    enumerable: !0,
                    get: function() {
                        return r.breakStatement;
                    }
                }), Object.defineProperty(t, "CallExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.callExpression;
                    }
                }), Object.defineProperty(t, "CatchClause", {
                    enumerable: !0,
                    get: function() {
                        return r.catchClause;
                    }
                }), Object.defineProperty(t, "ClassAccessorProperty", {
                    enumerable: !0,
                    get: function() {
                        return r.classAccessorProperty;
                    }
                }), Object.defineProperty(t, "ClassBody", {
                    enumerable: !0,
                    get: function() {
                        return r.classBody;
                    }
                }), Object.defineProperty(t, "ClassDeclaration", {
                    enumerable: !0,
                    get: function() {
                        return r.classDeclaration;
                    }
                }), Object.defineProperty(t, "ClassExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.classExpression;
                    }
                }), Object.defineProperty(t, "ClassImplements", {
                    enumerable: !0,
                    get: function() {
                        return r.classImplements;
                    }
                }), Object.defineProperty(t, "ClassMethod", {
                    enumerable: !0,
                    get: function() {
                        return r.classMethod;
                    }
                }), Object.defineProperty(t, "ClassPrivateMethod", {
                    enumerable: !0,
                    get: function() {
                        return r.classPrivateMethod;
                    }
                }), Object.defineProperty(t, "ClassPrivateProperty", {
                    enumerable: !0,
                    get: function() {
                        return r.classPrivateProperty;
                    }
                }), Object.defineProperty(t, "ClassProperty", {
                    enumerable: !0,
                    get: function() {
                        return r.classProperty;
                    }
                }), Object.defineProperty(t, "ConditionalExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.conditionalExpression;
                    }
                }), Object.defineProperty(t, "ContinueStatement", {
                    enumerable: !0,
                    get: function() {
                        return r.continueStatement;
                    }
                }), Object.defineProperty(t, "DebuggerStatement", {
                    enumerable: !0,
                    get: function() {
                        return r.debuggerStatement;
                    }
                }), Object.defineProperty(t, "DecimalLiteral", {
                    enumerable: !0,
                    get: function() {
                        return r.decimalLiteral;
                    }
                }), Object.defineProperty(t, "DeclareClass", {
                    enumerable: !0,
                    get: function() {
                        return r.declareClass;
                    }
                }), Object.defineProperty(t, "DeclareExportAllDeclaration", {
                    enumerable: !0,
                    get: function() {
                        return r.declareExportAllDeclaration;
                    }
                }), Object.defineProperty(t, "DeclareExportDeclaration", {
                    enumerable: !0,
                    get: function() {
                        return r.declareExportDeclaration;
                    }
                }), Object.defineProperty(t, "DeclareFunction", {
                    enumerable: !0,
                    get: function() {
                        return r.declareFunction;
                    }
                }), Object.defineProperty(t, "DeclareInterface", {
                    enumerable: !0,
                    get: function() {
                        return r.declareInterface;
                    }
                }), Object.defineProperty(t, "DeclareModule", {
                    enumerable: !0,
                    get: function() {
                        return r.declareModule;
                    }
                }), Object.defineProperty(t, "DeclareModuleExports", {
                    enumerable: !0,
                    get: function() {
                        return r.declareModuleExports;
                    }
                }), Object.defineProperty(t, "DeclareOpaqueType", {
                    enumerable: !0,
                    get: function() {
                        return r.declareOpaqueType;
                    }
                }), Object.defineProperty(t, "DeclareTypeAlias", {
                    enumerable: !0,
                    get: function() {
                        return r.declareTypeAlias;
                    }
                }), Object.defineProperty(t, "DeclareVariable", {
                    enumerable: !0,
                    get: function() {
                        return r.declareVariable;
                    }
                }), Object.defineProperty(t, "DeclaredPredicate", {
                    enumerable: !0,
                    get: function() {
                        return r.declaredPredicate;
                    }
                }), Object.defineProperty(t, "Decorator", {
                    enumerable: !0,
                    get: function() {
                        return r.decorator;
                    }
                }), Object.defineProperty(t, "Directive", {
                    enumerable: !0,
                    get: function() {
                        return r.directive;
                    }
                }), Object.defineProperty(t, "DirectiveLiteral", {
                    enumerable: !0,
                    get: function() {
                        return r.directiveLiteral;
                    }
                }), Object.defineProperty(t, "DoExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.doExpression;
                    }
                }), Object.defineProperty(t, "DoWhileStatement", {
                    enumerable: !0,
                    get: function() {
                        return r.doWhileStatement;
                    }
                }), Object.defineProperty(t, "EmptyStatement", {
                    enumerable: !0,
                    get: function() {
                        return r.emptyStatement;
                    }
                }), Object.defineProperty(t, "EmptyTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return r.emptyTypeAnnotation;
                    }
                }), Object.defineProperty(t, "EnumBooleanBody", {
                    enumerable: !0,
                    get: function() {
                        return r.enumBooleanBody;
                    }
                }), Object.defineProperty(t, "EnumBooleanMember", {
                    enumerable: !0,
                    get: function() {
                        return r.enumBooleanMember;
                    }
                }), Object.defineProperty(t, "EnumDeclaration", {
                    enumerable: !0,
                    get: function() {
                        return r.enumDeclaration;
                    }
                }), Object.defineProperty(t, "EnumDefaultedMember", {
                    enumerable: !0,
                    get: function() {
                        return r.enumDefaultedMember;
                    }
                }), Object.defineProperty(t, "EnumNumberBody", {
                    enumerable: !0,
                    get: function() {
                        return r.enumNumberBody;
                    }
                }), Object.defineProperty(t, "EnumNumberMember", {
                    enumerable: !0,
                    get: function() {
                        return r.enumNumberMember;
                    }
                }), Object.defineProperty(t, "EnumStringBody", {
                    enumerable: !0,
                    get: function() {
                        return r.enumStringBody;
                    }
                }), Object.defineProperty(t, "EnumStringMember", {
                    enumerable: !0,
                    get: function() {
                        return r.enumStringMember;
                    }
                }), Object.defineProperty(t, "EnumSymbolBody", {
                    enumerable: !0,
                    get: function() {
                        return r.enumSymbolBody;
                    }
                }), Object.defineProperty(t, "ExistsTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return r.existsTypeAnnotation;
                    }
                }), Object.defineProperty(t, "ExportAllDeclaration", {
                    enumerable: !0,
                    get: function() {
                        return r.exportAllDeclaration;
                    }
                }), Object.defineProperty(t, "ExportDefaultDeclaration", {
                    enumerable: !0,
                    get: function() {
                        return r.exportDefaultDeclaration;
                    }
                }), Object.defineProperty(t, "ExportDefaultSpecifier", {
                    enumerable: !0,
                    get: function() {
                        return r.exportDefaultSpecifier;
                    }
                }), Object.defineProperty(t, "ExportNamedDeclaration", {
                    enumerable: !0,
                    get: function() {
                        return r.exportNamedDeclaration;
                    }
                }), Object.defineProperty(t, "ExportNamespaceSpecifier", {
                    enumerable: !0,
                    get: function() {
                        return r.exportNamespaceSpecifier;
                    }
                }), Object.defineProperty(t, "ExportSpecifier", {
                    enumerable: !0,
                    get: function() {
                        return r.exportSpecifier;
                    }
                }), Object.defineProperty(t, "ExpressionStatement", {
                    enumerable: !0,
                    get: function() {
                        return r.expressionStatement;
                    }
                }), Object.defineProperty(t, "File", {
                    enumerable: !0,
                    get: function() {
                        return r.file;
                    }
                }), Object.defineProperty(t, "ForInStatement", {
                    enumerable: !0,
                    get: function() {
                        return r.forInStatement;
                    }
                }), Object.defineProperty(t, "ForOfStatement", {
                    enumerable: !0,
                    get: function() {
                        return r.forOfStatement;
                    }
                }), Object.defineProperty(t, "ForStatement", {
                    enumerable: !0,
                    get: function() {
                        return r.forStatement;
                    }
                }), Object.defineProperty(t, "FunctionDeclaration", {
                    enumerable: !0,
                    get: function() {
                        return r.functionDeclaration;
                    }
                }), Object.defineProperty(t, "FunctionExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.functionExpression;
                    }
                }), Object.defineProperty(t, "FunctionTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return r.functionTypeAnnotation;
                    }
                }), Object.defineProperty(t, "FunctionTypeParam", {
                    enumerable: !0,
                    get: function() {
                        return r.functionTypeParam;
                    }
                }), Object.defineProperty(t, "GenericTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return r.genericTypeAnnotation;
                    }
                }), Object.defineProperty(t, "Identifier", {
                    enumerable: !0,
                    get: function() {
                        return r.identifier;
                    }
                }), Object.defineProperty(t, "IfStatement", {
                    enumerable: !0,
                    get: function() {
                        return r.ifStatement;
                    }
                }), Object.defineProperty(t, "Import", {
                    enumerable: !0,
                    get: function() {
                        return r.import;
                    }
                }), Object.defineProperty(t, "ImportAttribute", {
                    enumerable: !0,
                    get: function() {
                        return r.importAttribute;
                    }
                }), Object.defineProperty(t, "ImportDeclaration", {
                    enumerable: !0,
                    get: function() {
                        return r.importDeclaration;
                    }
                }), Object.defineProperty(t, "ImportDefaultSpecifier", {
                    enumerable: !0,
                    get: function() {
                        return r.importDefaultSpecifier;
                    }
                }), Object.defineProperty(t, "ImportNamespaceSpecifier", {
                    enumerable: !0,
                    get: function() {
                        return r.importNamespaceSpecifier;
                    }
                }), Object.defineProperty(t, "ImportSpecifier", {
                    enumerable: !0,
                    get: function() {
                        return r.importSpecifier;
                    }
                }), Object.defineProperty(t, "IndexedAccessType", {
                    enumerable: !0,
                    get: function() {
                        return r.indexedAccessType;
                    }
                }), Object.defineProperty(t, "InferredPredicate", {
                    enumerable: !0,
                    get: function() {
                        return r.inferredPredicate;
                    }
                }), Object.defineProperty(t, "InterfaceDeclaration", {
                    enumerable: !0,
                    get: function() {
                        return r.interfaceDeclaration;
                    }
                }), Object.defineProperty(t, "InterfaceExtends", {
                    enumerable: !0,
                    get: function() {
                        return r.interfaceExtends;
                    }
                }), Object.defineProperty(t, "InterfaceTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return r.interfaceTypeAnnotation;
                    }
                }), Object.defineProperty(t, "InterpreterDirective", {
                    enumerable: !0,
                    get: function() {
                        return r.interpreterDirective;
                    }
                }), Object.defineProperty(t, "IntersectionTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return r.intersectionTypeAnnotation;
                    }
                }), Object.defineProperty(t, "JSXAttribute", {
                    enumerable: !0,
                    get: function() {
                        return r.jsxAttribute;
                    }
                }), Object.defineProperty(t, "JSXClosingElement", {
                    enumerable: !0,
                    get: function() {
                        return r.jsxClosingElement;
                    }
                }), Object.defineProperty(t, "JSXClosingFragment", {
                    enumerable: !0,
                    get: function() {
                        return r.jsxClosingFragment;
                    }
                }), Object.defineProperty(t, "JSXElement", {
                    enumerable: !0,
                    get: function() {
                        return r.jsxElement;
                    }
                }), Object.defineProperty(t, "JSXEmptyExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.jsxEmptyExpression;
                    }
                }), Object.defineProperty(t, "JSXExpressionContainer", {
                    enumerable: !0,
                    get: function() {
                        return r.jsxExpressionContainer;
                    }
                }), Object.defineProperty(t, "JSXFragment", {
                    enumerable: !0,
                    get: function() {
                        return r.jsxFragment;
                    }
                }), Object.defineProperty(t, "JSXIdentifier", {
                    enumerable: !0,
                    get: function() {
                        return r.jsxIdentifier;
                    }
                }), Object.defineProperty(t, "JSXMemberExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.jsxMemberExpression;
                    }
                }), Object.defineProperty(t, "JSXNamespacedName", {
                    enumerable: !0,
                    get: function() {
                        return r.jsxNamespacedName;
                    }
                }), Object.defineProperty(t, "JSXOpeningElement", {
                    enumerable: !0,
                    get: function() {
                        return r.jsxOpeningElement;
                    }
                }), Object.defineProperty(t, "JSXOpeningFragment", {
                    enumerable: !0,
                    get: function() {
                        return r.jsxOpeningFragment;
                    }
                }), Object.defineProperty(t, "JSXSpreadAttribute", {
                    enumerable: !0,
                    get: function() {
                        return r.jsxSpreadAttribute;
                    }
                }), Object.defineProperty(t, "JSXSpreadChild", {
                    enumerable: !0,
                    get: function() {
                        return r.jsxSpreadChild;
                    }
                }), Object.defineProperty(t, "JSXText", {
                    enumerable: !0,
                    get: function() {
                        return r.jsxText;
                    }
                }), Object.defineProperty(t, "LabeledStatement", {
                    enumerable: !0,
                    get: function() {
                        return r.labeledStatement;
                    }
                }), Object.defineProperty(t, "LogicalExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.logicalExpression;
                    }
                }), Object.defineProperty(t, "MemberExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.memberExpression;
                    }
                }), Object.defineProperty(t, "MetaProperty", {
                    enumerable: !0,
                    get: function() {
                        return r.metaProperty;
                    }
                }), Object.defineProperty(t, "MixedTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return r.mixedTypeAnnotation;
                    }
                }), Object.defineProperty(t, "ModuleExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.moduleExpression;
                    }
                }), Object.defineProperty(t, "NewExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.newExpression;
                    }
                }), Object.defineProperty(t, "Noop", {
                    enumerable: !0,
                    get: function() {
                        return r.noop;
                    }
                }), Object.defineProperty(t, "NullLiteral", {
                    enumerable: !0,
                    get: function() {
                        return r.nullLiteral;
                    }
                }), Object.defineProperty(t, "NullLiteralTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return r.nullLiteralTypeAnnotation;
                    }
                }), Object.defineProperty(t, "NullableTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return r.nullableTypeAnnotation;
                    }
                }), Object.defineProperty(t, "NumberLiteral", {
                    enumerable: !0,
                    get: function() {
                        return r.numberLiteral;
                    }
                }), Object.defineProperty(t, "NumberLiteralTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return r.numberLiteralTypeAnnotation;
                    }
                }), Object.defineProperty(t, "NumberTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return r.numberTypeAnnotation;
                    }
                }), Object.defineProperty(t, "NumericLiteral", {
                    enumerable: !0,
                    get: function() {
                        return r.numericLiteral;
                    }
                }), Object.defineProperty(t, "ObjectExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.objectExpression;
                    }
                }), Object.defineProperty(t, "ObjectMethod", {
                    enumerable: !0,
                    get: function() {
                        return r.objectMethod;
                    }
                }), Object.defineProperty(t, "ObjectPattern", {
                    enumerable: !0,
                    get: function() {
                        return r.objectPattern;
                    }
                }), Object.defineProperty(t, "ObjectProperty", {
                    enumerable: !0,
                    get: function() {
                        return r.objectProperty;
                    }
                }), Object.defineProperty(t, "ObjectTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return r.objectTypeAnnotation;
                    }
                }), Object.defineProperty(t, "ObjectTypeCallProperty", {
                    enumerable: !0,
                    get: function() {
                        return r.objectTypeCallProperty;
                    }
                }), Object.defineProperty(t, "ObjectTypeIndexer", {
                    enumerable: !0,
                    get: function() {
                        return r.objectTypeIndexer;
                    }
                }), Object.defineProperty(t, "ObjectTypeInternalSlot", {
                    enumerable: !0,
                    get: function() {
                        return r.objectTypeInternalSlot;
                    }
                }), Object.defineProperty(t, "ObjectTypeProperty", {
                    enumerable: !0,
                    get: function() {
                        return r.objectTypeProperty;
                    }
                }), Object.defineProperty(t, "ObjectTypeSpreadProperty", {
                    enumerable: !0,
                    get: function() {
                        return r.objectTypeSpreadProperty;
                    }
                }), Object.defineProperty(t, "OpaqueType", {
                    enumerable: !0,
                    get: function() {
                        return r.opaqueType;
                    }
                }), Object.defineProperty(t, "OptionalCallExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.optionalCallExpression;
                    }
                }), Object.defineProperty(t, "OptionalIndexedAccessType", {
                    enumerable: !0,
                    get: function() {
                        return r.optionalIndexedAccessType;
                    }
                }), Object.defineProperty(t, "OptionalMemberExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.optionalMemberExpression;
                    }
                }), Object.defineProperty(t, "ParenthesizedExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.parenthesizedExpression;
                    }
                }), Object.defineProperty(t, "PipelineBareFunction", {
                    enumerable: !0,
                    get: function() {
                        return r.pipelineBareFunction;
                    }
                }), Object.defineProperty(t, "PipelinePrimaryTopicReference", {
                    enumerable: !0,
                    get: function() {
                        return r.pipelinePrimaryTopicReference;
                    }
                }), Object.defineProperty(t, "PipelineTopicExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.pipelineTopicExpression;
                    }
                }), Object.defineProperty(t, "Placeholder", {
                    enumerable: !0,
                    get: function() {
                        return r.placeholder;
                    }
                }), Object.defineProperty(t, "PrivateName", {
                    enumerable: !0,
                    get: function() {
                        return r.privateName;
                    }
                }), Object.defineProperty(t, "Program", {
                    enumerable: !0,
                    get: function() {
                        return r.program;
                    }
                }), Object.defineProperty(t, "QualifiedTypeIdentifier", {
                    enumerable: !0,
                    get: function() {
                        return r.qualifiedTypeIdentifier;
                    }
                }), Object.defineProperty(t, "RecordExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.recordExpression;
                    }
                }), Object.defineProperty(t, "RegExpLiteral", {
                    enumerable: !0,
                    get: function() {
                        return r.regExpLiteral;
                    }
                }), Object.defineProperty(t, "RegexLiteral", {
                    enumerable: !0,
                    get: function() {
                        return r.regexLiteral;
                    }
                }), Object.defineProperty(t, "RestElement", {
                    enumerable: !0,
                    get: function() {
                        return r.restElement;
                    }
                }), Object.defineProperty(t, "RestProperty", {
                    enumerable: !0,
                    get: function() {
                        return r.restProperty;
                    }
                }), Object.defineProperty(t, "ReturnStatement", {
                    enumerable: !0,
                    get: function() {
                        return r.returnStatement;
                    }
                }), Object.defineProperty(t, "SequenceExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.sequenceExpression;
                    }
                }), Object.defineProperty(t, "SpreadElement", {
                    enumerable: !0,
                    get: function() {
                        return r.spreadElement;
                    }
                }), Object.defineProperty(t, "SpreadProperty", {
                    enumerable: !0,
                    get: function() {
                        return r.spreadProperty;
                    }
                }), Object.defineProperty(t, "StaticBlock", {
                    enumerable: !0,
                    get: function() {
                        return r.staticBlock;
                    }
                }), Object.defineProperty(t, "StringLiteral", {
                    enumerable: !0,
                    get: function() {
                        return r.stringLiteral;
                    }
                }), Object.defineProperty(t, "StringLiteralTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return r.stringLiteralTypeAnnotation;
                    }
                }), Object.defineProperty(t, "StringTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return r.stringTypeAnnotation;
                    }
                }), Object.defineProperty(t, "Super", {
                    enumerable: !0,
                    get: function() {
                        return r.super;
                    }
                }), Object.defineProperty(t, "SwitchCase", {
                    enumerable: !0,
                    get: function() {
                        return r.switchCase;
                    }
                }), Object.defineProperty(t, "SwitchStatement", {
                    enumerable: !0,
                    get: function() {
                        return r.switchStatement;
                    }
                }), Object.defineProperty(t, "SymbolTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return r.symbolTypeAnnotation;
                    }
                }), Object.defineProperty(t, "TSAnyKeyword", {
                    enumerable: !0,
                    get: function() {
                        return r.tsAnyKeyword;
                    }
                }), Object.defineProperty(t, "TSArrayType", {
                    enumerable: !0,
                    get: function() {
                        return r.tsArrayType;
                    }
                }), Object.defineProperty(t, "TSAsExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.tsAsExpression;
                    }
                }), Object.defineProperty(t, "TSBigIntKeyword", {
                    enumerable: !0,
                    get: function() {
                        return r.tsBigIntKeyword;
                    }
                }), Object.defineProperty(t, "TSBooleanKeyword", {
                    enumerable: !0,
                    get: function() {
                        return r.tsBooleanKeyword;
                    }
                }), Object.defineProperty(t, "TSCallSignatureDeclaration", {
                    enumerable: !0,
                    get: function() {
                        return r.tsCallSignatureDeclaration;
                    }
                }), Object.defineProperty(t, "TSConditionalType", {
                    enumerable: !0,
                    get: function() {
                        return r.tsConditionalType;
                    }
                }), Object.defineProperty(t, "TSConstructSignatureDeclaration", {
                    enumerable: !0,
                    get: function() {
                        return r.tsConstructSignatureDeclaration;
                    }
                }), Object.defineProperty(t, "TSConstructorType", {
                    enumerable: !0,
                    get: function() {
                        return r.tsConstructorType;
                    }
                }), Object.defineProperty(t, "TSDeclareFunction", {
                    enumerable: !0,
                    get: function() {
                        return r.tsDeclareFunction;
                    }
                }), Object.defineProperty(t, "TSDeclareMethod", {
                    enumerable: !0,
                    get: function() {
                        return r.tsDeclareMethod;
                    }
                }), Object.defineProperty(t, "TSEnumDeclaration", {
                    enumerable: !0,
                    get: function() {
                        return r.tsEnumDeclaration;
                    }
                }), Object.defineProperty(t, "TSEnumMember", {
                    enumerable: !0,
                    get: function() {
                        return r.tsEnumMember;
                    }
                }), Object.defineProperty(t, "TSExportAssignment", {
                    enumerable: !0,
                    get: function() {
                        return r.tsExportAssignment;
                    }
                }), Object.defineProperty(t, "TSExpressionWithTypeArguments", {
                    enumerable: !0,
                    get: function() {
                        return r.tsExpressionWithTypeArguments;
                    }
                }), Object.defineProperty(t, "TSExternalModuleReference", {
                    enumerable: !0,
                    get: function() {
                        return r.tsExternalModuleReference;
                    }
                }), Object.defineProperty(t, "TSFunctionType", {
                    enumerable: !0,
                    get: function() {
                        return r.tsFunctionType;
                    }
                }), Object.defineProperty(t, "TSImportEqualsDeclaration", {
                    enumerable: !0,
                    get: function() {
                        return r.tsImportEqualsDeclaration;
                    }
                }), Object.defineProperty(t, "TSImportType", {
                    enumerable: !0,
                    get: function() {
                        return r.tsImportType;
                    }
                }), Object.defineProperty(t, "TSIndexSignature", {
                    enumerable: !0,
                    get: function() {
                        return r.tsIndexSignature;
                    }
                }), Object.defineProperty(t, "TSIndexedAccessType", {
                    enumerable: !0,
                    get: function() {
                        return r.tsIndexedAccessType;
                    }
                }), Object.defineProperty(t, "TSInferType", {
                    enumerable: !0,
                    get: function() {
                        return r.tsInferType;
                    }
                }), Object.defineProperty(t, "TSInstantiationExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.tsInstantiationExpression;
                    }
                }), Object.defineProperty(t, "TSInterfaceBody", {
                    enumerable: !0,
                    get: function() {
                        return r.tsInterfaceBody;
                    }
                }), Object.defineProperty(t, "TSInterfaceDeclaration", {
                    enumerable: !0,
                    get: function() {
                        return r.tsInterfaceDeclaration;
                    }
                }), Object.defineProperty(t, "TSIntersectionType", {
                    enumerable: !0,
                    get: function() {
                        return r.tsIntersectionType;
                    }
                }), Object.defineProperty(t, "TSIntrinsicKeyword", {
                    enumerable: !0,
                    get: function() {
                        return r.tsIntrinsicKeyword;
                    }
                }), Object.defineProperty(t, "TSLiteralType", {
                    enumerable: !0,
                    get: function() {
                        return r.tsLiteralType;
                    }
                }), Object.defineProperty(t, "TSMappedType", {
                    enumerable: !0,
                    get: function() {
                        return r.tsMappedType;
                    }
                }), Object.defineProperty(t, "TSMethodSignature", {
                    enumerable: !0,
                    get: function() {
                        return r.tsMethodSignature;
                    }
                }), Object.defineProperty(t, "TSModuleBlock", {
                    enumerable: !0,
                    get: function() {
                        return r.tsModuleBlock;
                    }
                }), Object.defineProperty(t, "TSModuleDeclaration", {
                    enumerable: !0,
                    get: function() {
                        return r.tsModuleDeclaration;
                    }
                }), Object.defineProperty(t, "TSNamedTupleMember", {
                    enumerable: !0,
                    get: function() {
                        return r.tsNamedTupleMember;
                    }
                }), Object.defineProperty(t, "TSNamespaceExportDeclaration", {
                    enumerable: !0,
                    get: function() {
                        return r.tsNamespaceExportDeclaration;
                    }
                }), Object.defineProperty(t, "TSNeverKeyword", {
                    enumerable: !0,
                    get: function() {
                        return r.tsNeverKeyword;
                    }
                }), Object.defineProperty(t, "TSNonNullExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.tsNonNullExpression;
                    }
                }), Object.defineProperty(t, "TSNullKeyword", {
                    enumerable: !0,
                    get: function() {
                        return r.tsNullKeyword;
                    }
                }), Object.defineProperty(t, "TSNumberKeyword", {
                    enumerable: !0,
                    get: function() {
                        return r.tsNumberKeyword;
                    }
                }), Object.defineProperty(t, "TSObjectKeyword", {
                    enumerable: !0,
                    get: function() {
                        return r.tsObjectKeyword;
                    }
                }), Object.defineProperty(t, "TSOptionalType", {
                    enumerable: !0,
                    get: function() {
                        return r.tsOptionalType;
                    }
                }), Object.defineProperty(t, "TSParameterProperty", {
                    enumerable: !0,
                    get: function() {
                        return r.tsParameterProperty;
                    }
                }), Object.defineProperty(t, "TSParenthesizedType", {
                    enumerable: !0,
                    get: function() {
                        return r.tsParenthesizedType;
                    }
                }), Object.defineProperty(t, "TSPropertySignature", {
                    enumerable: !0,
                    get: function() {
                        return r.tsPropertySignature;
                    }
                }), Object.defineProperty(t, "TSQualifiedName", {
                    enumerable: !0,
                    get: function() {
                        return r.tsQualifiedName;
                    }
                }), Object.defineProperty(t, "TSRestType", {
                    enumerable: !0,
                    get: function() {
                        return r.tsRestType;
                    }
                }), Object.defineProperty(t, "TSSatisfiesExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.tsSatisfiesExpression;
                    }
                }), Object.defineProperty(t, "TSStringKeyword", {
                    enumerable: !0,
                    get: function() {
                        return r.tsStringKeyword;
                    }
                }), Object.defineProperty(t, "TSSymbolKeyword", {
                    enumerable: !0,
                    get: function() {
                        return r.tsSymbolKeyword;
                    }
                }), Object.defineProperty(t, "TSThisType", {
                    enumerable: !0,
                    get: function() {
                        return r.tsThisType;
                    }
                }), Object.defineProperty(t, "TSTupleType", {
                    enumerable: !0,
                    get: function() {
                        return r.tsTupleType;
                    }
                }), Object.defineProperty(t, "TSTypeAliasDeclaration", {
                    enumerable: !0,
                    get: function() {
                        return r.tsTypeAliasDeclaration;
                    }
                }), Object.defineProperty(t, "TSTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return r.tsTypeAnnotation;
                    }
                }), Object.defineProperty(t, "TSTypeAssertion", {
                    enumerable: !0,
                    get: function() {
                        return r.tsTypeAssertion;
                    }
                }), Object.defineProperty(t, "TSTypeLiteral", {
                    enumerable: !0,
                    get: function() {
                        return r.tsTypeLiteral;
                    }
                }), Object.defineProperty(t, "TSTypeOperator", {
                    enumerable: !0,
                    get: function() {
                        return r.tsTypeOperator;
                    }
                }), Object.defineProperty(t, "TSTypeParameter", {
                    enumerable: !0,
                    get: function() {
                        return r.tsTypeParameter;
                    }
                }), Object.defineProperty(t, "TSTypeParameterDeclaration", {
                    enumerable: !0,
                    get: function() {
                        return r.tsTypeParameterDeclaration;
                    }
                }), Object.defineProperty(t, "TSTypeParameterInstantiation", {
                    enumerable: !0,
                    get: function() {
                        return r.tsTypeParameterInstantiation;
                    }
                }), Object.defineProperty(t, "TSTypePredicate", {
                    enumerable: !0,
                    get: function() {
                        return r.tsTypePredicate;
                    }
                }), Object.defineProperty(t, "TSTypeQuery", {
                    enumerable: !0,
                    get: function() {
                        return r.tsTypeQuery;
                    }
                }), Object.defineProperty(t, "TSTypeReference", {
                    enumerable: !0,
                    get: function() {
                        return r.tsTypeReference;
                    }
                }), Object.defineProperty(t, "TSUndefinedKeyword", {
                    enumerable: !0,
                    get: function() {
                        return r.tsUndefinedKeyword;
                    }
                }), Object.defineProperty(t, "TSUnionType", {
                    enumerable: !0,
                    get: function() {
                        return r.tsUnionType;
                    }
                }), Object.defineProperty(t, "TSUnknownKeyword", {
                    enumerable: !0,
                    get: function() {
                        return r.tsUnknownKeyword;
                    }
                }), Object.defineProperty(t, "TSVoidKeyword", {
                    enumerable: !0,
                    get: function() {
                        return r.tsVoidKeyword;
                    }
                }), Object.defineProperty(t, "TaggedTemplateExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.taggedTemplateExpression;
                    }
                }), Object.defineProperty(t, "TemplateElement", {
                    enumerable: !0,
                    get: function() {
                        return r.templateElement;
                    }
                }), Object.defineProperty(t, "TemplateLiteral", {
                    enumerable: !0,
                    get: function() {
                        return r.templateLiteral;
                    }
                }), Object.defineProperty(t, "ThisExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.thisExpression;
                    }
                }), Object.defineProperty(t, "ThisTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return r.thisTypeAnnotation;
                    }
                }), Object.defineProperty(t, "ThrowStatement", {
                    enumerable: !0,
                    get: function() {
                        return r.throwStatement;
                    }
                }), Object.defineProperty(t, "TopicReference", {
                    enumerable: !0,
                    get: function() {
                        return r.topicReference;
                    }
                }), Object.defineProperty(t, "TryStatement", {
                    enumerable: !0,
                    get: function() {
                        return r.tryStatement;
                    }
                }), Object.defineProperty(t, "TupleExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.tupleExpression;
                    }
                }), Object.defineProperty(t, "TupleTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return r.tupleTypeAnnotation;
                    }
                }), Object.defineProperty(t, "TypeAlias", {
                    enumerable: !0,
                    get: function() {
                        return r.typeAlias;
                    }
                }), Object.defineProperty(t, "TypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return r.typeAnnotation;
                    }
                }), Object.defineProperty(t, "TypeCastExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.typeCastExpression;
                    }
                }), Object.defineProperty(t, "TypeParameter", {
                    enumerable: !0,
                    get: function() {
                        return r.typeParameter;
                    }
                }), Object.defineProperty(t, "TypeParameterDeclaration", {
                    enumerable: !0,
                    get: function() {
                        return r.typeParameterDeclaration;
                    }
                }), Object.defineProperty(t, "TypeParameterInstantiation", {
                    enumerable: !0,
                    get: function() {
                        return r.typeParameterInstantiation;
                    }
                }), Object.defineProperty(t, "TypeofTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return r.typeofTypeAnnotation;
                    }
                }), Object.defineProperty(t, "UnaryExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.unaryExpression;
                    }
                }), Object.defineProperty(t, "UnionTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return r.unionTypeAnnotation;
                    }
                }), Object.defineProperty(t, "UpdateExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.updateExpression;
                    }
                }), Object.defineProperty(t, "V8IntrinsicIdentifier", {
                    enumerable: !0,
                    get: function() {
                        return r.v8IntrinsicIdentifier;
                    }
                }), Object.defineProperty(t, "VariableDeclaration", {
                    enumerable: !0,
                    get: function() {
                        return r.variableDeclaration;
                    }
                }), Object.defineProperty(t, "VariableDeclarator", {
                    enumerable: !0,
                    get: function() {
                        return r.variableDeclarator;
                    }
                }), Object.defineProperty(t, "Variance", {
                    enumerable: !0,
                    get: function() {
                        return r.variance;
                    }
                }), Object.defineProperty(t, "VoidTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return r.voidTypeAnnotation;
                    }
                }), Object.defineProperty(t, "WhileStatement", {
                    enumerable: !0,
                    get: function() {
                        return r.whileStatement;
                    }
                }), Object.defineProperty(t, "WithStatement", {
                    enumerable: !0,
                    get: function() {
                        return r.withStatement;
                    }
                }), Object.defineProperty(t, "YieldExpression", {
                    enumerable: !0,
                    get: function() {
                        return r.yieldExpression;
                    }
                });
                var r = n(1411);
            },
            4225: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1) {
                    const t = [];
                    for(let n = 0; n < e1.children.length; n++){
                        let s = e1.children[n];
                        (0, r.isJSXText)(s) ? (0, i.default)(s, t) : ((0, r.isJSXExpressionContainer)(s) && (s = s.expression), (0, r.isJSXEmptyExpression)(s) || t.push(s));
                    }
                    return t;
                };
                var r = n(9869), i = n(8730);
            },
            6752: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1) {
                    const t = e1.map((e1)=>(0, s.isTSTypeAnnotation)(e1) ? e1.typeAnnotation : e1), n = (0, i.default)(t);
                    return 1 === n.length ? n[0] : (0, r.tsUnionType)(n);
                };
                var r = n(1411), i = n(2819), s = n(9869);
            },
            6505: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1) {
                    const t = i.BUILDER_KEYS[e1.type];
                    for (const n of t)(0, r.default)(e1, n, e1[n]);
                    return e1;
                };
                var r = n(7750), i = n(6067);
            },
            8229: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1) {
                    return (0, r.default)(e1, !1);
                };
                var r = n(2419);
            },
            8030: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1) {
                    return (0, r.default)(e1);
                };
                var r = n(2419);
            },
            8519: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1) {
                    return (0, r.default)(e1, !0, !0);
                };
                var r = n(2419);
            },
            2419: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t = !0, n = !1) {
                    return l(e1, t, n, new Map);
                };
                var r = n(1678), i = n(9869);
                const s = Function.call.bind(Object.prototype.hasOwnProperty);
                function a(e1, t, n, r) {
                    return e1 && "string" == typeof e1.type ? l(e1, t, n, r) : e1;
                }
                function o(e1, t, n, r) {
                    return Array.isArray(e1) ? e1.map((e1)=>a(e1, t, n, r)) : a(e1, t, n, r);
                }
                function l(e1, t = !0, n = !1, a) {
                    if (!e1) return e1;
                    const { type: l1 } = e1, u = {
                        type: e1.type
                    };
                    if ((0, i.isIdentifier)(e1)) u.name = e1.name, s(e1, "optional") && "boolean" == typeof e1.optional && (u.optional = e1.optional), s(e1, "typeAnnotation") && (u.typeAnnotation = t ? o(e1.typeAnnotation, !0, n, a) : e1.typeAnnotation);
                    else {
                        if (!s(r.NODE_FIELDS, l1)) throw new Error(`Unknown node type: "${l1}"`);
                        for (const p of Object.keys(r.NODE_FIELDS[l1]))s(e1, p) && (u[p] = t ? (0, i.isFile)(e1) && "comments" === p ? c(e1.comments, t, n, a) : o(e1[p], !0, n, a) : e1[p]);
                    }
                    return s(e1, "loc") && (u.loc = n ? null : e1.loc), s(e1, "leadingComments") && (u.leadingComments = c(e1.leadingComments, t, n, a)), s(e1, "innerComments") && (u.innerComments = c(e1.innerComments, t, n, a)), s(e1, "trailingComments") && (u.trailingComments = c(e1.trailingComments, t, n, a)), s(e1, "extra") && (u.extra = Object.assign({}, e1.extra)), u;
                }
                function c(e1, t, n, r) {
                    return e1 && t ? e1.map((e1)=>{
                        const t = r.get(e1);
                        if (t) return t;
                        const { type: i, value: s, loc: a } = e1, o = {
                            type: i,
                            value: s,
                            loc: a
                        };
                        return n && (o.loc = null), r.set(e1, o), o;
                    }) : e1;
                }
            },
            9381: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1) {
                    return (0, r.default)(e1, !1, !0);
                };
                var r = n(2419);
            },
            109: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t, n, i) {
                    return (0, r.default)(e1, t, [
                        {
                            type: i ? "CommentLine" : "CommentBlock",
                            value: n
                        }
                    ]);
                };
                var r = n(8647);
            },
            8647: (e1, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t, n) {
                    if (!n || !e1) return e1;
                    const r = `${t}Comments`;
                    return e1[r] ? "leading" === t ? e1[r] = n.concat(e1[r]) : e1[r].push(...n) : e1[r] = n, e1;
                };
            },
            2823: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t) {
                    (0, r.default)("innerComments", e1, t);
                };
                var r = n(9906);
            },
            8930: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t) {
                    (0, r.default)("leadingComments", e1, t);
                };
                var r = n(9906);
            },
            2714: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t) {
                    (0, r.default)("trailingComments", e1, t);
                };
                var r = n(9906);
            },
            9134: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t) {
                    return (0, r.default)(e1, t), (0, i.default)(e1, t), (0, s.default)(e1, t), e1;
                };
                var r = n(2714), i = n(8930), s = n(2823);
            },
            698: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1) {
                    return r.COMMENT_KEYS.forEach((t)=>{
                        e1[t] = null;
                    }), e1;
                };
                var r = n(3725);
            },
            4998: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.WHILE_TYPES = t.USERWHITESPACABLE_TYPES = t.UNARYLIKE_TYPES = t.TYPESCRIPT_TYPES = t.TSTYPE_TYPES = t.TSTYPEELEMENT_TYPES = t.TSENTITYNAME_TYPES = t.TSBASETYPE_TYPES = t.TERMINATORLESS_TYPES = t.STATEMENT_TYPES = t.STANDARDIZED_TYPES = t.SCOPABLE_TYPES = t.PUREISH_TYPES = t.PROPERTY_TYPES = t.PRIVATE_TYPES = t.PATTERN_TYPES = t.PATTERNLIKE_TYPES = t.OBJECTMEMBER_TYPES = t.MODULESPECIFIER_TYPES = t.MODULEDECLARATION_TYPES = t.MISCELLANEOUS_TYPES = t.METHOD_TYPES = t.LVAL_TYPES = t.LOOP_TYPES = t.LITERAL_TYPES = t.JSX_TYPES = t.IMPORTOREXPORTDECLARATION_TYPES = t.IMMUTABLE_TYPES = t.FUNCTION_TYPES = t.FUNCTIONPARENT_TYPES = t.FOR_TYPES = t.FORXSTATEMENT_TYPES = t.FLOW_TYPES = t.FLOWTYPE_TYPES = t.FLOWPREDICATE_TYPES = t.FLOWDECLARATION_TYPES = t.FLOWBASEANNOTATION_TYPES = t.EXPRESSION_TYPES = t.EXPRESSIONWRAPPER_TYPES = t.EXPORTDECLARATION_TYPES = t.ENUMMEMBER_TYPES = t.ENUMBODY_TYPES = t.DECLARATION_TYPES = t.CONDITIONAL_TYPES = t.COMPLETIONSTATEMENT_TYPES = t.CLASS_TYPES = t.BLOCK_TYPES = t.BLOCKPARENT_TYPES = t.BINARY_TYPES = t.ACCESSOR_TYPES = void 0;
                var r = n(1678);
                const i = r.FLIPPED_ALIAS_KEYS.Standardized;
                t.STANDARDIZED_TYPES = i;
                const s = r.FLIPPED_ALIAS_KEYS.Expression;
                t.EXPRESSION_TYPES = s;
                const a = r.FLIPPED_ALIAS_KEYS.Binary;
                t.BINARY_TYPES = a;
                const o = r.FLIPPED_ALIAS_KEYS.Scopable;
                t.SCOPABLE_TYPES = o;
                const l = r.FLIPPED_ALIAS_KEYS.BlockParent;
                t.BLOCKPARENT_TYPES = l;
                const c = r.FLIPPED_ALIAS_KEYS.Block;
                t.BLOCK_TYPES = c;
                const u = r.FLIPPED_ALIAS_KEYS.Statement;
                t.STATEMENT_TYPES = u;
                const p = r.FLIPPED_ALIAS_KEYS.Terminatorless;
                t.TERMINATORLESS_TYPES = p;
                const h = r.FLIPPED_ALIAS_KEYS.CompletionStatement;
                t.COMPLETIONSTATEMENT_TYPES = h;
                const d = r.FLIPPED_ALIAS_KEYS.Conditional;
                t.CONDITIONAL_TYPES = d;
                const f = r.FLIPPED_ALIAS_KEYS.Loop;
                t.LOOP_TYPES = f;
                const y = r.FLIPPED_ALIAS_KEYS.While;
                t.WHILE_TYPES = y;
                const m = r.FLIPPED_ALIAS_KEYS.ExpressionWrapper;
                t.EXPRESSIONWRAPPER_TYPES = m;
                const T = r.FLIPPED_ALIAS_KEYS.For;
                t.FOR_TYPES = T;
                const g = r.FLIPPED_ALIAS_KEYS.ForXStatement;
                t.FORXSTATEMENT_TYPES = g;
                const b = r.FLIPPED_ALIAS_KEYS.Function;
                t.FUNCTION_TYPES = b;
                const E = r.FLIPPED_ALIAS_KEYS.FunctionParent;
                t.FUNCTIONPARENT_TYPES = E;
                const S = r.FLIPPED_ALIAS_KEYS.Pureish;
                t.PUREISH_TYPES = S;
                const P = r.FLIPPED_ALIAS_KEYS.Declaration;
                t.DECLARATION_TYPES = P;
                const x = r.FLIPPED_ALIAS_KEYS.PatternLike;
                t.PATTERNLIKE_TYPES = x;
                const D = r.FLIPPED_ALIAS_KEYS.LVal;
                t.LVAL_TYPES = D;
                const A = r.FLIPPED_ALIAS_KEYS.TSEntityName;
                t.TSENTITYNAME_TYPES = A;
                const v = r.FLIPPED_ALIAS_KEYS.Literal;
                t.LITERAL_TYPES = v;
                const C = r.FLIPPED_ALIAS_KEYS.Immutable;
                t.IMMUTABLE_TYPES = C;
                const w = r.FLIPPED_ALIAS_KEYS.UserWhitespacable;
                t.USERWHITESPACABLE_TYPES = w;
                const O = r.FLIPPED_ALIAS_KEYS.Method;
                t.METHOD_TYPES = O;
                const I = r.FLIPPED_ALIAS_KEYS.ObjectMember;
                t.OBJECTMEMBER_TYPES = I;
                const N = r.FLIPPED_ALIAS_KEYS.Property;
                t.PROPERTY_TYPES = N;
                const F = r.FLIPPED_ALIAS_KEYS.UnaryLike;
                t.UNARYLIKE_TYPES = F;
                const k = r.FLIPPED_ALIAS_KEYS.Pattern;
                t.PATTERN_TYPES = k;
                const L = r.FLIPPED_ALIAS_KEYS.Class;
                t.CLASS_TYPES = L;
                const _ = r.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration;
                t.IMPORTOREXPORTDECLARATION_TYPES = _;
                const M = r.FLIPPED_ALIAS_KEYS.ExportDeclaration;
                t.EXPORTDECLARATION_TYPES = M;
                const B = r.FLIPPED_ALIAS_KEYS.ModuleSpecifier;
                t.MODULESPECIFIER_TYPES = B;
                const j = r.FLIPPED_ALIAS_KEYS.Accessor;
                t.ACCESSOR_TYPES = j;
                const R = r.FLIPPED_ALIAS_KEYS.Private;
                t.PRIVATE_TYPES = R;
                const U = r.FLIPPED_ALIAS_KEYS.Flow;
                t.FLOW_TYPES = U;
                const V = r.FLIPPED_ALIAS_KEYS.FlowType;
                t.FLOWTYPE_TYPES = V;
                const K = r.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation;
                t.FLOWBASEANNOTATION_TYPES = K;
                const W = r.FLIPPED_ALIAS_KEYS.FlowDeclaration;
                t.FLOWDECLARATION_TYPES = W;
                const X = r.FLIPPED_ALIAS_KEYS.FlowPredicate;
                t.FLOWPREDICATE_TYPES = X;
                const Y = r.FLIPPED_ALIAS_KEYS.EnumBody;
                t.ENUMBODY_TYPES = Y;
                const q = r.FLIPPED_ALIAS_KEYS.EnumMember;
                t.ENUMMEMBER_TYPES = q;
                const H = r.FLIPPED_ALIAS_KEYS.JSX;
                t.JSX_TYPES = H;
                const J = r.FLIPPED_ALIAS_KEYS.Miscellaneous;
                t.MISCELLANEOUS_TYPES = J;
                const $ = r.FLIPPED_ALIAS_KEYS.TypeScript;
                t.TYPESCRIPT_TYPES = $;
                const G = r.FLIPPED_ALIAS_KEYS.TSTypeElement;
                t.TSTYPEELEMENT_TYPES = G;
                const z = r.FLIPPED_ALIAS_KEYS.TSType;
                t.TSTYPE_TYPES = z;
                const Q = r.FLIPPED_ALIAS_KEYS.TSBaseType;
                t.TSBASETYPE_TYPES = Q;
                const Z = _;
                t.MODULEDECLARATION_TYPES = Z;
            },
            3725: (e1, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.UPDATE_OPERATORS = t.UNARY_OPERATORS = t.STRING_UNARY_OPERATORS = t.STATEMENT_OR_BLOCK_KEYS = t.NUMBER_UNARY_OPERATORS = t.NUMBER_BINARY_OPERATORS = t.NOT_LOCAL_BINDING = t.LOGICAL_OPERATORS = t.INHERIT_KEYS = t.FOR_INIT_KEYS = t.FLATTENABLE_KEYS = t.EQUALITY_BINARY_OPERATORS = t.COMPARISON_BINARY_OPERATORS = t.COMMENT_KEYS = t.BOOLEAN_UNARY_OPERATORS = t.BOOLEAN_NUMBER_BINARY_OPERATORS = t.BOOLEAN_BINARY_OPERATORS = t.BLOCK_SCOPED_SYMBOL = t.BINARY_OPERATORS = t.ASSIGNMENT_OPERATORS = void 0, t.STATEMENT_OR_BLOCK_KEYS = [
                    "consequent",
                    "body",
                    "alternate"
                ], t.FLATTENABLE_KEYS = [
                    "body",
                    "expressions"
                ], t.FOR_INIT_KEYS = [
                    "left",
                    "init"
                ], t.COMMENT_KEYS = [
                    "leadingComments",
                    "trailingComments",
                    "innerComments"
                ];
                const n = [
                    "||",
                    "&&",
                    "??"
                ];
                t.LOGICAL_OPERATORS = n, t.UPDATE_OPERATORS = [
                    "++",
                    "--"
                ];
                const r = [
                    ">",
                    "<",
                    ">=",
                    "<="
                ];
                t.BOOLEAN_NUMBER_BINARY_OPERATORS = r;
                const i = [
                    "==",
                    "===",
                    "!=",
                    "!=="
                ];
                t.EQUALITY_BINARY_OPERATORS = i;
                const s = [
                    ...i,
                    "in",
                    "instanceof"
                ];
                t.COMPARISON_BINARY_OPERATORS = s;
                const a = [
                    ...s,
                    ...r
                ];
                t.BOOLEAN_BINARY_OPERATORS = a;
                const o = [
                    "-",
                    "/",
                    "%",
                    "*",
                    "**",
                    "&",
                    "|",
                    ">>",
                    ">>>",
                    "<<",
                    "^"
                ];
                t.NUMBER_BINARY_OPERATORS = o;
                const l = [
                    "+",
                    ...o,
                    ...a,
                    "|>"
                ];
                t.BINARY_OPERATORS = l;
                const c = [
                    "=",
                    "+=",
                    ...o.map((e1)=>e1 + "="),
                    ...n.map((e1)=>e1 + "=")
                ];
                t.ASSIGNMENT_OPERATORS = c;
                const u = [
                    "delete",
                    "!"
                ];
                t.BOOLEAN_UNARY_OPERATORS = u;
                const p = [
                    "+",
                    "-",
                    "~"
                ];
                t.NUMBER_UNARY_OPERATORS = p;
                const h = [
                    "typeof"
                ];
                t.STRING_UNARY_OPERATORS = h;
                const d = [
                    "void",
                    "throw",
                    ...u,
                    ...p,
                    ...h
                ];
                t.UNARY_OPERATORS = d, t.INHERIT_KEYS = {
                    optional: [
                        "typeAnnotation",
                        "typeParameters",
                        "returnType"
                    ],
                    force: [
                        "start",
                        "loc",
                        "end"
                    ]
                };
                const f = Symbol.for("var used to be block scoped");
                t.BLOCK_SCOPED_SYMBOL = f;
                const y = Symbol.for("should not be considered a local binding");
                t.NOT_LOCAL_BINDING = y;
            },
            8560: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t = "body") {
                    const n = (0, r.default)(e1[t], e1);
                    return e1[t] = n, n;
                };
                var r = n(9988);
            },
            3556: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function e1(t, n, o) {
                    const l = [];
                    let c = !0;
                    for (const u of t)if ((0, i.isEmptyStatement)(u) || (c = !1), (0, i.isExpression)(u)) l.push(u);
                    else if ((0, i.isExpressionStatement)(u)) l.push(u.expression);
                    else if ((0, i.isVariableDeclaration)(u)) {
                        if ("var" !== u.kind) return;
                        for (const e1 of u.declarations){
                            const t = (0, r.default)(e1);
                            for (const e1 of Object.keys(t))o.push({
                                kind: u.kind,
                                id: (0, a.default)(t[e1])
                            });
                            e1.init && l.push((0, s.assignmentExpression)("=", e1.id, e1.init));
                        }
                        c = !0;
                    } else if ((0, i.isIfStatement)(u)) {
                        const t = u.consequent ? e1([
                            u.consequent
                        ], n, o) : n.buildUndefinedNode(), r = u.alternate ? e1([
                            u.alternate
                        ], n, o) : n.buildUndefinedNode();
                        if (!t || !r) return;
                        l.push((0, s.conditionalExpression)(u.test, t, r));
                    } else if ((0, i.isBlockStatement)(u)) {
                        const t = e1(u.body, n, o);
                        if (!t) return;
                        l.push(t);
                    } else {
                        if (!(0, i.isEmptyStatement)(u)) return;
                        0 === t.indexOf(u) && (c = !0);
                    }
                    return c && l.push(n.buildUndefinedNode()), 1 === l.length ? l[0] : (0, s.sequenceExpression)(l);
                };
                var r = n(984), i = n(9869), s = n(1411), a = n(2419);
            },
            5200: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1) {
                    return "eval" !== (e1 = (0, r.default)(e1)) && "arguments" !== e1 || (e1 = "_" + e1), e1;
                };
                var r = n(7885);
            },
            9988: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t) {
                    if ((0, r.isBlockStatement)(e1)) return e1;
                    let n = [];
                    return (0, r.isEmptyStatement)(e1) ? n = [] : ((0, r.isStatement)(e1) || (e1 = (0, r.isFunction)(t) ? (0, i.returnStatement)(e1) : (0, i.expressionStatement)(e1)), n = [
                        e1
                    ]), (0, i.blockStatement)(n);
                };
                var r = n(9869), i = n(1411);
            },
            3816: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t = e1.key || e1.property) {
                    return !e1.computed && (0, r.isIdentifier)(t) && (t = (0, i.stringLiteral)(t.name)), t;
                };
                var r = n(9869), i = n(1411);
            },
            5317: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var r = n(9869);
                t.default = function(e1) {
                    if ((0, r.isExpressionStatement)(e1) && (e1 = e1.expression), (0, r.isExpression)(e1)) return e1;
                    if ((0, r.isClass)(e1) ? e1.type = "ClassExpression" : (0, r.isFunction)(e1) && (e1.type = "FunctionExpression"), !(0, r.isExpression)(e1)) throw new Error(`cannot turn ${e1.type} to an expression`);
                    return e1;
                };
            },
            7885: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1) {
                    e1 += "";
                    let t = "";
                    for (const n of e1)t += (0, i.isIdentifierChar)(n.codePointAt(0)) ? n : "-";
                    return t = t.replace(/^[-0-9]+/, ""), t = t.replace(/[-\s]+(.)?/g, function(e1, t) {
                        return t ? t.toUpperCase() : "";
                    }), (0, r.default)(t) || (t = `_${t}`), t || "_";
                };
                var r = n(5820), i = n(9649);
            },
            5046: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = a;
                var r = n(9869), i = n(2419), s = n(857);
                function a(e1, t = e1.key) {
                    let n;
                    return "method" === e1.kind ? a.increment() + "" : (n = (0, r.isIdentifier)(t) ? t.name : (0, r.isStringLiteral)(t) ? JSON.stringify(t.value) : JSON.stringify((0, s.default)((0, i.default)(t))), e1.computed && (n = `[${n}]`), e1.static && (n = `static:${n}`), n);
                }
                a.uid = 0, a.increment = function() {
                    return a.uid >= Number.MAX_SAFE_INTEGER ? a.uid = 0 : a.uid++;
                };
            },
            2473: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t) {
                    if (null == e1 || !e1.length) return;
                    const n = [], i = (0, r.default)(e1, t, n);
                    if (i) {
                        for (const e1 of n)t.push(e1);
                        return i;
                    }
                };
                var r = n(3556);
            },
            350: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var r = n(9869), i = n(1411);
                t.default = function(e1, t) {
                    if ((0, r.isStatement)(e1)) return e1;
                    let n, s = !1;
                    if ((0, r.isClass)(e1)) s = !0, n = "ClassDeclaration";
                    else if ((0, r.isFunction)(e1)) s = !0, n = "FunctionDeclaration";
                    else if ((0, r.isAssignmentExpression)(e1)) return (0, i.expressionStatement)(e1);
                    if (s && !e1.id && (n = !1), !n) {
                        if (t) return !1;
                        throw new Error(`cannot turn ${e1.type} to a statement`);
                    }
                    return e1.type = n, e1;
                };
            },
            1382: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var r = n(5820), i = n(1411);
                t.default = function e1(t) {
                    if (void 0 === t) return (0, i.identifier)("undefined");
                    if (!0 === t || !1 === t) return (0, i.booleanLiteral)(t);
                    if (null === t) return (0, i.nullLiteral)();
                    if ("string" == typeof t) return (0, i.stringLiteral)(t);
                    if ("number" == typeof t) {
                        let e1;
                        if (Number.isFinite(t)) e1 = (0, i.numericLiteral)(Math.abs(t));
                        else {
                            let n;
                            n = Number.isNaN(t) ? (0, i.numericLiteral)(0) : (0, i.numericLiteral)(1), e1 = (0, i.binaryExpression)("/", n, (0, i.numericLiteral)(0));
                        }
                        return (t < 0 || Object.is(t, -0)) && (e1 = (0, i.unaryExpression)("-", e1)), e1;
                    }
                    if (function(e1) {
                        return "[object RegExp]" === s(e1);
                    }(t)) {
                        const e1 = t.source, n = t.toString().match(/\/([a-z]+|)$/)[1];
                        return (0, i.regExpLiteral)(e1, n);
                    }
                    if (Array.isArray(t)) return (0, i.arrayExpression)(t.map(e1));
                    if (function(e1) {
                        if ("object" != typeof e1 || null === e1 || "[object Object]" !== Object.prototype.toString.call(e1)) return !1;
                        const t = Object.getPrototypeOf(e1);
                        return null === t || null === Object.getPrototypeOf(t);
                    }(t)) {
                        const n = [];
                        for (const s of Object.keys(t)){
                            let a;
                            a = (0, r.default)(s) ? (0, i.identifier)(s) : (0, i.stringLiteral)(s), n.push((0, i.objectProperty)(a, e1(t[s])));
                        }
                        return (0, i.objectExpression)(n);
                    }
                    throw new Error("don't know how to turn this value into a node");
                };
                const s = Function.call.bind(Object.prototype.toString);
            },
            8248: (e1, t, n)=>{
                "use strict";
                var r = n(4155);
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.patternLikeCommon = t.functionTypeAnnotationCommon = t.functionDeclarationCommon = t.functionCommon = t.classMethodOrPropertyCommon = t.classMethodOrDeclareMethodCommon = void 0;
                var i = n(5171), s = n(5820), a = n(9649), o = n(7648), l = n(3725), c = n(1514);
                const u = (0, c.defineAliasedType)("Standardized");
                u("ArrayExpression", {
                    fields: {
                        elements: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
                            default: r.env.BABEL_TYPES_8_BREAKING ? void 0 : []
                        }
                    },
                    visitor: [
                        "elements"
                    ],
                    aliases: [
                        "Expression"
                    ]
                }), u("AssignmentExpression", {
                    fields: {
                        operator: {
                            validate: function() {
                                if (!r.env.BABEL_TYPES_8_BREAKING) return (0, c.assertValueType)("string");
                                const e1 = (0, c.assertOneOf)(...l.ASSIGNMENT_OPERATORS), t = (0, c.assertOneOf)("=");
                                return function(n, r, s) {
                                    ((0, i.default)("Pattern", n.left) ? t : e1)(n, r, s);
                                };
                            }()
                        },
                        left: {
                            validate: r.env.BABEL_TYPES_8_BREAKING ? (0, c.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, c.assertNodeType)("LVal")
                        },
                        right: {
                            validate: (0, c.assertNodeType)("Expression")
                        }
                    },
                    builder: [
                        "operator",
                        "left",
                        "right"
                    ],
                    visitor: [
                        "left",
                        "right"
                    ],
                    aliases: [
                        "Expression"
                    ]
                }), u("BinaryExpression", {
                    builder: [
                        "operator",
                        "left",
                        "right"
                    ],
                    fields: {
                        operator: {
                            validate: (0, c.assertOneOf)(...l.BINARY_OPERATORS)
                        },
                        left: {
                            validate: function() {
                                const e1 = (0, c.assertNodeType)("Expression"), t = (0, c.assertNodeType)("Expression", "PrivateName");
                                return Object.assign(function(n, r, i) {
                                    ("in" === n.operator ? t : e1)(n, r, i);
                                }, {
                                    oneOfNodeTypes: [
                                        "Expression",
                                        "PrivateName"
                                    ]
                                });
                            }()
                        },
                        right: {
                            validate: (0, c.assertNodeType)("Expression")
                        }
                    },
                    visitor: [
                        "left",
                        "right"
                    ],
                    aliases: [
                        "Binary",
                        "Expression"
                    ]
                }), u("InterpreterDirective", {
                    builder: [
                        "value"
                    ],
                    fields: {
                        value: {
                            validate: (0, c.assertValueType)("string")
                        }
                    }
                }), u("Directive", {
                    visitor: [
                        "value"
                    ],
                    fields: {
                        value: {
                            validate: (0, c.assertNodeType)("DirectiveLiteral")
                        }
                    }
                }), u("DirectiveLiteral", {
                    builder: [
                        "value"
                    ],
                    fields: {
                        value: {
                            validate: (0, c.assertValueType)("string")
                        }
                    }
                }), u("BlockStatement", {
                    builder: [
                        "body",
                        "directives"
                    ],
                    visitor: [
                        "directives",
                        "body"
                    ],
                    fields: {
                        directives: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Directive"))),
                            default: []
                        },
                        body: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Statement")))
                        }
                    },
                    aliases: [
                        "Scopable",
                        "BlockParent",
                        "Block",
                        "Statement"
                    ]
                }), u("BreakStatement", {
                    visitor: [
                        "label"
                    ],
                    fields: {
                        label: {
                            validate: (0, c.assertNodeType)("Identifier"),
                            optional: !0
                        }
                    },
                    aliases: [
                        "Statement",
                        "Terminatorless",
                        "CompletionStatement"
                    ]
                }), u("CallExpression", {
                    visitor: [
                        "callee",
                        "arguments",
                        "typeParameters",
                        "typeArguments"
                    ],
                    builder: [
                        "callee",
                        "arguments"
                    ],
                    aliases: [
                        "Expression"
                    ],
                    fields: Object.assign({
                        callee: {
                            validate: (0, c.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
                        },
                        arguments: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
                        }
                    }, r.env.BABEL_TYPES_8_BREAKING ? {} : {
                        optional: {
                            validate: (0, c.assertOneOf)(!0, !1),
                            optional: !0
                        }
                    }, {
                        typeArguments: {
                            validate: (0, c.assertNodeType)("TypeParameterInstantiation"),
                            optional: !0
                        },
                        typeParameters: {
                            validate: (0, c.assertNodeType)("TSTypeParameterInstantiation"),
                            optional: !0
                        }
                    })
                }), u("CatchClause", {
                    visitor: [
                        "param",
                        "body"
                    ],
                    fields: {
                        param: {
                            validate: (0, c.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
                            optional: !0
                        },
                        body: {
                            validate: (0, c.assertNodeType)("BlockStatement")
                        }
                    },
                    aliases: [
                        "Scopable",
                        "BlockParent"
                    ]
                }), u("ConditionalExpression", {
                    visitor: [
                        "test",
                        "consequent",
                        "alternate"
                    ],
                    fields: {
                        test: {
                            validate: (0, c.assertNodeType)("Expression")
                        },
                        consequent: {
                            validate: (0, c.assertNodeType)("Expression")
                        },
                        alternate: {
                            validate: (0, c.assertNodeType)("Expression")
                        }
                    },
                    aliases: [
                        "Expression",
                        "Conditional"
                    ]
                }), u("ContinueStatement", {
                    visitor: [
                        "label"
                    ],
                    fields: {
                        label: {
                            validate: (0, c.assertNodeType)("Identifier"),
                            optional: !0
                        }
                    },
                    aliases: [
                        "Statement",
                        "Terminatorless",
                        "CompletionStatement"
                    ]
                }), u("DebuggerStatement", {
                    aliases: [
                        "Statement"
                    ]
                }), u("DoWhileStatement", {
                    visitor: [
                        "test",
                        "body"
                    ],
                    fields: {
                        test: {
                            validate: (0, c.assertNodeType)("Expression")
                        },
                        body: {
                            validate: (0, c.assertNodeType)("Statement")
                        }
                    },
                    aliases: [
                        "Statement",
                        "BlockParent",
                        "Loop",
                        "While",
                        "Scopable"
                    ]
                }), u("EmptyStatement", {
                    aliases: [
                        "Statement"
                    ]
                }), u("ExpressionStatement", {
                    visitor: [
                        "expression"
                    ],
                    fields: {
                        expression: {
                            validate: (0, c.assertNodeType)("Expression")
                        }
                    },
                    aliases: [
                        "Statement",
                        "ExpressionWrapper"
                    ]
                }), u("File", {
                    builder: [
                        "program",
                        "comments",
                        "tokens"
                    ],
                    visitor: [
                        "program"
                    ],
                    fields: {
                        program: {
                            validate: (0, c.assertNodeType)("Program")
                        },
                        comments: {
                            validate: r.env.BABEL_TYPES_8_BREAKING ? (0, c.assertEach)((0, c.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(()=>{}, {
                                each: {
                                    oneOfNodeTypes: [
                                        "CommentBlock",
                                        "CommentLine"
                                    ]
                                }
                            }),
                            optional: !0
                        },
                        tokens: {
                            validate: (0, c.assertEach)(Object.assign(()=>{}, {
                                type: "any"
                            })),
                            optional: !0
                        }
                    }
                }), u("ForInStatement", {
                    visitor: [
                        "left",
                        "right",
                        "body"
                    ],
                    aliases: [
                        "Scopable",
                        "Statement",
                        "For",
                        "BlockParent",
                        "Loop",
                        "ForXStatement"
                    ],
                    fields: {
                        left: {
                            validate: r.env.BABEL_TYPES_8_BREAKING ? (0, c.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, c.assertNodeType)("VariableDeclaration", "LVal")
                        },
                        right: {
                            validate: (0, c.assertNodeType)("Expression")
                        },
                        body: {
                            validate: (0, c.assertNodeType)("Statement")
                        }
                    }
                }), u("ForStatement", {
                    visitor: [
                        "init",
                        "test",
                        "update",
                        "body"
                    ],
                    aliases: [
                        "Scopable",
                        "Statement",
                        "For",
                        "BlockParent",
                        "Loop"
                    ],
                    fields: {
                        init: {
                            validate: (0, c.assertNodeType)("VariableDeclaration", "Expression"),
                            optional: !0
                        },
                        test: {
                            validate: (0, c.assertNodeType)("Expression"),
                            optional: !0
                        },
                        update: {
                            validate: (0, c.assertNodeType)("Expression"),
                            optional: !0
                        },
                        body: {
                            validate: (0, c.assertNodeType)("Statement")
                        }
                    }
                });
                const p = ()=>({
                        params: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Identifier", "Pattern", "RestElement")))
                        },
                        generator: {
                            default: !1
                        },
                        async: {
                            default: !1
                        }
                    });
                t.functionCommon = p;
                const h = ()=>({
                        returnType: {
                            validate: (0, c.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                            optional: !0
                        },
                        typeParameters: {
                            validate: (0, c.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
                            optional: !0
                        }
                    });
                t.functionTypeAnnotationCommon = h;
                const d = ()=>Object.assign({}, p(), {
                        declare: {
                            validate: (0, c.assertValueType)("boolean"),
                            optional: !0
                        },
                        id: {
                            validate: (0, c.assertNodeType)("Identifier"),
                            optional: !0
                        }
                    });
                t.functionDeclarationCommon = d, u("FunctionDeclaration", {
                    builder: [
                        "id",
                        "params",
                        "body",
                        "generator",
                        "async"
                    ],
                    visitor: [
                        "id",
                        "params",
                        "body",
                        "returnType",
                        "typeParameters"
                    ],
                    fields: Object.assign({}, d(), h(), {
                        body: {
                            validate: (0, c.assertNodeType)("BlockStatement")
                        },
                        predicate: {
                            validate: (0, c.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
                            optional: !0
                        }
                    }),
                    aliases: [
                        "Scopable",
                        "Function",
                        "BlockParent",
                        "FunctionParent",
                        "Statement",
                        "Pureish",
                        "Declaration"
                    ],
                    validate: function() {
                        if (!r.env.BABEL_TYPES_8_BREAKING) return ()=>{};
                        const e1 = (0, c.assertNodeType)("Identifier");
                        return function(t, n, r) {
                            (0, i.default)("ExportDefaultDeclaration", t) || e1(r, "id", r.id);
                        };
                    }()
                }), u("FunctionExpression", {
                    inherits: "FunctionDeclaration",
                    aliases: [
                        "Scopable",
                        "Function",
                        "BlockParent",
                        "FunctionParent",
                        "Expression",
                        "Pureish"
                    ],
                    fields: Object.assign({}, p(), h(), {
                        id: {
                            validate: (0, c.assertNodeType)("Identifier"),
                            optional: !0
                        },
                        body: {
                            validate: (0, c.assertNodeType)("BlockStatement")
                        },
                        predicate: {
                            validate: (0, c.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
                            optional: !0
                        }
                    })
                });
                const f = ()=>({
                        typeAnnotation: {
                            validate: (0, c.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                            optional: !0
                        },
                        optional: {
                            validate: (0, c.assertValueType)("boolean"),
                            optional: !0
                        },
                        decorators: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Decorator"))),
                            optional: !0
                        }
                    });
                t.patternLikeCommon = f, u("Identifier", {
                    builder: [
                        "name"
                    ],
                    visitor: [
                        "typeAnnotation",
                        "decorators"
                    ],
                    aliases: [
                        "Expression",
                        "PatternLike",
                        "LVal",
                        "TSEntityName"
                    ],
                    fields: Object.assign({}, f(), {
                        name: {
                            validate: (0, c.chain)((0, c.assertValueType)("string"), Object.assign(function(e1, t, n) {
                                if (r.env.BABEL_TYPES_8_BREAKING && !(0, s.default)(n, !1)) throw new TypeError(`"${n}" is not a valid identifier name`);
                            }, {
                                type: "string"
                            }))
                        }
                    }),
                    validate (e1, t, n) {
                        if (!r.env.BABEL_TYPES_8_BREAKING) return;
                        const s = /\.(\w+)$/.exec(t);
                        if (!s) return;
                        const [, o] = s, l = {
                            computed: !1
                        };
                        if ("property" === o) {
                            if ((0, i.default)("MemberExpression", e1, l)) return;
                            if ((0, i.default)("OptionalMemberExpression", e1, l)) return;
                        } else if ("key" === o) {
                            if ((0, i.default)("Property", e1, l)) return;
                            if ((0, i.default)("Method", e1, l)) return;
                        } else if ("exported" === o) {
                            if ((0, i.default)("ExportSpecifier", e1)) return;
                        } else if ("imported" === o) {
                            if ((0, i.default)("ImportSpecifier", e1, {
                                imported: n
                            })) return;
                        } else if ("meta" === o && (0, i.default)("MetaProperty", e1, {
                            meta: n
                        })) return;
                        if (((0, a.isKeyword)(n.name) || (0, a.isReservedWord)(n.name, !1)) && "this" !== n.name) throw new TypeError(`"${n.name}" is not a valid identifier`);
                    }
                }), u("IfStatement", {
                    visitor: [
                        "test",
                        "consequent",
                        "alternate"
                    ],
                    aliases: [
                        "Statement",
                        "Conditional"
                    ],
                    fields: {
                        test: {
                            validate: (0, c.assertNodeType)("Expression")
                        },
                        consequent: {
                            validate: (0, c.assertNodeType)("Statement")
                        },
                        alternate: {
                            optional: !0,
                            validate: (0, c.assertNodeType)("Statement")
                        }
                    }
                }), u("LabeledStatement", {
                    visitor: [
                        "label",
                        "body"
                    ],
                    aliases: [
                        "Statement"
                    ],
                    fields: {
                        label: {
                            validate: (0, c.assertNodeType)("Identifier")
                        },
                        body: {
                            validate: (0, c.assertNodeType)("Statement")
                        }
                    }
                }), u("StringLiteral", {
                    builder: [
                        "value"
                    ],
                    fields: {
                        value: {
                            validate: (0, c.assertValueType)("string")
                        }
                    },
                    aliases: [
                        "Expression",
                        "Pureish",
                        "Literal",
                        "Immutable"
                    ]
                }), u("NumericLiteral", {
                    builder: [
                        "value"
                    ],
                    deprecatedAlias: "NumberLiteral",
                    fields: {
                        value: {
                            validate: (0, c.chain)((0, c.assertValueType)("number"), Object.assign(function(e1, t, n) {
                                (1 / n < 0 || !Number.isFinite(n)) && new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${n}) instead.`);
                            }, {
                                type: "number"
                            }))
                        }
                    },
                    aliases: [
                        "Expression",
                        "Pureish",
                        "Literal",
                        "Immutable"
                    ]
                }), u("NullLiteral", {
                    aliases: [
                        "Expression",
                        "Pureish",
                        "Literal",
                        "Immutable"
                    ]
                }), u("BooleanLiteral", {
                    builder: [
                        "value"
                    ],
                    fields: {
                        value: {
                            validate: (0, c.assertValueType)("boolean")
                        }
                    },
                    aliases: [
                        "Expression",
                        "Pureish",
                        "Literal",
                        "Immutable"
                    ]
                }), u("RegExpLiteral", {
                    builder: [
                        "pattern",
                        "flags"
                    ],
                    deprecatedAlias: "RegexLiteral",
                    aliases: [
                        "Expression",
                        "Pureish",
                        "Literal"
                    ],
                    fields: {
                        pattern: {
                            validate: (0, c.assertValueType)("string")
                        },
                        flags: {
                            validate: (0, c.chain)((0, c.assertValueType)("string"), Object.assign(function(e1, t, n) {
                                if (!r.env.BABEL_TYPES_8_BREAKING) return;
                                const i = /[^gimsuy]/.exec(n);
                                if (i) throw new TypeError(`"${i[0]}" is not a valid RegExp flag`);
                            }, {
                                type: "string"
                            })),
                            default: ""
                        }
                    }
                }), u("LogicalExpression", {
                    builder: [
                        "operator",
                        "left",
                        "right"
                    ],
                    visitor: [
                        "left",
                        "right"
                    ],
                    aliases: [
                        "Binary",
                        "Expression"
                    ],
                    fields: {
                        operator: {
                            validate: (0, c.assertOneOf)(...l.LOGICAL_OPERATORS)
                        },
                        left: {
                            validate: (0, c.assertNodeType)("Expression")
                        },
                        right: {
                            validate: (0, c.assertNodeType)("Expression")
                        }
                    }
                }), u("MemberExpression", {
                    builder: [
                        "object",
                        "property",
                        "computed",
                        ...r.env.BABEL_TYPES_8_BREAKING ? [] : [
                            "optional"
                        ]
                    ],
                    visitor: [
                        "object",
                        "property"
                    ],
                    aliases: [
                        "Expression",
                        "LVal"
                    ],
                    fields: Object.assign({
                        object: {
                            validate: (0, c.assertNodeType)("Expression", "Super")
                        },
                        property: {
                            validate: function() {
                                const e1 = (0, c.assertNodeType)("Identifier", "PrivateName"), t = (0, c.assertNodeType)("Expression"), n = function(n, r, i) {
                                    (n.computed ? t : e1)(n, r, i);
                                };
                                return n.oneOfNodeTypes = [
                                    "Expression",
                                    "Identifier",
                                    "PrivateName"
                                ], n;
                            }()
                        },
                        computed: {
                            default: !1
                        }
                    }, r.env.BABEL_TYPES_8_BREAKING ? {} : {
                        optional: {
                            validate: (0, c.assertOneOf)(!0, !1),
                            optional: !0
                        }
                    })
                }), u("NewExpression", {
                    inherits: "CallExpression"
                }), u("Program", {
                    visitor: [
                        "directives",
                        "body"
                    ],
                    builder: [
                        "body",
                        "directives",
                        "sourceType",
                        "interpreter"
                    ],
                    fields: {
                        sourceFile: {
                            validate: (0, c.assertValueType)("string")
                        },
                        sourceType: {
                            validate: (0, c.assertOneOf)("script", "module"),
                            default: "script"
                        },
                        interpreter: {
                            validate: (0, c.assertNodeType)("InterpreterDirective"),
                            default: null,
                            optional: !0
                        },
                        directives: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Directive"))),
                            default: []
                        },
                        body: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Statement")))
                        }
                    },
                    aliases: [
                        "Scopable",
                        "BlockParent",
                        "Block"
                    ]
                }), u("ObjectExpression", {
                    visitor: [
                        "properties"
                    ],
                    aliases: [
                        "Expression"
                    ],
                    fields: {
                        properties: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
                        }
                    }
                }), u("ObjectMethod", {
                    builder: [
                        "kind",
                        "key",
                        "params",
                        "body",
                        "computed",
                        "generator",
                        "async"
                    ],
                    fields: Object.assign({}, p(), h(), {
                        kind: Object.assign({
                            validate: (0, c.assertOneOf)("method", "get", "set")
                        }, r.env.BABEL_TYPES_8_BREAKING ? {} : {
                            default: "method"
                        }),
                        computed: {
                            default: !1
                        },
                        key: {
                            validate: function() {
                                const e1 = (0, c.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), t = (0, c.assertNodeType)("Expression"), n = function(n, r, i) {
                                    (n.computed ? t : e1)(n, r, i);
                                };
                                return n.oneOfNodeTypes = [
                                    "Expression",
                                    "Identifier",
                                    "StringLiteral",
                                    "NumericLiteral",
                                    "BigIntLiteral"
                                ], n;
                            }()
                        },
                        decorators: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Decorator"))),
                            optional: !0
                        },
                        body: {
                            validate: (0, c.assertNodeType)("BlockStatement")
                        }
                    }),
                    visitor: [
                        "key",
                        "params",
                        "body",
                        "decorators",
                        "returnType",
                        "typeParameters"
                    ],
                    aliases: [
                        "UserWhitespacable",
                        "Function",
                        "Scopable",
                        "BlockParent",
                        "FunctionParent",
                        "Method",
                        "ObjectMember"
                    ]
                }), u("ObjectProperty", {
                    builder: [
                        "key",
                        "value",
                        "computed",
                        "shorthand",
                        ...r.env.BABEL_TYPES_8_BREAKING ? [] : [
                            "decorators"
                        ]
                    ],
                    fields: {
                        computed: {
                            default: !1
                        },
                        key: {
                            validate: function() {
                                const e1 = (0, c.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), t = (0, c.assertNodeType)("Expression");
                                return Object.assign(function(n, r, i) {
                                    (n.computed ? t : e1)(n, r, i);
                                }, {
                                    oneOfNodeTypes: [
                                        "Expression",
                                        "Identifier",
                                        "StringLiteral",
                                        "NumericLiteral",
                                        "BigIntLiteral",
                                        "DecimalLiteral",
                                        "PrivateName"
                                    ]
                                });
                            }()
                        },
                        value: {
                            validate: (0, c.assertNodeType)("Expression", "PatternLike")
                        },
                        shorthand: {
                            validate: (0, c.chain)((0, c.assertValueType)("boolean"), Object.assign(function(e1, t, n) {
                                if (r.env.BABEL_TYPES_8_BREAKING && n && e1.computed) throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
                            }, {
                                type: "boolean"
                            }), function(e1, t, n) {
                                if (r.env.BABEL_TYPES_8_BREAKING && n && !(0, i.default)("Identifier", e1.key)) throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
                            }),
                            default: !1
                        },
                        decorators: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Decorator"))),
                            optional: !0
                        }
                    },
                    visitor: [
                        "key",
                        "value",
                        "decorators"
                    ],
                    aliases: [
                        "UserWhitespacable",
                        "Property",
                        "ObjectMember"
                    ],
                    validate: function() {
                        const e1 = (0, c.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion"), t = (0, c.assertNodeType)("Expression");
                        return function(n, s, a) {
                            r.env.BABEL_TYPES_8_BREAKING && ((0, i.default)("ObjectPattern", n) ? e1 : t)(a, "value", a.value);
                        };
                    }()
                }), u("RestElement", {
                    visitor: [
                        "argument",
                        "typeAnnotation"
                    ],
                    builder: [
                        "argument"
                    ],
                    aliases: [
                        "LVal",
                        "PatternLike"
                    ],
                    deprecatedAlias: "RestProperty",
                    fields: Object.assign({}, f(), {
                        argument: {
                            validate: r.env.BABEL_TYPES_8_BREAKING ? (0, c.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, c.assertNodeType)("LVal")
                        }
                    }),
                    validate (e1, t) {
                        if (!r.env.BABEL_TYPES_8_BREAKING) return;
                        const n = /(\w+)\[(\d+)\]/.exec(t);
                        if (!n) throw new Error("Internal Babel error: malformed key.");
                        const [, i, s] = n;
                        if (e1[i].length > +s + 1) throw new TypeError(`RestElement must be last element of ${i}`);
                    }
                }), u("ReturnStatement", {
                    visitor: [
                        "argument"
                    ],
                    aliases: [
                        "Statement",
                        "Terminatorless",
                        "CompletionStatement"
                    ],
                    fields: {
                        argument: {
                            validate: (0, c.assertNodeType)("Expression"),
                            optional: !0
                        }
                    }
                }), u("SequenceExpression", {
                    visitor: [
                        "expressions"
                    ],
                    fields: {
                        expressions: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Expression")))
                        }
                    },
                    aliases: [
                        "Expression"
                    ]
                }), u("ParenthesizedExpression", {
                    visitor: [
                        "expression"
                    ],
                    aliases: [
                        "Expression",
                        "ExpressionWrapper"
                    ],
                    fields: {
                        expression: {
                            validate: (0, c.assertNodeType)("Expression")
                        }
                    }
                }), u("SwitchCase", {
                    visitor: [
                        "test",
                        "consequent"
                    ],
                    fields: {
                        test: {
                            validate: (0, c.assertNodeType)("Expression"),
                            optional: !0
                        },
                        consequent: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Statement")))
                        }
                    }
                }), u("SwitchStatement", {
                    visitor: [
                        "discriminant",
                        "cases"
                    ],
                    aliases: [
                        "Statement",
                        "BlockParent",
                        "Scopable"
                    ],
                    fields: {
                        discriminant: {
                            validate: (0, c.assertNodeType)("Expression")
                        },
                        cases: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("SwitchCase")))
                        }
                    }
                }), u("ThisExpression", {
                    aliases: [
                        "Expression"
                    ]
                }), u("ThrowStatement", {
                    visitor: [
                        "argument"
                    ],
                    aliases: [
                        "Statement",
                        "Terminatorless",
                        "CompletionStatement"
                    ],
                    fields: {
                        argument: {
                            validate: (0, c.assertNodeType)("Expression")
                        }
                    }
                }), u("TryStatement", {
                    visitor: [
                        "block",
                        "handler",
                        "finalizer"
                    ],
                    aliases: [
                        "Statement"
                    ],
                    fields: {
                        block: {
                            validate: (0, c.chain)((0, c.assertNodeType)("BlockStatement"), Object.assign(function(e1) {
                                if (r.env.BABEL_TYPES_8_BREAKING && !e1.handler && !e1.finalizer) throw new TypeError("TryStatement expects either a handler or finalizer, or both");
                            }, {
                                oneOfNodeTypes: [
                                    "BlockStatement"
                                ]
                            }))
                        },
                        handler: {
                            optional: !0,
                            validate: (0, c.assertNodeType)("CatchClause")
                        },
                        finalizer: {
                            optional: !0,
                            validate: (0, c.assertNodeType)("BlockStatement")
                        }
                    }
                }), u("UnaryExpression", {
                    builder: [
                        "operator",
                        "argument",
                        "prefix"
                    ],
                    fields: {
                        prefix: {
                            default: !0
                        },
                        argument: {
                            validate: (0, c.assertNodeType)("Expression")
                        },
                        operator: {
                            validate: (0, c.assertOneOf)(...l.UNARY_OPERATORS)
                        }
                    },
                    visitor: [
                        "argument"
                    ],
                    aliases: [
                        "UnaryLike",
                        "Expression"
                    ]
                }), u("UpdateExpression", {
                    builder: [
                        "operator",
                        "argument",
                        "prefix"
                    ],
                    fields: {
                        prefix: {
                            default: !1
                        },
                        argument: {
                            validate: r.env.BABEL_TYPES_8_BREAKING ? (0, c.assertNodeType)("Identifier", "MemberExpression") : (0, c.assertNodeType)("Expression")
                        },
                        operator: {
                            validate: (0, c.assertOneOf)(...l.UPDATE_OPERATORS)
                        }
                    },
                    visitor: [
                        "argument"
                    ],
                    aliases: [
                        "Expression"
                    ]
                }), u("VariableDeclaration", {
                    builder: [
                        "kind",
                        "declarations"
                    ],
                    visitor: [
                        "declarations"
                    ],
                    aliases: [
                        "Statement",
                        "Declaration"
                    ],
                    fields: {
                        declare: {
                            validate: (0, c.assertValueType)("boolean"),
                            optional: !0
                        },
                        kind: {
                            validate: (0, c.assertOneOf)("var", "let", "const", "using", "await using")
                        },
                        declarations: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("VariableDeclarator")))
                        }
                    },
                    validate (e1, t, n) {
                        if (r.env.BABEL_TYPES_8_BREAKING && (0, i.default)("ForXStatement", e1, {
                            left: n
                        }) && 1 !== n.declarations.length) throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${e1.type}`);
                    }
                }), u("VariableDeclarator", {
                    visitor: [
                        "id",
                        "init"
                    ],
                    fields: {
                        id: {
                            validate: function() {
                                if (!r.env.BABEL_TYPES_8_BREAKING) return (0, c.assertNodeType)("LVal");
                                const e1 = (0, c.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), t = (0, c.assertNodeType)("Identifier");
                                return function(n, r, i) {
                                    (n.init ? e1 : t)(n, r, i);
                                };
                            }()
                        },
                        definite: {
                            optional: !0,
                            validate: (0, c.assertValueType)("boolean")
                        },
                        init: {
                            optional: !0,
                            validate: (0, c.assertNodeType)("Expression")
                        }
                    }
                }), u("WhileStatement", {
                    visitor: [
                        "test",
                        "body"
                    ],
                    aliases: [
                        "Statement",
                        "BlockParent",
                        "Loop",
                        "While",
                        "Scopable"
                    ],
                    fields: {
                        test: {
                            validate: (0, c.assertNodeType)("Expression")
                        },
                        body: {
                            validate: (0, c.assertNodeType)("Statement")
                        }
                    }
                }), u("WithStatement", {
                    visitor: [
                        "object",
                        "body"
                    ],
                    aliases: [
                        "Statement"
                    ],
                    fields: {
                        object: {
                            validate: (0, c.assertNodeType)("Expression")
                        },
                        body: {
                            validate: (0, c.assertNodeType)("Statement")
                        }
                    }
                }), u("AssignmentPattern", {
                    visitor: [
                        "left",
                        "right",
                        "decorators"
                    ],
                    builder: [
                        "left",
                        "right"
                    ],
                    aliases: [
                        "Pattern",
                        "PatternLike",
                        "LVal"
                    ],
                    fields: Object.assign({}, f(), {
                        left: {
                            validate: (0, c.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
                        },
                        right: {
                            validate: (0, c.assertNodeType)("Expression")
                        },
                        decorators: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Decorator"))),
                            optional: !0
                        }
                    })
                }), u("ArrayPattern", {
                    visitor: [
                        "elements",
                        "typeAnnotation"
                    ],
                    builder: [
                        "elements"
                    ],
                    aliases: [
                        "Pattern",
                        "PatternLike",
                        "LVal"
                    ],
                    fields: Object.assign({}, f(), {
                        elements: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeOrValueType)("null", "PatternLike", "LVal")))
                        }
                    })
                }), u("ArrowFunctionExpression", {
                    builder: [
                        "params",
                        "body",
                        "async"
                    ],
                    visitor: [
                        "params",
                        "body",
                        "returnType",
                        "typeParameters"
                    ],
                    aliases: [
                        "Scopable",
                        "Function",
                        "BlockParent",
                        "FunctionParent",
                        "Expression",
                        "Pureish"
                    ],
                    fields: Object.assign({}, p(), h(), {
                        expression: {
                            validate: (0, c.assertValueType)("boolean")
                        },
                        body: {
                            validate: (0, c.assertNodeType)("BlockStatement", "Expression")
                        },
                        predicate: {
                            validate: (0, c.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
                            optional: !0
                        }
                    })
                }), u("ClassBody", {
                    visitor: [
                        "body"
                    ],
                    fields: {
                        body: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
                        }
                    }
                }), u("ClassExpression", {
                    builder: [
                        "id",
                        "superClass",
                        "body",
                        "decorators"
                    ],
                    visitor: [
                        "id",
                        "body",
                        "superClass",
                        "mixins",
                        "typeParameters",
                        "superTypeParameters",
                        "implements",
                        "decorators"
                    ],
                    aliases: [
                        "Scopable",
                        "Class",
                        "Expression"
                    ],
                    fields: {
                        id: {
                            validate: (0, c.assertNodeType)("Identifier"),
                            optional: !0
                        },
                        typeParameters: {
                            validate: (0, c.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
                            optional: !0
                        },
                        body: {
                            validate: (0, c.assertNodeType)("ClassBody")
                        },
                        superClass: {
                            optional: !0,
                            validate: (0, c.assertNodeType)("Expression")
                        },
                        superTypeParameters: {
                            validate: (0, c.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                            optional: !0
                        },
                        implements: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
                            optional: !0
                        },
                        decorators: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Decorator"))),
                            optional: !0
                        },
                        mixins: {
                            validate: (0, c.assertNodeType)("InterfaceExtends"),
                            optional: !0
                        }
                    }
                }), u("ClassDeclaration", {
                    inherits: "ClassExpression",
                    aliases: [
                        "Scopable",
                        "Class",
                        "Statement",
                        "Declaration"
                    ],
                    fields: {
                        id: {
                            validate: (0, c.assertNodeType)("Identifier")
                        },
                        typeParameters: {
                            validate: (0, c.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
                            optional: !0
                        },
                        body: {
                            validate: (0, c.assertNodeType)("ClassBody")
                        },
                        superClass: {
                            optional: !0,
                            validate: (0, c.assertNodeType)("Expression")
                        },
                        superTypeParameters: {
                            validate: (0, c.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                            optional: !0
                        },
                        implements: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
                            optional: !0
                        },
                        decorators: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Decorator"))),
                            optional: !0
                        },
                        mixins: {
                            validate: (0, c.assertNodeType)("InterfaceExtends"),
                            optional: !0
                        },
                        declare: {
                            validate: (0, c.assertValueType)("boolean"),
                            optional: !0
                        },
                        abstract: {
                            validate: (0, c.assertValueType)("boolean"),
                            optional: !0
                        }
                    },
                    validate: function() {
                        const e1 = (0, c.assertNodeType)("Identifier");
                        return function(t, n, s) {
                            r.env.BABEL_TYPES_8_BREAKING && ((0, i.default)("ExportDefaultDeclaration", t) || e1(s, "id", s.id));
                        };
                    }()
                }), u("ExportAllDeclaration", {
                    builder: [
                        "source"
                    ],
                    visitor: [
                        "source",
                        "attributes",
                        "assertions"
                    ],
                    aliases: [
                        "Statement",
                        "Declaration",
                        "ImportOrExportDeclaration",
                        "ExportDeclaration"
                    ],
                    fields: {
                        source: {
                            validate: (0, c.assertNodeType)("StringLiteral")
                        },
                        exportKind: (0, c.validateOptional)((0, c.assertOneOf)("type", "value")),
                        attributes: {
                            optional: !0,
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("ImportAttribute")))
                        },
                        assertions: {
                            optional: !0,
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("ImportAttribute")))
                        }
                    }
                }), u("ExportDefaultDeclaration", {
                    visitor: [
                        "declaration"
                    ],
                    aliases: [
                        "Statement",
                        "Declaration",
                        "ImportOrExportDeclaration",
                        "ExportDeclaration"
                    ],
                    fields: {
                        declaration: {
                            validate: (0, c.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
                        },
                        exportKind: (0, c.validateOptional)((0, c.assertOneOf)("value"))
                    }
                }), u("ExportNamedDeclaration", {
                    builder: [
                        "declaration",
                        "specifiers",
                        "source"
                    ],
                    visitor: [
                        "declaration",
                        "specifiers",
                        "source",
                        "attributes",
                        "assertions"
                    ],
                    aliases: [
                        "Statement",
                        "Declaration",
                        "ImportOrExportDeclaration",
                        "ExportDeclaration"
                    ],
                    fields: {
                        declaration: {
                            optional: !0,
                            validate: (0, c.chain)((0, c.assertNodeType)("Declaration"), Object.assign(function(e1, t, n) {
                                if (r.env.BABEL_TYPES_8_BREAKING && n && e1.specifiers.length) throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
                            }, {
                                oneOfNodeTypes: [
                                    "Declaration"
                                ]
                            }), function(e1, t, n) {
                                if (r.env.BABEL_TYPES_8_BREAKING && n && e1.source) throw new TypeError("Cannot export a declaration from a source");
                            })
                        },
                        attributes: {
                            optional: !0,
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("ImportAttribute")))
                        },
                        assertions: {
                            optional: !0,
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("ImportAttribute")))
                        },
                        specifiers: {
                            default: [],
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)(function() {
                                const e1 = (0, c.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), t = (0, c.assertNodeType)("ExportSpecifier");
                                return r.env.BABEL_TYPES_8_BREAKING ? function(n, r, i) {
                                    (n.source ? e1 : t)(n, r, i);
                                } : e1;
                            }()))
                        },
                        source: {
                            validate: (0, c.assertNodeType)("StringLiteral"),
                            optional: !0
                        },
                        exportKind: (0, c.validateOptional)((0, c.assertOneOf)("type", "value"))
                    }
                }), u("ExportSpecifier", {
                    visitor: [
                        "local",
                        "exported"
                    ],
                    aliases: [
                        "ModuleSpecifier"
                    ],
                    fields: {
                        local: {
                            validate: (0, c.assertNodeType)("Identifier")
                        },
                        exported: {
                            validate: (0, c.assertNodeType)("Identifier", "StringLiteral")
                        },
                        exportKind: {
                            validate: (0, c.assertOneOf)("type", "value"),
                            optional: !0
                        }
                    }
                }), u("ForOfStatement", {
                    visitor: [
                        "left",
                        "right",
                        "body"
                    ],
                    builder: [
                        "left",
                        "right",
                        "body",
                        "await"
                    ],
                    aliases: [
                        "Scopable",
                        "Statement",
                        "For",
                        "BlockParent",
                        "Loop",
                        "ForXStatement"
                    ],
                    fields: {
                        left: {
                            validate: function() {
                                if (!r.env.BABEL_TYPES_8_BREAKING) return (0, c.assertNodeType)("VariableDeclaration", "LVal");
                                const e1 = (0, c.assertNodeType)("VariableDeclaration"), t = (0, c.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
                                return function(n, r, s) {
                                    (0, i.default)("VariableDeclaration", s) ? e1(n, r, s) : t(n, r, s);
                                };
                            }()
                        },
                        right: {
                            validate: (0, c.assertNodeType)("Expression")
                        },
                        body: {
                            validate: (0, c.assertNodeType)("Statement")
                        },
                        await: {
                            default: !1
                        }
                    }
                }), u("ImportDeclaration", {
                    builder: [
                        "specifiers",
                        "source"
                    ],
                    visitor: [
                        "specifiers",
                        "source",
                        "attributes",
                        "assertions"
                    ],
                    aliases: [
                        "Statement",
                        "Declaration",
                        "ImportOrExportDeclaration"
                    ],
                    fields: {
                        attributes: {
                            optional: !0,
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("ImportAttribute")))
                        },
                        assertions: {
                            optional: !0,
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("ImportAttribute")))
                        },
                        module: {
                            optional: !0,
                            validate: (0, c.assertValueType)("boolean")
                        },
                        specifiers: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
                        },
                        source: {
                            validate: (0, c.assertNodeType)("StringLiteral")
                        },
                        importKind: {
                            validate: (0, c.assertOneOf)("type", "typeof", "value"),
                            optional: !0
                        }
                    }
                }), u("ImportDefaultSpecifier", {
                    visitor: [
                        "local"
                    ],
                    aliases: [
                        "ModuleSpecifier"
                    ],
                    fields: {
                        local: {
                            validate: (0, c.assertNodeType)("Identifier")
                        }
                    }
                }), u("ImportNamespaceSpecifier", {
                    visitor: [
                        "local"
                    ],
                    aliases: [
                        "ModuleSpecifier"
                    ],
                    fields: {
                        local: {
                            validate: (0, c.assertNodeType)("Identifier")
                        }
                    }
                }), u("ImportSpecifier", {
                    visitor: [
                        "local",
                        "imported"
                    ],
                    aliases: [
                        "ModuleSpecifier"
                    ],
                    fields: {
                        local: {
                            validate: (0, c.assertNodeType)("Identifier")
                        },
                        imported: {
                            validate: (0, c.assertNodeType)("Identifier", "StringLiteral")
                        },
                        importKind: {
                            validate: (0, c.assertOneOf)("type", "typeof", "value"),
                            optional: !0
                        }
                    }
                }), u("MetaProperty", {
                    visitor: [
                        "meta",
                        "property"
                    ],
                    aliases: [
                        "Expression"
                    ],
                    fields: {
                        meta: {
                            validate: (0, c.chain)((0, c.assertNodeType)("Identifier"), Object.assign(function(e1, t, n) {
                                if (!r.env.BABEL_TYPES_8_BREAKING) return;
                                let s;
                                switch(n.name){
                                    case "function":
                                        s = "sent";
                                        break;
                                    case "new":
                                        s = "target";
                                        break;
                                    case "import":
                                        s = "meta";
                                }
                                if (!(0, i.default)("Identifier", e1.property, {
                                    name: s
                                })) throw new TypeError("Unrecognised MetaProperty");
                            }, {
                                oneOfNodeTypes: [
                                    "Identifier"
                                ]
                            }))
                        },
                        property: {
                            validate: (0, c.assertNodeType)("Identifier")
                        }
                    }
                });
                const y = ()=>({
                        abstract: {
                            validate: (0, c.assertValueType)("boolean"),
                            optional: !0
                        },
                        accessibility: {
                            validate: (0, c.assertOneOf)("public", "private", "protected"),
                            optional: !0
                        },
                        static: {
                            default: !1
                        },
                        override: {
                            default: !1
                        },
                        computed: {
                            default: !1
                        },
                        optional: {
                            validate: (0, c.assertValueType)("boolean"),
                            optional: !0
                        },
                        key: {
                            validate: (0, c.chain)(function() {
                                const e1 = (0, c.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral"), t = (0, c.assertNodeType)("Expression");
                                return function(n, r, i) {
                                    (n.computed ? t : e1)(n, r, i);
                                };
                            }(), (0, c.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
                        }
                    });
                t.classMethodOrPropertyCommon = y;
                const m = ()=>Object.assign({}, p(), y(), {
                        params: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
                        },
                        kind: {
                            validate: (0, c.assertOneOf)("get", "set", "method", "constructor"),
                            default: "method"
                        },
                        access: {
                            validate: (0, c.chain)((0, c.assertValueType)("string"), (0, c.assertOneOf)("public", "private", "protected")),
                            optional: !0
                        },
                        decorators: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Decorator"))),
                            optional: !0
                        }
                    });
                t.classMethodOrDeclareMethodCommon = m, u("ClassMethod", {
                    aliases: [
                        "Function",
                        "Scopable",
                        "BlockParent",
                        "FunctionParent",
                        "Method"
                    ],
                    builder: [
                        "kind",
                        "key",
                        "params",
                        "body",
                        "computed",
                        "static",
                        "generator",
                        "async"
                    ],
                    visitor: [
                        "key",
                        "params",
                        "body",
                        "decorators",
                        "returnType",
                        "typeParameters"
                    ],
                    fields: Object.assign({}, m(), h(), {
                        body: {
                            validate: (0, c.assertNodeType)("BlockStatement")
                        }
                    })
                }), u("ObjectPattern", {
                    visitor: [
                        "properties",
                        "typeAnnotation",
                        "decorators"
                    ],
                    builder: [
                        "properties"
                    ],
                    aliases: [
                        "Pattern",
                        "PatternLike",
                        "LVal"
                    ],
                    fields: Object.assign({}, f(), {
                        properties: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("RestElement", "ObjectProperty")))
                        }
                    })
                }), u("SpreadElement", {
                    visitor: [
                        "argument"
                    ],
                    aliases: [
                        "UnaryLike"
                    ],
                    deprecatedAlias: "SpreadProperty",
                    fields: {
                        argument: {
                            validate: (0, c.assertNodeType)("Expression")
                        }
                    }
                }), u("Super", {
                    aliases: [
                        "Expression"
                    ]
                }), u("TaggedTemplateExpression", {
                    visitor: [
                        "tag",
                        "quasi",
                        "typeParameters"
                    ],
                    builder: [
                        "tag",
                        "quasi"
                    ],
                    aliases: [
                        "Expression"
                    ],
                    fields: {
                        tag: {
                            validate: (0, c.assertNodeType)("Expression")
                        },
                        quasi: {
                            validate: (0, c.assertNodeType)("TemplateLiteral")
                        },
                        typeParameters: {
                            validate: (0, c.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                            optional: !0
                        }
                    }
                }), u("TemplateElement", {
                    builder: [
                        "value",
                        "tail"
                    ],
                    fields: {
                        value: {
                            validate: (0, c.chain)((0, c.assertShape)({
                                raw: {
                                    validate: (0, c.assertValueType)("string")
                                },
                                cooked: {
                                    validate: (0, c.assertValueType)("string"),
                                    optional: !0
                                }
                            }), function(e1) {
                                const t = e1.value.raw;
                                let n = !1;
                                const r = ()=>{
                                    throw new Error("Internal @babel/types error.");
                                }, { str: i, firstInvalidLoc: s } = (0, o.readStringContents)("template", t, 0, 0, 0, {
                                    unterminated () {
                                        n = !0;
                                    },
                                    strictNumericEscape: r,
                                    invalidEscapeSequence: r,
                                    numericSeparatorInEscapeSequence: r,
                                    unexpectedNumericSeparator: r,
                                    invalidDigit: r,
                                    invalidCodePoint: r
                                });
                                if (!n) throw new Error("Invalid raw");
                                e1.value.cooked = s ? null : i;
                            })
                        },
                        tail: {
                            default: !1
                        }
                    }
                }), u("TemplateLiteral", {
                    visitor: [
                        "quasis",
                        "expressions"
                    ],
                    aliases: [
                        "Expression",
                        "Literal"
                    ],
                    fields: {
                        quasis: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("TemplateElement")))
                        },
                        expressions: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Expression", "TSType")), function(e1, t, n) {
                                if (e1.quasis.length !== n.length + 1) throw new TypeError(`Number of ${e1.type} quasis should be exactly one more than the number of expressions.\nExpected ${n.length + 1} quasis but got ${e1.quasis.length}`);
                            })
                        }
                    }
                }), u("YieldExpression", {
                    builder: [
                        "argument",
                        "delegate"
                    ],
                    visitor: [
                        "argument"
                    ],
                    aliases: [
                        "Expression",
                        "Terminatorless"
                    ],
                    fields: {
                        delegate: {
                            validate: (0, c.chain)((0, c.assertValueType)("boolean"), Object.assign(function(e1, t, n) {
                                if (r.env.BABEL_TYPES_8_BREAKING && n && !e1.argument) throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
                            }, {
                                type: "boolean"
                            })),
                            default: !1
                        },
                        argument: {
                            optional: !0,
                            validate: (0, c.assertNodeType)("Expression")
                        }
                    }
                }), u("AwaitExpression", {
                    builder: [
                        "argument"
                    ],
                    visitor: [
                        "argument"
                    ],
                    aliases: [
                        "Expression",
                        "Terminatorless"
                    ],
                    fields: {
                        argument: {
                            validate: (0, c.assertNodeType)("Expression")
                        }
                    }
                }), u("Import", {
                    aliases: [
                        "Expression"
                    ]
                }), u("BigIntLiteral", {
                    builder: [
                        "value"
                    ],
                    fields: {
                        value: {
                            validate: (0, c.assertValueType)("string")
                        }
                    },
                    aliases: [
                        "Expression",
                        "Pureish",
                        "Literal",
                        "Immutable"
                    ]
                }), u("ExportNamespaceSpecifier", {
                    visitor: [
                        "exported"
                    ],
                    aliases: [
                        "ModuleSpecifier"
                    ],
                    fields: {
                        exported: {
                            validate: (0, c.assertNodeType)("Identifier")
                        }
                    }
                }), u("OptionalMemberExpression", {
                    builder: [
                        "object",
                        "property",
                        "computed",
                        "optional"
                    ],
                    visitor: [
                        "object",
                        "property"
                    ],
                    aliases: [
                        "Expression"
                    ],
                    fields: {
                        object: {
                            validate: (0, c.assertNodeType)("Expression")
                        },
                        property: {
                            validate: function() {
                                const e1 = (0, c.assertNodeType)("Identifier"), t = (0, c.assertNodeType)("Expression");
                                return Object.assign(function(n, r, i) {
                                    (n.computed ? t : e1)(n, r, i);
                                }, {
                                    oneOfNodeTypes: [
                                        "Expression",
                                        "Identifier"
                                    ]
                                });
                            }()
                        },
                        computed: {
                            default: !1
                        },
                        optional: {
                            validate: r.env.BABEL_TYPES_8_BREAKING ? (0, c.chain)((0, c.assertValueType)("boolean"), (0, c.assertOptionalChainStart)()) : (0, c.assertValueType)("boolean")
                        }
                    }
                }), u("OptionalCallExpression", {
                    visitor: [
                        "callee",
                        "arguments",
                        "typeParameters",
                        "typeArguments"
                    ],
                    builder: [
                        "callee",
                        "arguments",
                        "optional"
                    ],
                    aliases: [
                        "Expression"
                    ],
                    fields: {
                        callee: {
                            validate: (0, c.assertNodeType)("Expression")
                        },
                        arguments: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
                        },
                        optional: {
                            validate: r.env.BABEL_TYPES_8_BREAKING ? (0, c.chain)((0, c.assertValueType)("boolean"), (0, c.assertOptionalChainStart)()) : (0, c.assertValueType)("boolean")
                        },
                        typeArguments: {
                            validate: (0, c.assertNodeType)("TypeParameterInstantiation"),
                            optional: !0
                        },
                        typeParameters: {
                            validate: (0, c.assertNodeType)("TSTypeParameterInstantiation"),
                            optional: !0
                        }
                    }
                }), u("ClassProperty", {
                    visitor: [
                        "key",
                        "value",
                        "typeAnnotation",
                        "decorators"
                    ],
                    builder: [
                        "key",
                        "value",
                        "typeAnnotation",
                        "decorators",
                        "computed",
                        "static"
                    ],
                    aliases: [
                        "Property"
                    ],
                    fields: Object.assign({}, y(), {
                        value: {
                            validate: (0, c.assertNodeType)("Expression"),
                            optional: !0
                        },
                        definite: {
                            validate: (0, c.assertValueType)("boolean"),
                            optional: !0
                        },
                        typeAnnotation: {
                            validate: (0, c.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                            optional: !0
                        },
                        decorators: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Decorator"))),
                            optional: !0
                        },
                        readonly: {
                            validate: (0, c.assertValueType)("boolean"),
                            optional: !0
                        },
                        declare: {
                            validate: (0, c.assertValueType)("boolean"),
                            optional: !0
                        },
                        variance: {
                            validate: (0, c.assertNodeType)("Variance"),
                            optional: !0
                        }
                    })
                }), u("ClassAccessorProperty", {
                    visitor: [
                        "key",
                        "value",
                        "typeAnnotation",
                        "decorators"
                    ],
                    builder: [
                        "key",
                        "value",
                        "typeAnnotation",
                        "decorators",
                        "computed",
                        "static"
                    ],
                    aliases: [
                        "Property",
                        "Accessor"
                    ],
                    fields: Object.assign({}, y(), {
                        key: {
                            validate: (0, c.chain)(function() {
                                const e1 = (0, c.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), t = (0, c.assertNodeType)("Expression");
                                return function(n, r, i) {
                                    (n.computed ? t : e1)(n, r, i);
                                };
                            }(), (0, c.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
                        },
                        value: {
                            validate: (0, c.assertNodeType)("Expression"),
                            optional: !0
                        },
                        definite: {
                            validate: (0, c.assertValueType)("boolean"),
                            optional: !0
                        },
                        typeAnnotation: {
                            validate: (0, c.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                            optional: !0
                        },
                        decorators: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Decorator"))),
                            optional: !0
                        },
                        readonly: {
                            validate: (0, c.assertValueType)("boolean"),
                            optional: !0
                        },
                        declare: {
                            validate: (0, c.assertValueType)("boolean"),
                            optional: !0
                        },
                        variance: {
                            validate: (0, c.assertNodeType)("Variance"),
                            optional: !0
                        }
                    })
                }), u("ClassPrivateProperty", {
                    visitor: [
                        "key",
                        "value",
                        "decorators",
                        "typeAnnotation"
                    ],
                    builder: [
                        "key",
                        "value",
                        "decorators",
                        "static"
                    ],
                    aliases: [
                        "Property",
                        "Private"
                    ],
                    fields: {
                        key: {
                            validate: (0, c.assertNodeType)("PrivateName")
                        },
                        value: {
                            validate: (0, c.assertNodeType)("Expression"),
                            optional: !0
                        },
                        typeAnnotation: {
                            validate: (0, c.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                            optional: !0
                        },
                        decorators: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Decorator"))),
                            optional: !0
                        },
                        static: {
                            validate: (0, c.assertValueType)("boolean"),
                            default: !1
                        },
                        readonly: {
                            validate: (0, c.assertValueType)("boolean"),
                            optional: !0
                        },
                        definite: {
                            validate: (0, c.assertValueType)("boolean"),
                            optional: !0
                        },
                        variance: {
                            validate: (0, c.assertNodeType)("Variance"),
                            optional: !0
                        }
                    }
                }), u("ClassPrivateMethod", {
                    builder: [
                        "kind",
                        "key",
                        "params",
                        "body",
                        "static"
                    ],
                    visitor: [
                        "key",
                        "params",
                        "body",
                        "decorators",
                        "returnType",
                        "typeParameters"
                    ],
                    aliases: [
                        "Function",
                        "Scopable",
                        "BlockParent",
                        "FunctionParent",
                        "Method",
                        "Private"
                    ],
                    fields: Object.assign({}, m(), h(), {
                        kind: {
                            validate: (0, c.assertOneOf)("get", "set", "method"),
                            default: "method"
                        },
                        key: {
                            validate: (0, c.assertNodeType)("PrivateName")
                        },
                        body: {
                            validate: (0, c.assertNodeType)("BlockStatement")
                        }
                    })
                }), u("PrivateName", {
                    visitor: [
                        "id"
                    ],
                    aliases: [
                        "Private"
                    ],
                    fields: {
                        id: {
                            validate: (0, c.assertNodeType)("Identifier")
                        }
                    }
                }), u("StaticBlock", {
                    visitor: [
                        "body"
                    ],
                    fields: {
                        body: {
                            validate: (0, c.chain)((0, c.assertValueType)("array"), (0, c.assertEach)((0, c.assertNodeType)("Statement")))
                        }
                    },
                    aliases: [
                        "Scopable",
                        "BlockParent",
                        "FunctionParent"
                    ]
                });
            },
            6937: (e1, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.DEPRECATED_ALIASES = void 0, t.DEPRECATED_ALIASES = {
                    ModuleDeclaration: "ImportOrExportDeclaration"
                };
            },
            1190: (e1, t, n)=>{
                "use strict";
                var r = n(4155), i = n(1514);
                (0, i.default)("ArgumentPlaceholder", {}), (0, i.default)("BindExpression", {
                    visitor: [
                        "object",
                        "callee"
                    ],
                    aliases: [
                        "Expression"
                    ],
                    fields: r.env.BABEL_TYPES_8_BREAKING ? {
                        object: {
                            validate: (0, i.assertNodeType)("Expression")
                        },
                        callee: {
                            validate: (0, i.assertNodeType)("Expression")
                        }
                    } : {
                        object: {
                            validate: Object.assign(()=>{}, {
                                oneOfNodeTypes: [
                                    "Expression"
                                ]
                            })
                        },
                        callee: {
                            validate: Object.assign(()=>{}, {
                                oneOfNodeTypes: [
                                    "Expression"
                                ]
                            })
                        }
                    }
                }), (0, i.default)("ImportAttribute", {
                    visitor: [
                        "key",
                        "value"
                    ],
                    fields: {
                        key: {
                            validate: (0, i.assertNodeType)("Identifier", "StringLiteral")
                        },
                        value: {
                            validate: (0, i.assertNodeType)("StringLiteral")
                        }
                    }
                }), (0, i.default)("Decorator", {
                    visitor: [
                        "expression"
                    ],
                    fields: {
                        expression: {
                            validate: (0, i.assertNodeType)("Expression")
                        }
                    }
                }), (0, i.default)("DoExpression", {
                    visitor: [
                        "body"
                    ],
                    builder: [
                        "body",
                        "async"
                    ],
                    aliases: [
                        "Expression"
                    ],
                    fields: {
                        body: {
                            validate: (0, i.assertNodeType)("BlockStatement")
                        },
                        async: {
                            validate: (0, i.assertValueType)("boolean"),
                            default: !1
                        }
                    }
                }), (0, i.default)("ExportDefaultSpecifier", {
                    visitor: [
                        "exported"
                    ],
                    aliases: [
                        "ModuleSpecifier"
                    ],
                    fields: {
                        exported: {
                            validate: (0, i.assertNodeType)("Identifier")
                        }
                    }
                }), (0, i.default)("RecordExpression", {
                    visitor: [
                        "properties"
                    ],
                    aliases: [
                        "Expression"
                    ],
                    fields: {
                        properties: {
                            validate: (0, i.chain)((0, i.assertValueType)("array"), (0, i.assertEach)((0, i.assertNodeType)("ObjectProperty", "SpreadElement")))
                        }
                    }
                }), (0, i.default)("TupleExpression", {
                    fields: {
                        elements: {
                            validate: (0, i.chain)((0, i.assertValueType)("array"), (0, i.assertEach)((0, i.assertNodeType)("Expression", "SpreadElement"))),
                            default: []
                        }
                    },
                    visitor: [
                        "elements"
                    ],
                    aliases: [
                        "Expression"
                    ]
                }), (0, i.default)("DecimalLiteral", {
                    builder: [
                        "value"
                    ],
                    fields: {
                        value: {
                            validate: (0, i.assertValueType)("string")
                        }
                    },
                    aliases: [
                        "Expression",
                        "Pureish",
                        "Literal",
                        "Immutable"
                    ]
                }), (0, i.default)("ModuleExpression", {
                    visitor: [
                        "body"
                    ],
                    fields: {
                        body: {
                            validate: (0, i.assertNodeType)("Program")
                        }
                    },
                    aliases: [
                        "Expression"
                    ]
                }), (0, i.default)("TopicReference", {
                    aliases: [
                        "Expression"
                    ]
                }), (0, i.default)("PipelineTopicExpression", {
                    builder: [
                        "expression"
                    ],
                    visitor: [
                        "expression"
                    ],
                    fields: {
                        expression: {
                            validate: (0, i.assertNodeType)("Expression")
                        }
                    },
                    aliases: [
                        "Expression"
                    ]
                }), (0, i.default)("PipelineBareFunction", {
                    builder: [
                        "callee"
                    ],
                    visitor: [
                        "callee"
                    ],
                    fields: {
                        callee: {
                            validate: (0, i.assertNodeType)("Expression")
                        }
                    },
                    aliases: [
                        "Expression"
                    ]
                }), (0, i.default)("PipelinePrimaryTopicReference", {
                    aliases: [
                        "Expression"
                    ]
                });
            },
            3940: (e1, t, n)=>{
                "use strict";
                var r = n(1514);
                const i = (0, r.defineAliasedType)("Flow"), s = (e1)=>{
                    const t = "DeclareClass" === e1;
                    i(e1, {
                        builder: [
                            "id",
                            "typeParameters",
                            "extends",
                            "body"
                        ],
                        visitor: [
                            "id",
                            "typeParameters",
                            "extends",
                            ...t ? [
                                "mixins",
                                "implements"
                            ] : [],
                            "body"
                        ],
                        aliases: [
                            "FlowDeclaration",
                            "Statement",
                            "Declaration"
                        ],
                        fields: Object.assign({
                            id: (0, r.validateType)("Identifier"),
                            typeParameters: (0, r.validateOptionalType)("TypeParameterDeclaration"),
                            extends: (0, r.validateOptional)((0, r.arrayOfType)("InterfaceExtends"))
                        }, t ? {
                            mixins: (0, r.validateOptional)((0, r.arrayOfType)("InterfaceExtends")),
                            implements: (0, r.validateOptional)((0, r.arrayOfType)("ClassImplements"))
                        } : {}, {
                            body: (0, r.validateType)("ObjectTypeAnnotation")
                        })
                    });
                };
                i("AnyTypeAnnotation", {
                    aliases: [
                        "FlowType",
                        "FlowBaseAnnotation"
                    ]
                }), i("ArrayTypeAnnotation", {
                    visitor: [
                        "elementType"
                    ],
                    aliases: [
                        "FlowType"
                    ],
                    fields: {
                        elementType: (0, r.validateType)("FlowType")
                    }
                }), i("BooleanTypeAnnotation", {
                    aliases: [
                        "FlowType",
                        "FlowBaseAnnotation"
                    ]
                }), i("BooleanLiteralTypeAnnotation", {
                    builder: [
                        "value"
                    ],
                    aliases: [
                        "FlowType"
                    ],
                    fields: {
                        value: (0, r.validate)((0, r.assertValueType)("boolean"))
                    }
                }), i("NullLiteralTypeAnnotation", {
                    aliases: [
                        "FlowType",
                        "FlowBaseAnnotation"
                    ]
                }), i("ClassImplements", {
                    visitor: [
                        "id",
                        "typeParameters"
                    ],
                    fields: {
                        id: (0, r.validateType)("Identifier"),
                        typeParameters: (0, r.validateOptionalType)("TypeParameterInstantiation")
                    }
                }), s("DeclareClass"), i("DeclareFunction", {
                    visitor: [
                        "id"
                    ],
                    aliases: [
                        "FlowDeclaration",
                        "Statement",
                        "Declaration"
                    ],
                    fields: {
                        id: (0, r.validateType)("Identifier"),
                        predicate: (0, r.validateOptionalType)("DeclaredPredicate")
                    }
                }), s("DeclareInterface"), i("DeclareModule", {
                    builder: [
                        "id",
                        "body",
                        "kind"
                    ],
                    visitor: [
                        "id",
                        "body"
                    ],
                    aliases: [
                        "FlowDeclaration",
                        "Statement",
                        "Declaration"
                    ],
                    fields: {
                        id: (0, r.validateType)([
                            "Identifier",
                            "StringLiteral"
                        ]),
                        body: (0, r.validateType)("BlockStatement"),
                        kind: (0, r.validateOptional)((0, r.assertOneOf)("CommonJS", "ES"))
                    }
                }), i("DeclareModuleExports", {
                    visitor: [
                        "typeAnnotation"
                    ],
                    aliases: [
                        "FlowDeclaration",
                        "Statement",
                        "Declaration"
                    ],
                    fields: {
                        typeAnnotation: (0, r.validateType)("TypeAnnotation")
                    }
                }), i("DeclareTypeAlias", {
                    visitor: [
                        "id",
                        "typeParameters",
                        "right"
                    ],
                    aliases: [
                        "FlowDeclaration",
                        "Statement",
                        "Declaration"
                    ],
                    fields: {
                        id: (0, r.validateType)("Identifier"),
                        typeParameters: (0, r.validateOptionalType)("TypeParameterDeclaration"),
                        right: (0, r.validateType)("FlowType")
                    }
                }), i("DeclareOpaqueType", {
                    visitor: [
                        "id",
                        "typeParameters",
                        "supertype"
                    ],
                    aliases: [
                        "FlowDeclaration",
                        "Statement",
                        "Declaration"
                    ],
                    fields: {
                        id: (0, r.validateType)("Identifier"),
                        typeParameters: (0, r.validateOptionalType)("TypeParameterDeclaration"),
                        supertype: (0, r.validateOptionalType)("FlowType"),
                        impltype: (0, r.validateOptionalType)("FlowType")
                    }
                }), i("DeclareVariable", {
                    visitor: [
                        "id"
                    ],
                    aliases: [
                        "FlowDeclaration",
                        "Statement",
                        "Declaration"
                    ],
                    fields: {
                        id: (0, r.validateType)("Identifier")
                    }
                }), i("DeclareExportDeclaration", {
                    visitor: [
                        "declaration",
                        "specifiers",
                        "source"
                    ],
                    aliases: [
                        "FlowDeclaration",
                        "Statement",
                        "Declaration"
                    ],
                    fields: {
                        declaration: (0, r.validateOptionalType)("Flow"),
                        specifiers: (0, r.validateOptional)((0, r.arrayOfType)([
                            "ExportSpecifier",
                            "ExportNamespaceSpecifier"
                        ])),
                        source: (0, r.validateOptionalType)("StringLiteral"),
                        default: (0, r.validateOptional)((0, r.assertValueType)("boolean"))
                    }
                }), i("DeclareExportAllDeclaration", {
                    visitor: [
                        "source"
                    ],
                    aliases: [
                        "FlowDeclaration",
                        "Statement",
                        "Declaration"
                    ],
                    fields: {
                        source: (0, r.validateType)("StringLiteral"),
                        exportKind: (0, r.validateOptional)((0, r.assertOneOf)("type", "value"))
                    }
                }), i("DeclaredPredicate", {
                    visitor: [
                        "value"
                    ],
                    aliases: [
                        "FlowPredicate"
                    ],
                    fields: {
                        value: (0, r.validateType)("Flow")
                    }
                }), i("ExistsTypeAnnotation", {
                    aliases: [
                        "FlowType"
                    ]
                }), i("FunctionTypeAnnotation", {
                    visitor: [
                        "typeParameters",
                        "params",
                        "rest",
                        "returnType"
                    ],
                    aliases: [
                        "FlowType"
                    ],
                    fields: {
                        typeParameters: (0, r.validateOptionalType)("TypeParameterDeclaration"),
                        params: (0, r.validate)((0, r.arrayOfType)("FunctionTypeParam")),
                        rest: (0, r.validateOptionalType)("FunctionTypeParam"),
                        this: (0, r.validateOptionalType)("FunctionTypeParam"),
                        returnType: (0, r.validateType)("FlowType")
                    }
                }), i("FunctionTypeParam", {
                    visitor: [
                        "name",
                        "typeAnnotation"
                    ],
                    fields: {
                        name: (0, r.validateOptionalType)("Identifier"),
                        typeAnnotation: (0, r.validateType)("FlowType"),
                        optional: (0, r.validateOptional)((0, r.assertValueType)("boolean"))
                    }
                }), i("GenericTypeAnnotation", {
                    visitor: [
                        "id",
                        "typeParameters"
                    ],
                    aliases: [
                        "FlowType"
                    ],
                    fields: {
                        id: (0, r.validateType)([
                            "Identifier",
                            "QualifiedTypeIdentifier"
                        ]),
                        typeParameters: (0, r.validateOptionalType)("TypeParameterInstantiation")
                    }
                }), i("InferredPredicate", {
                    aliases: [
                        "FlowPredicate"
                    ]
                }), i("InterfaceExtends", {
                    visitor: [
                        "id",
                        "typeParameters"
                    ],
                    fields: {
                        id: (0, r.validateType)([
                            "Identifier",
                            "QualifiedTypeIdentifier"
                        ]),
                        typeParameters: (0, r.validateOptionalType)("TypeParameterInstantiation")
                    }
                }), s("InterfaceDeclaration"), i("InterfaceTypeAnnotation", {
                    visitor: [
                        "extends",
                        "body"
                    ],
                    aliases: [
                        "FlowType"
                    ],
                    fields: {
                        extends: (0, r.validateOptional)((0, r.arrayOfType)("InterfaceExtends")),
                        body: (0, r.validateType)("ObjectTypeAnnotation")
                    }
                }), i("IntersectionTypeAnnotation", {
                    visitor: [
                        "types"
                    ],
                    aliases: [
                        "FlowType"
                    ],
                    fields: {
                        types: (0, r.validate)((0, r.arrayOfType)("FlowType"))
                    }
                }), i("MixedTypeAnnotation", {
                    aliases: [
                        "FlowType",
                        "FlowBaseAnnotation"
                    ]
                }), i("EmptyTypeAnnotation", {
                    aliases: [
                        "FlowType",
                        "FlowBaseAnnotation"
                    ]
                }), i("NullableTypeAnnotation", {
                    visitor: [
                        "typeAnnotation"
                    ],
                    aliases: [
                        "FlowType"
                    ],
                    fields: {
                        typeAnnotation: (0, r.validateType)("FlowType")
                    }
                }), i("NumberLiteralTypeAnnotation", {
                    builder: [
                        "value"
                    ],
                    aliases: [
                        "FlowType"
                    ],
                    fields: {
                        value: (0, r.validate)((0, r.assertValueType)("number"))
                    }
                }), i("NumberTypeAnnotation", {
                    aliases: [
                        "FlowType",
                        "FlowBaseAnnotation"
                    ]
                }), i("ObjectTypeAnnotation", {
                    visitor: [
                        "properties",
                        "indexers",
                        "callProperties",
                        "internalSlots"
                    ],
                    aliases: [
                        "FlowType"
                    ],
                    builder: [
                        "properties",
                        "indexers",
                        "callProperties",
                        "internalSlots",
                        "exact"
                    ],
                    fields: {
                        properties: (0, r.validate)((0, r.arrayOfType)([
                            "ObjectTypeProperty",
                            "ObjectTypeSpreadProperty"
                        ])),
                        indexers: {
                            validate: (0, r.arrayOfType)("ObjectTypeIndexer"),
                            optional: !0,
                            default: []
                        },
                        callProperties: {
                            validate: (0, r.arrayOfType)("ObjectTypeCallProperty"),
                            optional: !0,
                            default: []
                        },
                        internalSlots: {
                            validate: (0, r.arrayOfType)("ObjectTypeInternalSlot"),
                            optional: !0,
                            default: []
                        },
                        exact: {
                            validate: (0, r.assertValueType)("boolean"),
                            default: !1
                        },
                        inexact: (0, r.validateOptional)((0, r.assertValueType)("boolean"))
                    }
                }), i("ObjectTypeInternalSlot", {
                    visitor: [
                        "id",
                        "value",
                        "optional",
                        "static",
                        "method"
                    ],
                    aliases: [
                        "UserWhitespacable"
                    ],
                    fields: {
                        id: (0, r.validateType)("Identifier"),
                        value: (0, r.validateType)("FlowType"),
                        optional: (0, r.validate)((0, r.assertValueType)("boolean")),
                        static: (0, r.validate)((0, r.assertValueType)("boolean")),
                        method: (0, r.validate)((0, r.assertValueType)("boolean"))
                    }
                }), i("ObjectTypeCallProperty", {
                    visitor: [
                        "value"
                    ],
                    aliases: [
                        "UserWhitespacable"
                    ],
                    fields: {
                        value: (0, r.validateType)("FlowType"),
                        static: (0, r.validate)((0, r.assertValueType)("boolean"))
                    }
                }), i("ObjectTypeIndexer", {
                    visitor: [
                        "id",
                        "key",
                        "value",
                        "variance"
                    ],
                    aliases: [
                        "UserWhitespacable"
                    ],
                    fields: {
                        id: (0, r.validateOptionalType)("Identifier"),
                        key: (0, r.validateType)("FlowType"),
                        value: (0, r.validateType)("FlowType"),
                        static: (0, r.validate)((0, r.assertValueType)("boolean")),
                        variance: (0, r.validateOptionalType)("Variance")
                    }
                }), i("ObjectTypeProperty", {
                    visitor: [
                        "key",
                        "value",
                        "variance"
                    ],
                    aliases: [
                        "UserWhitespacable"
                    ],
                    fields: {
                        key: (0, r.validateType)([
                            "Identifier",
                            "StringLiteral"
                        ]),
                        value: (0, r.validateType)("FlowType"),
                        kind: (0, r.validate)((0, r.assertOneOf)("init", "get", "set")),
                        static: (0, r.validate)((0, r.assertValueType)("boolean")),
                        proto: (0, r.validate)((0, r.assertValueType)("boolean")),
                        optional: (0, r.validate)((0, r.assertValueType)("boolean")),
                        variance: (0, r.validateOptionalType)("Variance"),
                        method: (0, r.validate)((0, r.assertValueType)("boolean"))
                    }
                }), i("ObjectTypeSpreadProperty", {
                    visitor: [
                        "argument"
                    ],
                    aliases: [
                        "UserWhitespacable"
                    ],
                    fields: {
                        argument: (0, r.validateType)("FlowType")
                    }
                }), i("OpaqueType", {
                    visitor: [
                        "id",
                        "typeParameters",
                        "supertype",
                        "impltype"
                    ],
                    aliases: [
                        "FlowDeclaration",
                        "Statement",
                        "Declaration"
                    ],
                    fields: {
                        id: (0, r.validateType)("Identifier"),
                        typeParameters: (0, r.validateOptionalType)("TypeParameterDeclaration"),
                        supertype: (0, r.validateOptionalType)("FlowType"),
                        impltype: (0, r.validateType)("FlowType")
                    }
                }), i("QualifiedTypeIdentifier", {
                    visitor: [
                        "id",
                        "qualification"
                    ],
                    fields: {
                        id: (0, r.validateType)("Identifier"),
                        qualification: (0, r.validateType)([
                            "Identifier",
                            "QualifiedTypeIdentifier"
                        ])
                    }
                }), i("StringLiteralTypeAnnotation", {
                    builder: [
                        "value"
                    ],
                    aliases: [
                        "FlowType"
                    ],
                    fields: {
                        value: (0, r.validate)((0, r.assertValueType)("string"))
                    }
                }), i("StringTypeAnnotation", {
                    aliases: [
                        "FlowType",
                        "FlowBaseAnnotation"
                    ]
                }), i("SymbolTypeAnnotation", {
                    aliases: [
                        "FlowType",
                        "FlowBaseAnnotation"
                    ]
                }), i("ThisTypeAnnotation", {
                    aliases: [
                        "FlowType",
                        "FlowBaseAnnotation"
                    ]
                }), i("TupleTypeAnnotation", {
                    visitor: [
                        "types"
                    ],
                    aliases: [
                        "FlowType"
                    ],
                    fields: {
                        types: (0, r.validate)((0, r.arrayOfType)("FlowType"))
                    }
                }), i("TypeofTypeAnnotation", {
                    visitor: [
                        "argument"
                    ],
                    aliases: [
                        "FlowType"
                    ],
                    fields: {
                        argument: (0, r.validateType)("FlowType")
                    }
                }), i("TypeAlias", {
                    visitor: [
                        "id",
                        "typeParameters",
                        "right"
                    ],
                    aliases: [
                        "FlowDeclaration",
                        "Statement",
                        "Declaration"
                    ],
                    fields: {
                        id: (0, r.validateType)("Identifier"),
                        typeParameters: (0, r.validateOptionalType)("TypeParameterDeclaration"),
                        right: (0, r.validateType)("FlowType")
                    }
                }), i("TypeAnnotation", {
                    visitor: [
                        "typeAnnotation"
                    ],
                    fields: {
                        typeAnnotation: (0, r.validateType)("FlowType")
                    }
                }), i("TypeCastExpression", {
                    visitor: [
                        "expression",
                        "typeAnnotation"
                    ],
                    aliases: [
                        "ExpressionWrapper",
                        "Expression"
                    ],
                    fields: {
                        expression: (0, r.validateType)("Expression"),
                        typeAnnotation: (0, r.validateType)("TypeAnnotation")
                    }
                }), i("TypeParameter", {
                    visitor: [
                        "bound",
                        "default",
                        "variance"
                    ],
                    fields: {
                        name: (0, r.validate)((0, r.assertValueType)("string")),
                        bound: (0, r.validateOptionalType)("TypeAnnotation"),
                        default: (0, r.validateOptionalType)("FlowType"),
                        variance: (0, r.validateOptionalType)("Variance")
                    }
                }), i("TypeParameterDeclaration", {
                    visitor: [
                        "params"
                    ],
                    fields: {
                        params: (0, r.validate)((0, r.arrayOfType)("TypeParameter"))
                    }
                }), i("TypeParameterInstantiation", {
                    visitor: [
                        "params"
                    ],
                    fields: {
                        params: (0, r.validate)((0, r.arrayOfType)("FlowType"))
                    }
                }), i("UnionTypeAnnotation", {
                    visitor: [
                        "types"
                    ],
                    aliases: [
                        "FlowType"
                    ],
                    fields: {
                        types: (0, r.validate)((0, r.arrayOfType)("FlowType"))
                    }
                }), i("Variance", {
                    builder: [
                        "kind"
                    ],
                    fields: {
                        kind: (0, r.validate)((0, r.assertOneOf)("minus", "plus"))
                    }
                }), i("VoidTypeAnnotation", {
                    aliases: [
                        "FlowType",
                        "FlowBaseAnnotation"
                    ]
                }), i("EnumDeclaration", {
                    aliases: [
                        "Statement",
                        "Declaration"
                    ],
                    visitor: [
                        "id",
                        "body"
                    ],
                    fields: {
                        id: (0, r.validateType)("Identifier"),
                        body: (0, r.validateType)([
                            "EnumBooleanBody",
                            "EnumNumberBody",
                            "EnumStringBody",
                            "EnumSymbolBody"
                        ])
                    }
                }), i("EnumBooleanBody", {
                    aliases: [
                        "EnumBody"
                    ],
                    visitor: [
                        "members"
                    ],
                    fields: {
                        explicitType: (0, r.validate)((0, r.assertValueType)("boolean")),
                        members: (0, r.validateArrayOfType)("EnumBooleanMember"),
                        hasUnknownMembers: (0, r.validate)((0, r.assertValueType)("boolean"))
                    }
                }), i("EnumNumberBody", {
                    aliases: [
                        "EnumBody"
                    ],
                    visitor: [
                        "members"
                    ],
                    fields: {
                        explicitType: (0, r.validate)((0, r.assertValueType)("boolean")),
                        members: (0, r.validateArrayOfType)("EnumNumberMember"),
                        hasUnknownMembers: (0, r.validate)((0, r.assertValueType)("boolean"))
                    }
                }), i("EnumStringBody", {
                    aliases: [
                        "EnumBody"
                    ],
                    visitor: [
                        "members"
                    ],
                    fields: {
                        explicitType: (0, r.validate)((0, r.assertValueType)("boolean")),
                        members: (0, r.validateArrayOfType)([
                            "EnumStringMember",
                            "EnumDefaultedMember"
                        ]),
                        hasUnknownMembers: (0, r.validate)((0, r.assertValueType)("boolean"))
                    }
                }), i("EnumSymbolBody", {
                    aliases: [
                        "EnumBody"
                    ],
                    visitor: [
                        "members"
                    ],
                    fields: {
                        members: (0, r.validateArrayOfType)("EnumDefaultedMember"),
                        hasUnknownMembers: (0, r.validate)((0, r.assertValueType)("boolean"))
                    }
                }), i("EnumBooleanMember", {
                    aliases: [
                        "EnumMember"
                    ],
                    visitor: [
                        "id"
                    ],
                    fields: {
                        id: (0, r.validateType)("Identifier"),
                        init: (0, r.validateType)("BooleanLiteral")
                    }
                }), i("EnumNumberMember", {
                    aliases: [
                        "EnumMember"
                    ],
                    visitor: [
                        "id",
                        "init"
                    ],
                    fields: {
                        id: (0, r.validateType)("Identifier"),
                        init: (0, r.validateType)("NumericLiteral")
                    }
                }), i("EnumStringMember", {
                    aliases: [
                        "EnumMember"
                    ],
                    visitor: [
                        "id",
                        "init"
                    ],
                    fields: {
                        id: (0, r.validateType)("Identifier"),
                        init: (0, r.validateType)("StringLiteral")
                    }
                }), i("EnumDefaultedMember", {
                    aliases: [
                        "EnumMember"
                    ],
                    visitor: [
                        "id"
                    ],
                    fields: {
                        id: (0, r.validateType)("Identifier")
                    }
                }), i("IndexedAccessType", {
                    visitor: [
                        "objectType",
                        "indexType"
                    ],
                    aliases: [
                        "FlowType"
                    ],
                    fields: {
                        objectType: (0, r.validateType)("FlowType"),
                        indexType: (0, r.validateType)("FlowType")
                    }
                }), i("OptionalIndexedAccessType", {
                    visitor: [
                        "objectType",
                        "indexType"
                    ],
                    aliases: [
                        "FlowType"
                    ],
                    fields: {
                        objectType: (0, r.validateType)("FlowType"),
                        indexType: (0, r.validateType)("FlowType"),
                        optional: (0, r.validate)((0, r.assertValueType)("boolean"))
                    }
                });
            },
            1678: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), Object.defineProperty(t, "ALIAS_KEYS", {
                    enumerable: !0,
                    get: function() {
                        return i.ALIAS_KEYS;
                    }
                }), Object.defineProperty(t, "BUILDER_KEYS", {
                    enumerable: !0,
                    get: function() {
                        return i.BUILDER_KEYS;
                    }
                }), Object.defineProperty(t, "DEPRECATED_ALIASES", {
                    enumerable: !0,
                    get: function() {
                        return a.DEPRECATED_ALIASES;
                    }
                }), Object.defineProperty(t, "DEPRECATED_KEYS", {
                    enumerable: !0,
                    get: function() {
                        return i.DEPRECATED_KEYS;
                    }
                }), Object.defineProperty(t, "FLIPPED_ALIAS_KEYS", {
                    enumerable: !0,
                    get: function() {
                        return i.FLIPPED_ALIAS_KEYS;
                    }
                }), Object.defineProperty(t, "NODE_FIELDS", {
                    enumerable: !0,
                    get: function() {
                        return i.NODE_FIELDS;
                    }
                }), Object.defineProperty(t, "NODE_PARENT_VALIDATIONS", {
                    enumerable: !0,
                    get: function() {
                        return i.NODE_PARENT_VALIDATIONS;
                    }
                }), Object.defineProperty(t, "PLACEHOLDERS", {
                    enumerable: !0,
                    get: function() {
                        return s.PLACEHOLDERS;
                    }
                }), Object.defineProperty(t, "PLACEHOLDERS_ALIAS", {
                    enumerable: !0,
                    get: function() {
                        return s.PLACEHOLDERS_ALIAS;
                    }
                }), Object.defineProperty(t, "PLACEHOLDERS_FLIPPED_ALIAS", {
                    enumerable: !0,
                    get: function() {
                        return s.PLACEHOLDERS_FLIPPED_ALIAS;
                    }
                }), t.TYPES = void 0, Object.defineProperty(t, "VISITOR_KEYS", {
                    enumerable: !0,
                    get: function() {
                        return i.VISITOR_KEYS;
                    }
                });
                var r = n(3164);
                n(8248), n(3940), n(1410), n(3858), n(1190), n(4);
                var i = n(1514), s = n(7389), a = n(6937);
                Object.keys(a.DEPRECATED_ALIASES).forEach((e1)=>{
                    i.FLIPPED_ALIAS_KEYS[e1] = i.FLIPPED_ALIAS_KEYS[a.DEPRECATED_ALIASES[e1]];
                }), r(i.VISITOR_KEYS), r(i.ALIAS_KEYS), r(i.FLIPPED_ALIAS_KEYS), r(i.NODE_FIELDS), r(i.BUILDER_KEYS), r(i.DEPRECATED_KEYS), r(s.PLACEHOLDERS_ALIAS), r(s.PLACEHOLDERS_FLIPPED_ALIAS);
                const o = [].concat(Object.keys(i.VISITOR_KEYS), Object.keys(i.FLIPPED_ALIAS_KEYS), Object.keys(i.DEPRECATED_KEYS));
                t.TYPES = o;
            },
            1410: (e1, t, n)=>{
                "use strict";
                var r = n(1514);
                const i = (0, r.defineAliasedType)("JSX");
                i("JSXAttribute", {
                    visitor: [
                        "name",
                        "value"
                    ],
                    aliases: [
                        "Immutable"
                    ],
                    fields: {
                        name: {
                            validate: (0, r.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
                        },
                        value: {
                            optional: !0,
                            validate: (0, r.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
                        }
                    }
                }), i("JSXClosingElement", {
                    visitor: [
                        "name"
                    ],
                    aliases: [
                        "Immutable"
                    ],
                    fields: {
                        name: {
                            validate: (0, r.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
                        }
                    }
                }), i("JSXElement", {
                    builder: [
                        "openingElement",
                        "closingElement",
                        "children",
                        "selfClosing"
                    ],
                    visitor: [
                        "openingElement",
                        "children",
                        "closingElement"
                    ],
                    aliases: [
                        "Immutable",
                        "Expression"
                    ],
                    fields: Object.assign({
                        openingElement: {
                            validate: (0, r.assertNodeType)("JSXOpeningElement")
                        },
                        closingElement: {
                            optional: !0,
                            validate: (0, r.assertNodeType)("JSXClosingElement")
                        },
                        children: {
                            validate: (0, r.chain)((0, r.assertValueType)("array"), (0, r.assertEach)((0, r.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
                        }
                    }, {
                        selfClosing: {
                            validate: (0, r.assertValueType)("boolean"),
                            optional: !0
                        }
                    })
                }), i("JSXEmptyExpression", {}), i("JSXExpressionContainer", {
                    visitor: [
                        "expression"
                    ],
                    aliases: [
                        "Immutable"
                    ],
                    fields: {
                        expression: {
                            validate: (0, r.assertNodeType)("Expression", "JSXEmptyExpression")
                        }
                    }
                }), i("JSXSpreadChild", {
                    visitor: [
                        "expression"
                    ],
                    aliases: [
                        "Immutable"
                    ],
                    fields: {
                        expression: {
                            validate: (0, r.assertNodeType)("Expression")
                        }
                    }
                }), i("JSXIdentifier", {
                    builder: [
                        "name"
                    ],
                    fields: {
                        name: {
                            validate: (0, r.assertValueType)("string")
                        }
                    }
                }), i("JSXMemberExpression", {
                    visitor: [
                        "object",
                        "property"
                    ],
                    fields: {
                        object: {
                            validate: (0, r.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
                        },
                        property: {
                            validate: (0, r.assertNodeType)("JSXIdentifier")
                        }
                    }
                }), i("JSXNamespacedName", {
                    visitor: [
                        "namespace",
                        "name"
                    ],
                    fields: {
                        namespace: {
                            validate: (0, r.assertNodeType)("JSXIdentifier")
                        },
                        name: {
                            validate: (0, r.assertNodeType)("JSXIdentifier")
                        }
                    }
                }), i("JSXOpeningElement", {
                    builder: [
                        "name",
                        "attributes",
                        "selfClosing"
                    ],
                    visitor: [
                        "name",
                        "attributes"
                    ],
                    aliases: [
                        "Immutable"
                    ],
                    fields: {
                        name: {
                            validate: (0, r.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
                        },
                        selfClosing: {
                            default: !1
                        },
                        attributes: {
                            validate: (0, r.chain)((0, r.assertValueType)("array"), (0, r.assertEach)((0, r.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
                        },
                        typeParameters: {
                            validate: (0, r.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                            optional: !0
                        }
                    }
                }), i("JSXSpreadAttribute", {
                    visitor: [
                        "argument"
                    ],
                    fields: {
                        argument: {
                            validate: (0, r.assertNodeType)("Expression")
                        }
                    }
                }), i("JSXText", {
                    aliases: [
                        "Immutable"
                    ],
                    builder: [
                        "value"
                    ],
                    fields: {
                        value: {
                            validate: (0, r.assertValueType)("string")
                        }
                    }
                }), i("JSXFragment", {
                    builder: [
                        "openingFragment",
                        "closingFragment",
                        "children"
                    ],
                    visitor: [
                        "openingFragment",
                        "children",
                        "closingFragment"
                    ],
                    aliases: [
                        "Immutable",
                        "Expression"
                    ],
                    fields: {
                        openingFragment: {
                            validate: (0, r.assertNodeType)("JSXOpeningFragment")
                        },
                        closingFragment: {
                            validate: (0, r.assertNodeType)("JSXClosingFragment")
                        },
                        children: {
                            validate: (0, r.chain)((0, r.assertValueType)("array"), (0, r.assertEach)((0, r.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
                        }
                    }
                }), i("JSXOpeningFragment", {
                    aliases: [
                        "Immutable"
                    ]
                }), i("JSXClosingFragment", {
                    aliases: [
                        "Immutable"
                    ]
                });
            },
            3858: (e1, t, n)=>{
                "use strict";
                var r = n(1514), i = n(7389);
                const s = (0, r.defineAliasedType)("Miscellaneous");
                s("Noop", {
                    visitor: []
                }), s("Placeholder", {
                    visitor: [],
                    builder: [
                        "expectedNode",
                        "name"
                    ],
                    fields: {
                        name: {
                            validate: (0, r.assertNodeType)("Identifier")
                        },
                        expectedNode: {
                            validate: (0, r.assertOneOf)(...i.PLACEHOLDERS)
                        }
                    }
                }), s("V8IntrinsicIdentifier", {
                    builder: [
                        "name"
                    ],
                    fields: {
                        name: {
                            validate: (0, r.assertValueType)("string")
                        }
                    }
                });
            },
            7389: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.PLACEHOLDERS_FLIPPED_ALIAS = t.PLACEHOLDERS_ALIAS = t.PLACEHOLDERS = void 0;
                var r = n(1514);
                const i = [
                    "Identifier",
                    "StringLiteral",
                    "Expression",
                    "Statement",
                    "Declaration",
                    "BlockStatement",
                    "ClassBody",
                    "Pattern"
                ];
                t.PLACEHOLDERS = i;
                const s = {
                    Declaration: [
                        "Statement"
                    ],
                    Pattern: [
                        "PatternLike",
                        "LVal"
                    ]
                };
                t.PLACEHOLDERS_ALIAS = s;
                for (const e1 of i){
                    const t = r.ALIAS_KEYS[e1];
                    null != t && t.length && (s[e1] = t);
                }
                const a = {};
                t.PLACEHOLDERS_FLIPPED_ALIAS = a, Object.keys(s).forEach((e1)=>{
                    s[e1].forEach((t)=>{
                        Object.hasOwnProperty.call(a, t) || (a[t] = []), a[t].push(e1);
                    });
                });
            },
            4: (e1, t, n)=>{
                "use strict";
                var r = n(1514), i = n(8248), s = n(5171);
                const a = (0, r.defineAliasedType)("TypeScript"), o = (0, r.assertValueType)("boolean"), l = ()=>({
                        returnType: {
                            validate: (0, r.assertNodeType)("TSTypeAnnotation", "Noop"),
                            optional: !0
                        },
                        typeParameters: {
                            validate: (0, r.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
                            optional: !0
                        }
                    });
                a("TSParameterProperty", {
                    aliases: [
                        "LVal"
                    ],
                    visitor: [
                        "parameter"
                    ],
                    fields: {
                        accessibility: {
                            validate: (0, r.assertOneOf)("public", "private", "protected"),
                            optional: !0
                        },
                        readonly: {
                            validate: (0, r.assertValueType)("boolean"),
                            optional: !0
                        },
                        parameter: {
                            validate: (0, r.assertNodeType)("Identifier", "AssignmentPattern")
                        },
                        override: {
                            validate: (0, r.assertValueType)("boolean"),
                            optional: !0
                        },
                        decorators: {
                            validate: (0, r.chain)((0, r.assertValueType)("array"), (0, r.assertEach)((0, r.assertNodeType)("Decorator"))),
                            optional: !0
                        }
                    }
                }), a("TSDeclareFunction", {
                    aliases: [
                        "Statement",
                        "Declaration"
                    ],
                    visitor: [
                        "id",
                        "typeParameters",
                        "params",
                        "returnType"
                    ],
                    fields: Object.assign({}, (0, i.functionDeclarationCommon)(), l())
                }), a("TSDeclareMethod", {
                    visitor: [
                        "decorators",
                        "key",
                        "typeParameters",
                        "params",
                        "returnType"
                    ],
                    fields: Object.assign({}, (0, i.classMethodOrDeclareMethodCommon)(), l())
                }), a("TSQualifiedName", {
                    aliases: [
                        "TSEntityName"
                    ],
                    visitor: [
                        "left",
                        "right"
                    ],
                    fields: {
                        left: (0, r.validateType)("TSEntityName"),
                        right: (0, r.validateType)("Identifier")
                    }
                });
                const c = ()=>({
                        typeParameters: (0, r.validateOptionalType)("TSTypeParameterDeclaration"),
                        parameters: (0, r.validateArrayOfType)([
                            "ArrayPattern",
                            "Identifier",
                            "ObjectPattern",
                            "RestElement"
                        ]),
                        typeAnnotation: (0, r.validateOptionalType)("TSTypeAnnotation")
                    }), u = {
                    aliases: [
                        "TSTypeElement"
                    ],
                    visitor: [
                        "typeParameters",
                        "parameters",
                        "typeAnnotation"
                    ],
                    fields: c()
                };
                a("TSCallSignatureDeclaration", u), a("TSConstructSignatureDeclaration", u);
                const p = ()=>({
                        key: (0, r.validateType)("Expression"),
                        computed: {
                            default: !1
                        },
                        optional: (0, r.validateOptional)(o)
                    });
                a("TSPropertySignature", {
                    aliases: [
                        "TSTypeElement"
                    ],
                    visitor: [
                        "key",
                        "typeAnnotation",
                        "initializer"
                    ],
                    fields: Object.assign({}, p(), {
                        readonly: (0, r.validateOptional)(o),
                        typeAnnotation: (0, r.validateOptionalType)("TSTypeAnnotation"),
                        initializer: (0, r.validateOptionalType)("Expression"),
                        kind: {
                            validate: (0, r.assertOneOf)("get", "set")
                        }
                    })
                }), a("TSMethodSignature", {
                    aliases: [
                        "TSTypeElement"
                    ],
                    visitor: [
                        "key",
                        "typeParameters",
                        "parameters",
                        "typeAnnotation"
                    ],
                    fields: Object.assign({}, c(), p(), {
                        kind: {
                            validate: (0, r.assertOneOf)("method", "get", "set")
                        }
                    })
                }), a("TSIndexSignature", {
                    aliases: [
                        "TSTypeElement"
                    ],
                    visitor: [
                        "parameters",
                        "typeAnnotation"
                    ],
                    fields: {
                        readonly: (0, r.validateOptional)(o),
                        static: (0, r.validateOptional)(o),
                        parameters: (0, r.validateArrayOfType)("Identifier"),
                        typeAnnotation: (0, r.validateOptionalType)("TSTypeAnnotation")
                    }
                });
                const h = [
                    "TSAnyKeyword",
                    "TSBooleanKeyword",
                    "TSBigIntKeyword",
                    "TSIntrinsicKeyword",
                    "TSNeverKeyword",
                    "TSNullKeyword",
                    "TSNumberKeyword",
                    "TSObjectKeyword",
                    "TSStringKeyword",
                    "TSSymbolKeyword",
                    "TSUndefinedKeyword",
                    "TSUnknownKeyword",
                    "TSVoidKeyword"
                ];
                for (const e1 of h)a(e1, {
                    aliases: [
                        "TSType",
                        "TSBaseType"
                    ],
                    visitor: [],
                    fields: {}
                });
                a("TSThisType", {
                    aliases: [
                        "TSType",
                        "TSBaseType"
                    ],
                    visitor: [],
                    fields: {}
                });
                const d = {
                    aliases: [
                        "TSType"
                    ],
                    visitor: [
                        "typeParameters",
                        "parameters",
                        "typeAnnotation"
                    ]
                };
                a("TSFunctionType", Object.assign({}, d, {
                    fields: c()
                })), a("TSConstructorType", Object.assign({}, d, {
                    fields: Object.assign({}, c(), {
                        abstract: (0, r.validateOptional)(o)
                    })
                })), a("TSTypeReference", {
                    aliases: [
                        "TSType"
                    ],
                    visitor: [
                        "typeName",
                        "typeParameters"
                    ],
                    fields: {
                        typeName: (0, r.validateType)("TSEntityName"),
                        typeParameters: (0, r.validateOptionalType)("TSTypeParameterInstantiation")
                    }
                }), a("TSTypePredicate", {
                    aliases: [
                        "TSType"
                    ],
                    visitor: [
                        "parameterName",
                        "typeAnnotation"
                    ],
                    builder: [
                        "parameterName",
                        "typeAnnotation",
                        "asserts"
                    ],
                    fields: {
                        parameterName: (0, r.validateType)([
                            "Identifier",
                            "TSThisType"
                        ]),
                        typeAnnotation: (0, r.validateOptionalType)("TSTypeAnnotation"),
                        asserts: (0, r.validateOptional)(o)
                    }
                }), a("TSTypeQuery", {
                    aliases: [
                        "TSType"
                    ],
                    visitor: [
                        "exprName",
                        "typeParameters"
                    ],
                    fields: {
                        exprName: (0, r.validateType)([
                            "TSEntityName",
                            "TSImportType"
                        ]),
                        typeParameters: (0, r.validateOptionalType)("TSTypeParameterInstantiation")
                    }
                }), a("TSTypeLiteral", {
                    aliases: [
                        "TSType"
                    ],
                    visitor: [
                        "members"
                    ],
                    fields: {
                        members: (0, r.validateArrayOfType)("TSTypeElement")
                    }
                }), a("TSArrayType", {
                    aliases: [
                        "TSType"
                    ],
                    visitor: [
                        "elementType"
                    ],
                    fields: {
                        elementType: (0, r.validateType)("TSType")
                    }
                }), a("TSTupleType", {
                    aliases: [
                        "TSType"
                    ],
                    visitor: [
                        "elementTypes"
                    ],
                    fields: {
                        elementTypes: (0, r.validateArrayOfType)([
                            "TSType",
                            "TSNamedTupleMember"
                        ])
                    }
                }), a("TSOptionalType", {
                    aliases: [
                        "TSType"
                    ],
                    visitor: [
                        "typeAnnotation"
                    ],
                    fields: {
                        typeAnnotation: (0, r.validateType)("TSType")
                    }
                }), a("TSRestType", {
                    aliases: [
                        "TSType"
                    ],
                    visitor: [
                        "typeAnnotation"
                    ],
                    fields: {
                        typeAnnotation: (0, r.validateType)("TSType")
                    }
                }), a("TSNamedTupleMember", {
                    visitor: [
                        "label",
                        "elementType"
                    ],
                    builder: [
                        "label",
                        "elementType",
                        "optional"
                    ],
                    fields: {
                        label: (0, r.validateType)("Identifier"),
                        optional: {
                            validate: o,
                            default: !1
                        },
                        elementType: (0, r.validateType)("TSType")
                    }
                });
                const f = {
                    aliases: [
                        "TSType"
                    ],
                    visitor: [
                        "types"
                    ],
                    fields: {
                        types: (0, r.validateArrayOfType)("TSType")
                    }
                };
                a("TSUnionType", f), a("TSIntersectionType", f), a("TSConditionalType", {
                    aliases: [
                        "TSType"
                    ],
                    visitor: [
                        "checkType",
                        "extendsType",
                        "trueType",
                        "falseType"
                    ],
                    fields: {
                        checkType: (0, r.validateType)("TSType"),
                        extendsType: (0, r.validateType)("TSType"),
                        trueType: (0, r.validateType)("TSType"),
                        falseType: (0, r.validateType)("TSType")
                    }
                }), a("TSInferType", {
                    aliases: [
                        "TSType"
                    ],
                    visitor: [
                        "typeParameter"
                    ],
                    fields: {
                        typeParameter: (0, r.validateType)("TSTypeParameter")
                    }
                }), a("TSParenthesizedType", {
                    aliases: [
                        "TSType"
                    ],
                    visitor: [
                        "typeAnnotation"
                    ],
                    fields: {
                        typeAnnotation: (0, r.validateType)("TSType")
                    }
                }), a("TSTypeOperator", {
                    aliases: [
                        "TSType"
                    ],
                    visitor: [
                        "typeAnnotation"
                    ],
                    fields: {
                        operator: (0, r.validate)((0, r.assertValueType)("string")),
                        typeAnnotation: (0, r.validateType)("TSType")
                    }
                }), a("TSIndexedAccessType", {
                    aliases: [
                        "TSType"
                    ],
                    visitor: [
                        "objectType",
                        "indexType"
                    ],
                    fields: {
                        objectType: (0, r.validateType)("TSType"),
                        indexType: (0, r.validateType)("TSType")
                    }
                }), a("TSMappedType", {
                    aliases: [
                        "TSType"
                    ],
                    visitor: [
                        "typeParameter",
                        "typeAnnotation",
                        "nameType"
                    ],
                    fields: {
                        readonly: (0, r.validateOptional)((0, r.assertOneOf)(!0, !1, "+", "-")),
                        typeParameter: (0, r.validateType)("TSTypeParameter"),
                        optional: (0, r.validateOptional)((0, r.assertOneOf)(!0, !1, "+", "-")),
                        typeAnnotation: (0, r.validateOptionalType)("TSType"),
                        nameType: (0, r.validateOptionalType)("TSType")
                    }
                }), a("TSLiteralType", {
                    aliases: [
                        "TSType",
                        "TSBaseType"
                    ],
                    visitor: [
                        "literal"
                    ],
                    fields: {
                        literal: {
                            validate: function() {
                                const e1 = (0, r.assertNodeType)("NumericLiteral", "BigIntLiteral"), t = (0, r.assertOneOf)("-"), n = (0, r.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
                                function i(r, i, a) {
                                    (0, s.default)("UnaryExpression", a) ? (t(a, "operator", a.operator), e1(a, "argument", a.argument)) : n(r, i, a);
                                }
                                return i.oneOfNodeTypes = [
                                    "NumericLiteral",
                                    "StringLiteral",
                                    "BooleanLiteral",
                                    "BigIntLiteral",
                                    "TemplateLiteral",
                                    "UnaryExpression"
                                ], i;
                            }()
                        }
                    }
                }), a("TSExpressionWithTypeArguments", {
                    aliases: [
                        "TSType"
                    ],
                    visitor: [
                        "expression",
                        "typeParameters"
                    ],
                    fields: {
                        expression: (0, r.validateType)("TSEntityName"),
                        typeParameters: (0, r.validateOptionalType)("TSTypeParameterInstantiation")
                    }
                }), a("TSInterfaceDeclaration", {
                    aliases: [
                        "Statement",
                        "Declaration"
                    ],
                    visitor: [
                        "id",
                        "typeParameters",
                        "extends",
                        "body"
                    ],
                    fields: {
                        declare: (0, r.validateOptional)(o),
                        id: (0, r.validateType)("Identifier"),
                        typeParameters: (0, r.validateOptionalType)("TSTypeParameterDeclaration"),
                        extends: (0, r.validateOptional)((0, r.arrayOfType)("TSExpressionWithTypeArguments")),
                        body: (0, r.validateType)("TSInterfaceBody")
                    }
                }), a("TSInterfaceBody", {
                    visitor: [
                        "body"
                    ],
                    fields: {
                        body: (0, r.validateArrayOfType)("TSTypeElement")
                    }
                }), a("TSTypeAliasDeclaration", {
                    aliases: [
                        "Statement",
                        "Declaration"
                    ],
                    visitor: [
                        "id",
                        "typeParameters",
                        "typeAnnotation"
                    ],
                    fields: {
                        declare: (0, r.validateOptional)(o),
                        id: (0, r.validateType)("Identifier"),
                        typeParameters: (0, r.validateOptionalType)("TSTypeParameterDeclaration"),
                        typeAnnotation: (0, r.validateType)("TSType")
                    }
                }), a("TSInstantiationExpression", {
                    aliases: [
                        "Expression"
                    ],
                    visitor: [
                        "expression",
                        "typeParameters"
                    ],
                    fields: {
                        expression: (0, r.validateType)("Expression"),
                        typeParameters: (0, r.validateOptionalType)("TSTypeParameterInstantiation")
                    }
                });
                const y = {
                    aliases: [
                        "Expression",
                        "LVal",
                        "PatternLike"
                    ],
                    visitor: [
                        "expression",
                        "typeAnnotation"
                    ],
                    fields: {
                        expression: (0, r.validateType)("Expression"),
                        typeAnnotation: (0, r.validateType)("TSType")
                    }
                };
                a("TSAsExpression", y), a("TSSatisfiesExpression", y), a("TSTypeAssertion", {
                    aliases: [
                        "Expression",
                        "LVal",
                        "PatternLike"
                    ],
                    visitor: [
                        "typeAnnotation",
                        "expression"
                    ],
                    fields: {
                        typeAnnotation: (0, r.validateType)("TSType"),
                        expression: (0, r.validateType)("Expression")
                    }
                }), a("TSEnumDeclaration", {
                    aliases: [
                        "Statement",
                        "Declaration"
                    ],
                    visitor: [
                        "id",
                        "members"
                    ],
                    fields: {
                        declare: (0, r.validateOptional)(o),
                        const: (0, r.validateOptional)(o),
                        id: (0, r.validateType)("Identifier"),
                        members: (0, r.validateArrayOfType)("TSEnumMember"),
                        initializer: (0, r.validateOptionalType)("Expression")
                    }
                }), a("TSEnumMember", {
                    visitor: [
                        "id",
                        "initializer"
                    ],
                    fields: {
                        id: (0, r.validateType)([
                            "Identifier",
                            "StringLiteral"
                        ]),
                        initializer: (0, r.validateOptionalType)("Expression")
                    }
                }), a("TSModuleDeclaration", {
                    aliases: [
                        "Statement",
                        "Declaration"
                    ],
                    visitor: [
                        "id",
                        "body"
                    ],
                    fields: {
                        declare: (0, r.validateOptional)(o),
                        global: (0, r.validateOptional)(o),
                        id: (0, r.validateType)([
                            "Identifier",
                            "StringLiteral"
                        ]),
                        body: (0, r.validateType)([
                            "TSModuleBlock",
                            "TSModuleDeclaration"
                        ])
                    }
                }), a("TSModuleBlock", {
                    aliases: [
                        "Scopable",
                        "Block",
                        "BlockParent",
                        "FunctionParent"
                    ],
                    visitor: [
                        "body"
                    ],
                    fields: {
                        body: (0, r.validateArrayOfType)("Statement")
                    }
                }), a("TSImportType", {
                    aliases: [
                        "TSType"
                    ],
                    visitor: [
                        "argument",
                        "qualifier",
                        "typeParameters"
                    ],
                    fields: {
                        argument: (0, r.validateType)("StringLiteral"),
                        qualifier: (0, r.validateOptionalType)("TSEntityName"),
                        typeParameters: (0, r.validateOptionalType)("TSTypeParameterInstantiation")
                    }
                }), a("TSImportEqualsDeclaration", {
                    aliases: [
                        "Statement"
                    ],
                    visitor: [
                        "id",
                        "moduleReference"
                    ],
                    fields: {
                        isExport: (0, r.validate)(o),
                        id: (0, r.validateType)("Identifier"),
                        moduleReference: (0, r.validateType)([
                            "TSEntityName",
                            "TSExternalModuleReference"
                        ]),
                        importKind: {
                            validate: (0, r.assertOneOf)("type", "value"),
                            optional: !0
                        }
                    }
                }), a("TSExternalModuleReference", {
                    visitor: [
                        "expression"
                    ],
                    fields: {
                        expression: (0, r.validateType)("StringLiteral")
                    }
                }), a("TSNonNullExpression", {
                    aliases: [
                        "Expression",
                        "LVal",
                        "PatternLike"
                    ],
                    visitor: [
                        "expression"
                    ],
                    fields: {
                        expression: (0, r.validateType)("Expression")
                    }
                }), a("TSExportAssignment", {
                    aliases: [
                        "Statement"
                    ],
                    visitor: [
                        "expression"
                    ],
                    fields: {
                        expression: (0, r.validateType)("Expression")
                    }
                }), a("TSNamespaceExportDeclaration", {
                    aliases: [
                        "Statement"
                    ],
                    visitor: [
                        "id"
                    ],
                    fields: {
                        id: (0, r.validateType)("Identifier")
                    }
                }), a("TSTypeAnnotation", {
                    visitor: [
                        "typeAnnotation"
                    ],
                    fields: {
                        typeAnnotation: {
                            validate: (0, r.assertNodeType)("TSType")
                        }
                    }
                }), a("TSTypeParameterInstantiation", {
                    visitor: [
                        "params"
                    ],
                    fields: {
                        params: {
                            validate: (0, r.chain)((0, r.assertValueType)("array"), (0, r.assertEach)((0, r.assertNodeType)("TSType")))
                        }
                    }
                }), a("TSTypeParameterDeclaration", {
                    visitor: [
                        "params"
                    ],
                    fields: {
                        params: {
                            validate: (0, r.chain)((0, r.assertValueType)("array"), (0, r.assertEach)((0, r.assertNodeType)("TSTypeParameter")))
                        }
                    }
                }), a("TSTypeParameter", {
                    builder: [
                        "constraint",
                        "default",
                        "name"
                    ],
                    visitor: [
                        "constraint",
                        "default"
                    ],
                    fields: {
                        name: {
                            validate: (0, r.assertValueType)("string")
                        },
                        in: {
                            validate: (0, r.assertValueType)("boolean"),
                            optional: !0
                        },
                        out: {
                            validate: (0, r.assertValueType)("boolean"),
                            optional: !0
                        },
                        const: {
                            validate: (0, r.assertValueType)("boolean"),
                            optional: !0
                        },
                        constraint: {
                            validate: (0, r.assertNodeType)("TSType"),
                            optional: !0
                        },
                        default: {
                            validate: (0, r.assertNodeType)("TSType"),
                            optional: !0
                        }
                    }
                });
            },
            1514: (e1, t, n)=>{
                "use strict";
                var r = n(4155);
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.VISITOR_KEYS = t.NODE_PARENT_VALIDATIONS = t.NODE_FIELDS = t.FLIPPED_ALIAS_KEYS = t.DEPRECATED_KEYS = t.BUILDER_KEYS = t.ALIAS_KEYS = void 0, t.arrayOf = m, t.arrayOfType = T, t.assertEach = g, t.assertNodeOrValueType = function(...e1) {
                    function t(t, n, r) {
                        for (const a of e1)if (d(r) === a || (0, i.default)(a, r)) return void (0, s.validateChild)(t, n, r);
                        throw new TypeError(`Property ${n} of ${t.type} expected node to be of a type ${JSON.stringify(e1)} but instead got ${JSON.stringify(null == r ? void 0 : r.type)}`);
                    }
                    return t.oneOfNodeOrValueTypes = e1, t;
                }, t.assertNodeType = b, t.assertOneOf = function(...e1) {
                    function t(t, n, r) {
                        if (e1.indexOf(r) < 0) throw new TypeError(`Property ${n} expected value to be one of ${JSON.stringify(e1)} but got ${JSON.stringify(r)}`);
                    }
                    return t.oneOf = e1, t;
                }, t.assertOptionalChainStart = function() {
                    return function(e1) {
                        var t;
                        let n = e1;
                        for(; e1;){
                            const { type: e1 } = n;
                            if ("OptionalCallExpression" !== e1) {
                                if ("OptionalMemberExpression" !== e1) break;
                                if (n.optional) return;
                                n = n.object;
                            } else {
                                if (n.optional) return;
                                n = n.callee;
                            }
                        }
                        throw new TypeError(`Non-optional ${e1.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${null == (t = n) ? void 0 : t.type}`);
                    };
                }, t.assertShape = function(e1) {
                    function t(t, n, r) {
                        const i = [];
                        for (const n of Object.keys(e1))try {
                            (0, s.validateField)(t, n, r[n], e1[n]);
                        } catch (e1) {
                            if (e1 instanceof TypeError) {
                                i.push(e1.message);
                                continue;
                            }
                            throw e1;
                        }
                        if (i.length) throw new TypeError(`Property ${n} of ${t.type} expected to have the following:\n${i.join("\n")}`);
                    }
                    return t.shapeOf = e1, t;
                }, t.assertValueType = E, t.chain = S, t.default = A, t.defineAliasedType = function(...e1) {
                    return (t, n = {})=>{
                        let r = n.aliases;
                        var i;
                        r || (n.inherits && (r = null == (i = D[n.inherits].aliases) ? void 0 : i.slice()), null != r || (r = []), n.aliases = r);
                        const s = e1.filter((e1)=>!r.includes(e1));
                        r.unshift(...s), A(t, n);
                    };
                }, t.typeIs = y, t.validate = f, t.validateArrayOfType = function(e1) {
                    return f(T(e1));
                }, t.validateOptional = function(e1) {
                    return {
                        validate: e1,
                        optional: !0
                    };
                }, t.validateOptionalType = function(e1) {
                    return {
                        validate: y(e1),
                        optional: !0
                    };
                }, t.validateType = function(e1) {
                    return f(y(e1));
                };
                var i = n(5171), s = n(7750);
                const a = {};
                t.VISITOR_KEYS = a;
                const o = {};
                t.ALIAS_KEYS = o;
                const l = {};
                t.FLIPPED_ALIAS_KEYS = l;
                const c = {};
                t.NODE_FIELDS = c;
                const u = {};
                t.BUILDER_KEYS = u;
                const p = {};
                t.DEPRECATED_KEYS = p;
                const h = {};
                function d(e1) {
                    return Array.isArray(e1) ? "array" : null === e1 ? "null" : typeof e1;
                }
                function f(e1) {
                    return {
                        validate: e1
                    };
                }
                function y(e1) {
                    return "string" == typeof e1 ? b(e1) : b(...e1);
                }
                function m(e1) {
                    return S(E("array"), g(e1));
                }
                function T(e1) {
                    return m(y(e1));
                }
                function g(e1) {
                    function t(t, n, i) {
                        if (Array.isArray(i)) for(let a = 0; a < i.length; a++){
                            const o = `${n}[${a}]`, l = i[a];
                            e1(t, o, l), r.env.BABEL_TYPES_8_BREAKING && (0, s.validateChild)(t, o, l);
                        }
                    }
                    return t.each = e1, t;
                }
                function b(...e1) {
                    function t(t, n, r) {
                        for (const a of e1)if ((0, i.default)(a, r)) return void (0, s.validateChild)(t, n, r);
                        throw new TypeError(`Property ${n} of ${t.type} expected node to be of a type ${JSON.stringify(e1)} but instead got ${JSON.stringify(null == r ? void 0 : r.type)}`);
                    }
                    return t.oneOfNodeTypes = e1, t;
                }
                function E(e1) {
                    function t(t, n, r) {
                        if (d(r) !== e1) throw new TypeError(`Property ${n} expected type of ${e1} but got ${d(r)}`);
                    }
                    return t.type = e1, t;
                }
                function S(...e1) {
                    function t(...t1) {
                        for (const n of e1)n(...t1);
                    }
                    if (t.chainOf = e1, e1.length >= 2 && "type" in e1[0] && "array" === e1[0].type && !("each" in e1[1])) throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
                    return t;
                }
                t.NODE_PARENT_VALIDATIONS = h;
                const P = [
                    "aliases",
                    "builder",
                    "deprecatedAlias",
                    "fields",
                    "inherits",
                    "visitor",
                    "validate"
                ], x = [
                    "default",
                    "optional",
                    "deprecated",
                    "validate"
                ], D = {};
                function A(e1, t = {}) {
                    const n = t.inherits && D[t.inherits] || {};
                    let r = t.fields;
                    if (!r && (r = {}, n.fields)) {
                        const e1 = Object.getOwnPropertyNames(n.fields);
                        for (const t of e1){
                            const e1 = n.fields[t], i = e1.default;
                            if (Array.isArray(i) ? i.length > 0 : i && "object" == typeof i) throw new Error("field defaults can only be primitives or empty arrays currently");
                            r[t] = {
                                default: Array.isArray(i) ? [] : i,
                                optional: e1.optional,
                                deprecated: e1.deprecated,
                                validate: e1.validate
                            };
                        }
                    }
                    const i = t.visitor || n.visitor || [], s = t.aliases || n.aliases || [], f = t.builder || n.builder || t.visitor || [];
                    for (const n of Object.keys(t))if (-1 === P.indexOf(n)) throw new Error(`Unknown type option "${n}" on ${e1}`);
                    t.deprecatedAlias && (p[t.deprecatedAlias] = e1);
                    for (const e1 of i.concat(f))r[e1] = r[e1] || {};
                    for (const t of Object.keys(r)){
                        const n = r[t];
                        void 0 !== n.default && -1 === f.indexOf(t) && (n.optional = !0), void 0 === n.default ? n.default = null : n.validate || null == n.default || (n.validate = E(d(n.default)));
                        for (const r of Object.keys(n))if (-1 === x.indexOf(r)) throw new Error(`Unknown field key "${r}" on ${e1}.${t}`);
                    }
                    a[e1] = t.visitor = i, u[e1] = t.builder = f, c[e1] = t.fields = r, o[e1] = t.aliases = s, s.forEach((t)=>{
                        l[t] = l[t] || [], l[t].push(e1);
                    }), t.validate && (h[e1] = t.validate), D[e1] = t;
                }
            },
            6067: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var r = {
                    react: !0,
                    assertNode: !0,
                    createTypeAnnotationBasedOnTypeof: !0,
                    createUnionTypeAnnotation: !0,
                    createFlowUnionType: !0,
                    createTSUnionType: !0,
                    cloneNode: !0,
                    clone: !0,
                    cloneDeep: !0,
                    cloneDeepWithoutLoc: !0,
                    cloneWithoutLoc: !0,
                    addComment: !0,
                    addComments: !0,
                    inheritInnerComments: !0,
                    inheritLeadingComments: !0,
                    inheritsComments: !0,
                    inheritTrailingComments: !0,
                    removeComments: !0,
                    ensureBlock: !0,
                    toBindingIdentifierName: !0,
                    toBlock: !0,
                    toComputedKey: !0,
                    toExpression: !0,
                    toIdentifier: !0,
                    toKeyAlias: !0,
                    toSequenceExpression: !0,
                    toStatement: !0,
                    valueToNode: !0,
                    appendToMemberExpression: !0,
                    inherits: !0,
                    prependToMemberExpression: !0,
                    removeProperties: !0,
                    removePropertiesDeep: !0,
                    removeTypeDuplicates: !0,
                    getBindingIdentifiers: !0,
                    getOuterBindingIdentifiers: !0,
                    traverse: !0,
                    traverseFast: !0,
                    shallowEqual: !0,
                    is: !0,
                    isBinding: !0,
                    isBlockScoped: !0,
                    isImmutable: !0,
                    isLet: !0,
                    isNode: !0,
                    isNodesEquivalent: !0,
                    isPlaceholderType: !0,
                    isReferenced: !0,
                    isScope: !0,
                    isSpecifierDefault: !0,
                    isType: !0,
                    isValidES3Identifier: !0,
                    isValidIdentifier: !0,
                    isVar: !0,
                    matchesPattern: !0,
                    validate: !0,
                    buildMatchMemberExpression: !0,
                    __internal__deprecationWarning: !0
                };
                Object.defineProperty(t, "__internal__deprecationWarning", {
                    enumerable: !0,
                    get: function() {
                        return ye.default;
                    }
                }), Object.defineProperty(t, "addComment", {
                    enumerable: !0,
                    get: function() {
                        return b.default;
                    }
                }), Object.defineProperty(t, "addComments", {
                    enumerable: !0,
                    get: function() {
                        return E.default;
                    }
                }), Object.defineProperty(t, "appendToMemberExpression", {
                    enumerable: !0,
                    get: function() {
                        return R.default;
                    }
                }), Object.defineProperty(t, "assertNode", {
                    enumerable: !0,
                    get: function() {
                        return o.default;
                    }
                }), Object.defineProperty(t, "buildMatchMemberExpression", {
                    enumerable: !0,
                    get: function() {
                        return de.default;
                    }
                }), Object.defineProperty(t, "clone", {
                    enumerable: !0,
                    get: function() {
                        return y.default;
                    }
                }), Object.defineProperty(t, "cloneDeep", {
                    enumerable: !0,
                    get: function() {
                        return m.default;
                    }
                }), Object.defineProperty(t, "cloneDeepWithoutLoc", {
                    enumerable: !0,
                    get: function() {
                        return T.default;
                    }
                }), Object.defineProperty(t, "cloneNode", {
                    enumerable: !0,
                    get: function() {
                        return f.default;
                    }
                }), Object.defineProperty(t, "cloneWithoutLoc", {
                    enumerable: !0,
                    get: function() {
                        return g.default;
                    }
                }), Object.defineProperty(t, "createFlowUnionType", {
                    enumerable: !0,
                    get: function() {
                        return u.default;
                    }
                }), Object.defineProperty(t, "createTSUnionType", {
                    enumerable: !0,
                    get: function() {
                        return p.default;
                    }
                }), Object.defineProperty(t, "createTypeAnnotationBasedOnTypeof", {
                    enumerable: !0,
                    get: function() {
                        return c.default;
                    }
                }), Object.defineProperty(t, "createUnionTypeAnnotation", {
                    enumerable: !0,
                    get: function() {
                        return u.default;
                    }
                }), Object.defineProperty(t, "ensureBlock", {
                    enumerable: !0,
                    get: function() {
                        return w.default;
                    }
                }), Object.defineProperty(t, "getBindingIdentifiers", {
                    enumerable: !0,
                    get: function() {
                        return Y.default;
                    }
                }), Object.defineProperty(t, "getOuterBindingIdentifiers", {
                    enumerable: !0,
                    get: function() {
                        return q.default;
                    }
                }), Object.defineProperty(t, "inheritInnerComments", {
                    enumerable: !0,
                    get: function() {
                        return S.default;
                    }
                }), Object.defineProperty(t, "inheritLeadingComments", {
                    enumerable: !0,
                    get: function() {
                        return P.default;
                    }
                }), Object.defineProperty(t, "inheritTrailingComments", {
                    enumerable: !0,
                    get: function() {
                        return D.default;
                    }
                }), Object.defineProperty(t, "inherits", {
                    enumerable: !0,
                    get: function() {
                        return U.default;
                    }
                }), Object.defineProperty(t, "inheritsComments", {
                    enumerable: !0,
                    get: function() {
                        return x.default;
                    }
                }), Object.defineProperty(t, "is", {
                    enumerable: !0,
                    get: function() {
                        return G.default;
                    }
                }), Object.defineProperty(t, "isBinding", {
                    enumerable: !0,
                    get: function() {
                        return z.default;
                    }
                }), Object.defineProperty(t, "isBlockScoped", {
                    enumerable: !0,
                    get: function() {
                        return Q.default;
                    }
                }), Object.defineProperty(t, "isImmutable", {
                    enumerable: !0,
                    get: function() {
                        return Z.default;
                    }
                }), Object.defineProperty(t, "isLet", {
                    enumerable: !0,
                    get: function() {
                        return ee.default;
                    }
                }), Object.defineProperty(t, "isNode", {
                    enumerable: !0,
                    get: function() {
                        return te.default;
                    }
                }), Object.defineProperty(t, "isNodesEquivalent", {
                    enumerable: !0,
                    get: function() {
                        return ne.default;
                    }
                }), Object.defineProperty(t, "isPlaceholderType", {
                    enumerable: !0,
                    get: function() {
                        return re.default;
                    }
                }), Object.defineProperty(t, "isReferenced", {
                    enumerable: !0,
                    get: function() {
                        return ie.default;
                    }
                }), Object.defineProperty(t, "isScope", {
                    enumerable: !0,
                    get: function() {
                        return se.default;
                    }
                }), Object.defineProperty(t, "isSpecifierDefault", {
                    enumerable: !0,
                    get: function() {
                        return ae.default;
                    }
                }), Object.defineProperty(t, "isType", {
                    enumerable: !0,
                    get: function() {
                        return oe.default;
                    }
                }), Object.defineProperty(t, "isValidES3Identifier", {
                    enumerable: !0,
                    get: function() {
                        return le.default;
                    }
                }), Object.defineProperty(t, "isValidIdentifier", {
                    enumerable: !0,
                    get: function() {
                        return ce.default;
                    }
                }), Object.defineProperty(t, "isVar", {
                    enumerable: !0,
                    get: function() {
                        return ue.default;
                    }
                }), Object.defineProperty(t, "matchesPattern", {
                    enumerable: !0,
                    get: function() {
                        return pe.default;
                    }
                }), Object.defineProperty(t, "prependToMemberExpression", {
                    enumerable: !0,
                    get: function() {
                        return V.default;
                    }
                }), t.react = void 0, Object.defineProperty(t, "removeComments", {
                    enumerable: !0,
                    get: function() {
                        return A.default;
                    }
                }), Object.defineProperty(t, "removeProperties", {
                    enumerable: !0,
                    get: function() {
                        return K.default;
                    }
                }), Object.defineProperty(t, "removePropertiesDeep", {
                    enumerable: !0,
                    get: function() {
                        return W.default;
                    }
                }), Object.defineProperty(t, "removeTypeDuplicates", {
                    enumerable: !0,
                    get: function() {
                        return X.default;
                    }
                }), Object.defineProperty(t, "shallowEqual", {
                    enumerable: !0,
                    get: function() {
                        return $.default;
                    }
                }), Object.defineProperty(t, "toBindingIdentifierName", {
                    enumerable: !0,
                    get: function() {
                        return O.default;
                    }
                }), Object.defineProperty(t, "toBlock", {
                    enumerable: !0,
                    get: function() {
                        return I.default;
                    }
                }), Object.defineProperty(t, "toComputedKey", {
                    enumerable: !0,
                    get: function() {
                        return N.default;
                    }
                }), Object.defineProperty(t, "toExpression", {
                    enumerable: !0,
                    get: function() {
                        return F.default;
                    }
                }), Object.defineProperty(t, "toIdentifier", {
                    enumerable: !0,
                    get: function() {
                        return k.default;
                    }
                }), Object.defineProperty(t, "toKeyAlias", {
                    enumerable: !0,
                    get: function() {
                        return L.default;
                    }
                }), Object.defineProperty(t, "toSequenceExpression", {
                    enumerable: !0,
                    get: function() {
                        return _.default;
                    }
                }), Object.defineProperty(t, "toStatement", {
                    enumerable: !0,
                    get: function() {
                        return M.default;
                    }
                }), Object.defineProperty(t, "traverse", {
                    enumerable: !0,
                    get: function() {
                        return H.default;
                    }
                }), Object.defineProperty(t, "traverseFast", {
                    enumerable: !0,
                    get: function() {
                        return J.default;
                    }
                }), Object.defineProperty(t, "validate", {
                    enumerable: !0,
                    get: function() {
                        return he.default;
                    }
                }), Object.defineProperty(t, "valueToNode", {
                    enumerable: !0,
                    get: function() {
                        return B.default;
                    }
                });
                var i = n(4229), s = n(9733), a = n(4225), o = n(391), l = n(163);
                Object.keys(l).forEach(function(e1) {
                    "default" !== e1 && "__esModule" !== e1 && (Object.prototype.hasOwnProperty.call(r, e1) || e1 in t && t[e1] === l[e1] || Object.defineProperty(t, e1, {
                        enumerable: !0,
                        get: function() {
                            return l[e1];
                        }
                    }));
                });
                var c = n(5976), u = n(7625), p = n(6752), h = n(1411);
                Object.keys(h).forEach(function(e1) {
                    "default" !== e1 && "__esModule" !== e1 && (Object.prototype.hasOwnProperty.call(r, e1) || e1 in t && t[e1] === h[e1] || Object.defineProperty(t, e1, {
                        enumerable: !0,
                        get: function() {
                            return h[e1];
                        }
                    }));
                });
                var d = n(9470);
                Object.keys(d).forEach(function(e1) {
                    "default" !== e1 && "__esModule" !== e1 && (Object.prototype.hasOwnProperty.call(r, e1) || e1 in t && t[e1] === d[e1] || Object.defineProperty(t, e1, {
                        enumerable: !0,
                        get: function() {
                            return d[e1];
                        }
                    }));
                });
                var f = n(2419), y = n(8229), m = n(8030), T = n(8519), g = n(9381), b = n(109), E = n(8647), S = n(2823), P = n(8930), x = n(9134), D = n(2714), A = n(698), v = n(4998);
                Object.keys(v).forEach(function(e1) {
                    "default" !== e1 && "__esModule" !== e1 && (Object.prototype.hasOwnProperty.call(r, e1) || e1 in t && t[e1] === v[e1] || Object.defineProperty(t, e1, {
                        enumerable: !0,
                        get: function() {
                            return v[e1];
                        }
                    }));
                });
                var C = n(3725);
                Object.keys(C).forEach(function(e1) {
                    "default" !== e1 && "__esModule" !== e1 && (Object.prototype.hasOwnProperty.call(r, e1) || e1 in t && t[e1] === C[e1] || Object.defineProperty(t, e1, {
                        enumerable: !0,
                        get: function() {
                            return C[e1];
                        }
                    }));
                });
                var w = n(8560), O = n(5200), I = n(9988), N = n(3816), F = n(5317), k = n(7885), L = n(5046), _ = n(2473), M = n(350), B = n(1382), j = n(1678);
                Object.keys(j).forEach(function(e1) {
                    "default" !== e1 && "__esModule" !== e1 && (Object.prototype.hasOwnProperty.call(r, e1) || e1 in t && t[e1] === j[e1] || Object.defineProperty(t, e1, {
                        enumerable: !0,
                        get: function() {
                            return j[e1];
                        }
                    }));
                });
                var R = n(2115), U = n(4151), V = n(2369), K = n(7665), W = n(857), X = n(8874), Y = n(984), q = n(179), H = n(9787);
                Object.keys(H).forEach(function(e1) {
                    "default" !== e1 && "__esModule" !== e1 && (Object.prototype.hasOwnProperty.call(r, e1) || e1 in t && t[e1] === H[e1] || Object.defineProperty(t, e1, {
                        enumerable: !0,
                        get: function() {
                            return H[e1];
                        }
                    }));
                });
                var J = n(5139), $ = n(9960), G = n(5171), z = n(8443), Q = n(964), Z = n(1689), ee = n(3066), te = n(4814), ne = n(7997), re = n(8894), ie = n(3683), se = n(2126), ae = n(8691), oe = n(5179), le = n(7879), ce = n(5820), ue = n(3358), pe = n(2693), he = n(7750), de = n(2051), fe = n(9869);
                Object.keys(fe).forEach(function(e1) {
                    "default" !== e1 && "__esModule" !== e1 && (Object.prototype.hasOwnProperty.call(r, e1) || e1 in t && t[e1] === fe[e1] || Object.defineProperty(t, e1, {
                        enumerable: !0,
                        get: function() {
                            return fe[e1];
                        }
                    }));
                });
                var ye = n(4619);
                const me = {
                    isReactComponent: i.default,
                    isCompatTag: s.default,
                    buildChildren: a.default
                };
                t.react = me;
            },
            2115: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t, n = !1) {
                    return e1.object = (0, r.memberExpression)(e1.object, e1.property, e1.computed), e1.property = t, e1.computed = !!n, e1;
                };
                var r = n(1411);
            },
            8874: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function e1(t) {
                    const n = Array.from(t), s = new Map, a = new Map, o = new Set, l = [];
                    for(let t = 0; t < n.length; t++){
                        const c = n[t];
                        if (c && !(l.indexOf(c) >= 0)) {
                            if ((0, r.isAnyTypeAnnotation)(c)) return [
                                c
                            ];
                            if ((0, r.isFlowBaseAnnotation)(c)) a.set(c.type, c);
                            else if ((0, r.isUnionTypeAnnotation)(c)) o.has(c.types) || (n.push(...c.types), o.add(c.types));
                            else if ((0, r.isGenericTypeAnnotation)(c)) {
                                const t = i(c.id);
                                if (s.has(t)) {
                                    let n = s.get(t);
                                    n.typeParameters ? c.typeParameters && (n.typeParameters.params.push(...c.typeParameters.params), n.typeParameters.params = e1(n.typeParameters.params)) : n = c.typeParameters;
                                } else s.set(t, c);
                            } else l.push(c);
                        }
                    }
                    for (const [, e1] of a)l.push(e1);
                    for (const [, e1] of s)l.push(e1);
                    return l;
                };
                var r = n(9869);
                function i(e1) {
                    return (0, r.isIdentifier)(e1) ? e1.name : `${e1.id.name}.${i(e1.qualification)}`;
                }
            },
            4151: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t) {
                    if (!e1 || !t) return e1;
                    for (const n of r.INHERIT_KEYS.optional)null == e1[n] && (e1[n] = t[n]);
                    for (const n of Object.keys(t))"_" === n[0] && "__clone" !== n && (e1[n] = t[n]);
                    for (const n of r.INHERIT_KEYS.force)e1[n] = t[n];
                    return (0, i.default)(e1, t), e1;
                };
                var r = n(3725), i = n(9134);
            },
            2369: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t) {
                    if ((0, i.isSuper)(e1.object)) throw new Error("Cannot prepend node to super property access (`super.foo`).");
                    return e1.object = (0, r.memberExpression)(t, e1.object), e1;
                };
                var r = n(1411), i = n(6067);
            },
            7665: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t = {}) {
                    const n = t.preserveComments ? i : s;
                    for (const t of n)null != e1[t] && (e1[t] = void 0);
                    for (const t of Object.keys(e1))"_" === t[0] && null != e1[t] && (e1[t] = void 0);
                    const r = Object.getOwnPropertySymbols(e1);
                    for (const t of r)e1[t] = null;
                };
                var r = n(3725);
                const i = [
                    "tokens",
                    "start",
                    "end",
                    "loc",
                    "raw",
                    "rawValue"
                ], s = [
                    ...r.COMMENT_KEYS,
                    "comments",
                    ...i
                ];
            },
            857: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t) {
                    return (0, r.default)(e1, i.default, t), e1;
                };
                var r = n(5139), i = n(7665);
            },
            2819: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function e1(t) {
                    const n = Array.from(t), s = new Map, a = new Map, o = new Set, l = [];
                    for(let t = 0; t < n.length; t++){
                        const c = n[t];
                        if (c && !(l.indexOf(c) >= 0)) {
                            if ((0, r.isTSAnyKeyword)(c)) return [
                                c
                            ];
                            if ((0, r.isTSBaseType)(c)) a.set(c.type, c);
                            else if ((0, r.isTSUnionType)(c)) o.has(c.types) || (n.push(...c.types), o.add(c.types));
                            else if ((0, r.isTSTypeReference)(c) && c.typeParameters) {
                                const t = i(c.typeName);
                                if (s.has(t)) {
                                    let n = s.get(t);
                                    n.typeParameters ? c.typeParameters && (n.typeParameters.params.push(...c.typeParameters.params), n.typeParameters.params = e1(n.typeParameters.params)) : n = c.typeParameters;
                                } else s.set(t, c);
                            } else l.push(c);
                        }
                    }
                    for (const [, e1] of a)l.push(e1);
                    for (const [, e1] of s)l.push(e1);
                    return l;
                };
                var r = n(9869);
                function i(e1) {
                    return (0, r.isIdentifier)(e1) ? e1.name : `${e1.right.name}.${i(e1.left)}`;
                }
            },
            984: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = i;
                var r = n(9869);
                function i(e1, t, n) {
                    const s = [].concat(e1), a = Object.create(null);
                    for(; s.length;){
                        const e1 = s.shift();
                        if (!e1) continue;
                        const o = i.keys[e1.type];
                        if ((0, r.isIdentifier)(e1)) t ? (a[e1.name] = a[e1.name] || []).push(e1) : a[e1.name] = e1;
                        else if (!(0, r.isExportDeclaration)(e1) || (0, r.isExportAllDeclaration)(e1)) {
                            if (n) {
                                if ((0, r.isFunctionDeclaration)(e1)) {
                                    s.push(e1.id);
                                    continue;
                                }
                                if ((0, r.isFunctionExpression)(e1)) continue;
                            }
                            if (o) for(let t = 0; t < o.length; t++){
                                const n = e1[o[t]];
                                n && (Array.isArray(n) ? s.push(...n) : s.push(n));
                            }
                        } else (0, r.isDeclaration)(e1.declaration) && s.push(e1.declaration);
                    }
                    return a;
                }
                i.keys = {
                    DeclareClass: [
                        "id"
                    ],
                    DeclareFunction: [
                        "id"
                    ],
                    DeclareModule: [
                        "id"
                    ],
                    DeclareVariable: [
                        "id"
                    ],
                    DeclareInterface: [
                        "id"
                    ],
                    DeclareTypeAlias: [
                        "id"
                    ],
                    DeclareOpaqueType: [
                        "id"
                    ],
                    InterfaceDeclaration: [
                        "id"
                    ],
                    TypeAlias: [
                        "id"
                    ],
                    OpaqueType: [
                        "id"
                    ],
                    CatchClause: [
                        "param"
                    ],
                    LabeledStatement: [
                        "label"
                    ],
                    UnaryExpression: [
                        "argument"
                    ],
                    AssignmentExpression: [
                        "left"
                    ],
                    ImportSpecifier: [
                        "local"
                    ],
                    ImportNamespaceSpecifier: [
                        "local"
                    ],
                    ImportDefaultSpecifier: [
                        "local"
                    ],
                    ImportDeclaration: [
                        "specifiers"
                    ],
                    ExportSpecifier: [
                        "exported"
                    ],
                    ExportNamespaceSpecifier: [
                        "exported"
                    ],
                    ExportDefaultSpecifier: [
                        "exported"
                    ],
                    FunctionDeclaration: [
                        "id",
                        "params"
                    ],
                    FunctionExpression: [
                        "id",
                        "params"
                    ],
                    ArrowFunctionExpression: [
                        "params"
                    ],
                    ObjectMethod: [
                        "params"
                    ],
                    ClassMethod: [
                        "params"
                    ],
                    ClassPrivateMethod: [
                        "params"
                    ],
                    ForInStatement: [
                        "left"
                    ],
                    ForOfStatement: [
                        "left"
                    ],
                    ClassDeclaration: [
                        "id"
                    ],
                    ClassExpression: [
                        "id"
                    ],
                    RestElement: [
                        "argument"
                    ],
                    UpdateExpression: [
                        "argument"
                    ],
                    ObjectProperty: [
                        "value"
                    ],
                    AssignmentPattern: [
                        "left"
                    ],
                    ArrayPattern: [
                        "elements"
                    ],
                    ObjectPattern: [
                        "properties"
                    ],
                    VariableDeclaration: [
                        "declarations"
                    ],
                    VariableDeclarator: [
                        "id"
                    ]
                };
            },
            179: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var r = n(984);
                t.default = function(e1, t) {
                    return (0, r.default)(e1, t, !0);
                };
            },
            9787: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t, n) {
                    "function" == typeof t && (t = {
                        enter: t
                    });
                    const { enter: r, exit: s } = t;
                    i(e1, r, s, n, []);
                };
                var r = n(1678);
                function i(e1, t, n, s, a) {
                    const o = r.VISITOR_KEYS[e1.type];
                    if (o) {
                        t && t(e1, a, s);
                        for (const r of o){
                            const o = e1[r];
                            if (Array.isArray(o)) for(let l = 0; l < o.length; l++){
                                const c = o[l];
                                c && (a.push({
                                    node: e1,
                                    key: r,
                                    index: l
                                }), i(c, t, n, s, a), a.pop());
                            }
                            else o && (a.push({
                                node: e1,
                                key: r
                            }), i(o, t, n, s, a), a.pop());
                        }
                        n && n(e1, a, s);
                    }
                }
            },
            5139: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function e1(t, n, i) {
                    if (!t) return;
                    const s = r.VISITOR_KEYS[t.type];
                    if (s) {
                        n(t, i = i || {});
                        for (const r of s){
                            const s = t[r];
                            if (Array.isArray(s)) for (const t of s)e1(t, n, i);
                            else e1(s, n, i);
                        }
                    }
                };
                var r = n(1678);
            },
            4619: (e1, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t, r = "") {
                    if (n.has(e1)) return;
                    n.add(e1);
                    const { internal: i, trace: s } = function(e1, t) {
                        const { stackTraceLimit: n, prepareStackTrace: r } = Error;
                        let i;
                        if (Error.stackTraceLimit = 4, Error.prepareStackTrace = function(e1, t) {
                            i = t;
                        }, (new Error).stack, Error.stackTraceLimit = n, Error.prepareStackTrace = r, !i) return {
                            internal: !1,
                            trace: ""
                        };
                        const s = i.slice(2, 4);
                        return {
                            internal: /[\\/]@babel[\\/]/.test(s[1].getFileName()),
                            trace: s.map((e1)=>`    at ${e1}`).join("\n")
                        };
                    }();
                    i || console.warn(`${r}\`${e1}\` has been deprecated, please migrate to \`${t}\`\n${s}`);
                };
                const n = new Set;
            },
            9906: (e1, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t, n) {
                    t && n && (t[e1] = Array.from(new Set([].concat(t[e1], n[e1]).filter(Boolean))));
                };
            },
            8730: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t) {
                    const n = e1.value.split(/\r\n|\n|\r/);
                    let s = 0;
                    for(let e1 = 0; e1 < n.length; e1++)n[e1].match(/[^ \t]/) && (s = e1);
                    let a = "";
                    for(let e1 = 0; e1 < n.length; e1++){
                        const t = n[e1], r = 0 === e1, i = e1 === n.length - 1, o = e1 === s;
                        let l = t.replace(/\t/g, " ");
                        r || (l = l.replace(/^[ ]+/, "")), i || (l = l.replace(/[ ]+$/, "")), l && (o || (l += " "), a += l);
                    }
                    a && t.push((0, i.inherits)((0, r.stringLiteral)(a), e1));
                };
                var r = n(1411), i = n(6067);
            },
            9960: (e1, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t) {
                    const n = Object.keys(t);
                    for (const r of n)if (e1[r] !== t[r]) return !1;
                    return !0;
                };
            },
            2051: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t) {
                    const n = e1.split(".");
                    return (e1)=>(0, r.default)(e1, n, t);
                };
                var r = n(2693);
            },
            9869: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.isAccessor = function(e1, t) {
                    return !!e1 && "ClassAccessorProperty" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isAnyTypeAnnotation = function(e1, t) {
                    return !!e1 && "AnyTypeAnnotation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isArgumentPlaceholder = function(e1, t) {
                    return !!e1 && "ArgumentPlaceholder" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isArrayExpression = function(e1, t) {
                    return !!e1 && "ArrayExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isArrayPattern = function(e1, t) {
                    return !!e1 && "ArrayPattern" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isArrayTypeAnnotation = function(e1, t) {
                    return !!e1 && "ArrayTypeAnnotation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isArrowFunctionExpression = function(e1, t) {
                    return !!e1 && "ArrowFunctionExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isAssignmentExpression = function(e1, t) {
                    return !!e1 && "AssignmentExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isAssignmentPattern = function(e1, t) {
                    return !!e1 && "AssignmentPattern" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isAwaitExpression = function(e1, t) {
                    return !!e1 && "AwaitExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isBigIntLiteral = function(e1, t) {
                    return !!e1 && "BigIntLiteral" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isBinary = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "BinaryExpression":
                        case "LogicalExpression":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isBinaryExpression = function(e1, t) {
                    return !!e1 && "BinaryExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isBindExpression = function(e1, t) {
                    return !!e1 && "BindExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isBlock = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "BlockStatement":
                        case "Program":
                        case "TSModuleBlock":
                            break;
                        case "Placeholder":
                            if ("BlockStatement" === e1.expectedNode) break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isBlockParent = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "BlockStatement":
                        case "CatchClause":
                        case "DoWhileStatement":
                        case "ForInStatement":
                        case "ForStatement":
                        case "FunctionDeclaration":
                        case "FunctionExpression":
                        case "Program":
                        case "ObjectMethod":
                        case "SwitchStatement":
                        case "WhileStatement":
                        case "ArrowFunctionExpression":
                        case "ForOfStatement":
                        case "ClassMethod":
                        case "ClassPrivateMethod":
                        case "StaticBlock":
                        case "TSModuleBlock":
                            break;
                        case "Placeholder":
                            if ("BlockStatement" === e1.expectedNode) break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isBlockStatement = function(e1, t) {
                    return !!e1 && "BlockStatement" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isBooleanLiteral = function(e1, t) {
                    return !!e1 && "BooleanLiteral" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isBooleanLiteralTypeAnnotation = function(e1, t) {
                    return !!e1 && "BooleanLiteralTypeAnnotation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isBooleanTypeAnnotation = function(e1, t) {
                    return !!e1 && "BooleanTypeAnnotation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isBreakStatement = function(e1, t) {
                    return !!e1 && "BreakStatement" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isCallExpression = function(e1, t) {
                    return !!e1 && "CallExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isCatchClause = function(e1, t) {
                    return !!e1 && "CatchClause" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isClass = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "ClassExpression":
                        case "ClassDeclaration":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isClassAccessorProperty = function(e1, t) {
                    return !!e1 && "ClassAccessorProperty" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isClassBody = function(e1, t) {
                    return !!e1 && "ClassBody" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isClassDeclaration = function(e1, t) {
                    return !!e1 && "ClassDeclaration" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isClassExpression = function(e1, t) {
                    return !!e1 && "ClassExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isClassImplements = function(e1, t) {
                    return !!e1 && "ClassImplements" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isClassMethod = function(e1, t) {
                    return !!e1 && "ClassMethod" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isClassPrivateMethod = function(e1, t) {
                    return !!e1 && "ClassPrivateMethod" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isClassPrivateProperty = function(e1, t) {
                    return !!e1 && "ClassPrivateProperty" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isClassProperty = function(e1, t) {
                    return !!e1 && "ClassProperty" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isCompletionStatement = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "BreakStatement":
                        case "ContinueStatement":
                        case "ReturnStatement":
                        case "ThrowStatement":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isConditional = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "ConditionalExpression":
                        case "IfStatement":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isConditionalExpression = function(e1, t) {
                    return !!e1 && "ConditionalExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isContinueStatement = function(e1, t) {
                    return !!e1 && "ContinueStatement" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isDebuggerStatement = function(e1, t) {
                    return !!e1 && "DebuggerStatement" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isDecimalLiteral = function(e1, t) {
                    return !!e1 && "DecimalLiteral" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isDeclaration = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "FunctionDeclaration":
                        case "VariableDeclaration":
                        case "ClassDeclaration":
                        case "ExportAllDeclaration":
                        case "ExportDefaultDeclaration":
                        case "ExportNamedDeclaration":
                        case "ImportDeclaration":
                        case "DeclareClass":
                        case "DeclareFunction":
                        case "DeclareInterface":
                        case "DeclareModule":
                        case "DeclareModuleExports":
                        case "DeclareTypeAlias":
                        case "DeclareOpaqueType":
                        case "DeclareVariable":
                        case "DeclareExportDeclaration":
                        case "DeclareExportAllDeclaration":
                        case "InterfaceDeclaration":
                        case "OpaqueType":
                        case "TypeAlias":
                        case "EnumDeclaration":
                        case "TSDeclareFunction":
                        case "TSInterfaceDeclaration":
                        case "TSTypeAliasDeclaration":
                        case "TSEnumDeclaration":
                        case "TSModuleDeclaration":
                            break;
                        case "Placeholder":
                            if ("Declaration" === e1.expectedNode) break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isDeclareClass = function(e1, t) {
                    return !!e1 && "DeclareClass" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isDeclareExportAllDeclaration = function(e1, t) {
                    return !!e1 && "DeclareExportAllDeclaration" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isDeclareExportDeclaration = function(e1, t) {
                    return !!e1 && "DeclareExportDeclaration" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isDeclareFunction = function(e1, t) {
                    return !!e1 && "DeclareFunction" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isDeclareInterface = function(e1, t) {
                    return !!e1 && "DeclareInterface" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isDeclareModule = function(e1, t) {
                    return !!e1 && "DeclareModule" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isDeclareModuleExports = function(e1, t) {
                    return !!e1 && "DeclareModuleExports" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isDeclareOpaqueType = function(e1, t) {
                    return !!e1 && "DeclareOpaqueType" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isDeclareTypeAlias = function(e1, t) {
                    return !!e1 && "DeclareTypeAlias" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isDeclareVariable = function(e1, t) {
                    return !!e1 && "DeclareVariable" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isDeclaredPredicate = function(e1, t) {
                    return !!e1 && "DeclaredPredicate" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isDecorator = function(e1, t) {
                    return !!e1 && "Decorator" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isDirective = function(e1, t) {
                    return !!e1 && "Directive" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isDirectiveLiteral = function(e1, t) {
                    return !!e1 && "DirectiveLiteral" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isDoExpression = function(e1, t) {
                    return !!e1 && "DoExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isDoWhileStatement = function(e1, t) {
                    return !!e1 && "DoWhileStatement" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isEmptyStatement = function(e1, t) {
                    return !!e1 && "EmptyStatement" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isEmptyTypeAnnotation = function(e1, t) {
                    return !!e1 && "EmptyTypeAnnotation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isEnumBody = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "EnumBooleanBody":
                        case "EnumNumberBody":
                        case "EnumStringBody":
                        case "EnumSymbolBody":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isEnumBooleanBody = function(e1, t) {
                    return !!e1 && "EnumBooleanBody" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isEnumBooleanMember = function(e1, t) {
                    return !!e1 && "EnumBooleanMember" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isEnumDeclaration = function(e1, t) {
                    return !!e1 && "EnumDeclaration" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isEnumDefaultedMember = function(e1, t) {
                    return !!e1 && "EnumDefaultedMember" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isEnumMember = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "EnumBooleanMember":
                        case "EnumNumberMember":
                        case "EnumStringMember":
                        case "EnumDefaultedMember":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isEnumNumberBody = function(e1, t) {
                    return !!e1 && "EnumNumberBody" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isEnumNumberMember = function(e1, t) {
                    return !!e1 && "EnumNumberMember" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isEnumStringBody = function(e1, t) {
                    return !!e1 && "EnumStringBody" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isEnumStringMember = function(e1, t) {
                    return !!e1 && "EnumStringMember" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isEnumSymbolBody = function(e1, t) {
                    return !!e1 && "EnumSymbolBody" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isExistsTypeAnnotation = function(e1, t) {
                    return !!e1 && "ExistsTypeAnnotation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isExportAllDeclaration = function(e1, t) {
                    return !!e1 && "ExportAllDeclaration" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isExportDeclaration = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "ExportAllDeclaration":
                        case "ExportDefaultDeclaration":
                        case "ExportNamedDeclaration":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isExportDefaultDeclaration = function(e1, t) {
                    return !!e1 && "ExportDefaultDeclaration" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isExportDefaultSpecifier = function(e1, t) {
                    return !!e1 && "ExportDefaultSpecifier" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isExportNamedDeclaration = function(e1, t) {
                    return !!e1 && "ExportNamedDeclaration" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isExportNamespaceSpecifier = function(e1, t) {
                    return !!e1 && "ExportNamespaceSpecifier" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isExportSpecifier = function(e1, t) {
                    return !!e1 && "ExportSpecifier" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isExpression = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "ArrayExpression":
                        case "AssignmentExpression":
                        case "BinaryExpression":
                        case "CallExpression":
                        case "ConditionalExpression":
                        case "FunctionExpression":
                        case "Identifier":
                        case "StringLiteral":
                        case "NumericLiteral":
                        case "NullLiteral":
                        case "BooleanLiteral":
                        case "RegExpLiteral":
                        case "LogicalExpression":
                        case "MemberExpression":
                        case "NewExpression":
                        case "ObjectExpression":
                        case "SequenceExpression":
                        case "ParenthesizedExpression":
                        case "ThisExpression":
                        case "UnaryExpression":
                        case "UpdateExpression":
                        case "ArrowFunctionExpression":
                        case "ClassExpression":
                        case "MetaProperty":
                        case "Super":
                        case "TaggedTemplateExpression":
                        case "TemplateLiteral":
                        case "YieldExpression":
                        case "AwaitExpression":
                        case "Import":
                        case "BigIntLiteral":
                        case "OptionalMemberExpression":
                        case "OptionalCallExpression":
                        case "TypeCastExpression":
                        case "JSXElement":
                        case "JSXFragment":
                        case "BindExpression":
                        case "DoExpression":
                        case "RecordExpression":
                        case "TupleExpression":
                        case "DecimalLiteral":
                        case "ModuleExpression":
                        case "TopicReference":
                        case "PipelineTopicExpression":
                        case "PipelineBareFunction":
                        case "PipelinePrimaryTopicReference":
                        case "TSInstantiationExpression":
                        case "TSAsExpression":
                        case "TSSatisfiesExpression":
                        case "TSTypeAssertion":
                        case "TSNonNullExpression":
                            break;
                        case "Placeholder":
                            switch(e1.expectedNode){
                                case "Expression":
                                case "Identifier":
                                case "StringLiteral":
                                    break;
                                default:
                                    return !1;
                            }
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isExpressionStatement = function(e1, t) {
                    return !!e1 && "ExpressionStatement" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isExpressionWrapper = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "ExpressionStatement":
                        case "ParenthesizedExpression":
                        case "TypeCastExpression":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isFile = function(e1, t) {
                    return !!e1 && "File" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isFlow = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "AnyTypeAnnotation":
                        case "ArrayTypeAnnotation":
                        case "BooleanTypeAnnotation":
                        case "BooleanLiteralTypeAnnotation":
                        case "NullLiteralTypeAnnotation":
                        case "ClassImplements":
                        case "DeclareClass":
                        case "DeclareFunction":
                        case "DeclareInterface":
                        case "DeclareModule":
                        case "DeclareModuleExports":
                        case "DeclareTypeAlias":
                        case "DeclareOpaqueType":
                        case "DeclareVariable":
                        case "DeclareExportDeclaration":
                        case "DeclareExportAllDeclaration":
                        case "DeclaredPredicate":
                        case "ExistsTypeAnnotation":
                        case "FunctionTypeAnnotation":
                        case "FunctionTypeParam":
                        case "GenericTypeAnnotation":
                        case "InferredPredicate":
                        case "InterfaceExtends":
                        case "InterfaceDeclaration":
                        case "InterfaceTypeAnnotation":
                        case "IntersectionTypeAnnotation":
                        case "MixedTypeAnnotation":
                        case "EmptyTypeAnnotation":
                        case "NullableTypeAnnotation":
                        case "NumberLiteralTypeAnnotation":
                        case "NumberTypeAnnotation":
                        case "ObjectTypeAnnotation":
                        case "ObjectTypeInternalSlot":
                        case "ObjectTypeCallProperty":
                        case "ObjectTypeIndexer":
                        case "ObjectTypeProperty":
                        case "ObjectTypeSpreadProperty":
                        case "OpaqueType":
                        case "QualifiedTypeIdentifier":
                        case "StringLiteralTypeAnnotation":
                        case "StringTypeAnnotation":
                        case "SymbolTypeAnnotation":
                        case "ThisTypeAnnotation":
                        case "TupleTypeAnnotation":
                        case "TypeofTypeAnnotation":
                        case "TypeAlias":
                        case "TypeAnnotation":
                        case "TypeCastExpression":
                        case "TypeParameter":
                        case "TypeParameterDeclaration":
                        case "TypeParameterInstantiation":
                        case "UnionTypeAnnotation":
                        case "Variance":
                        case "VoidTypeAnnotation":
                        case "EnumDeclaration":
                        case "EnumBooleanBody":
                        case "EnumNumberBody":
                        case "EnumStringBody":
                        case "EnumSymbolBody":
                        case "EnumBooleanMember":
                        case "EnumNumberMember":
                        case "EnumStringMember":
                        case "EnumDefaultedMember":
                        case "IndexedAccessType":
                        case "OptionalIndexedAccessType":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isFlowBaseAnnotation = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "AnyTypeAnnotation":
                        case "BooleanTypeAnnotation":
                        case "NullLiteralTypeAnnotation":
                        case "MixedTypeAnnotation":
                        case "EmptyTypeAnnotation":
                        case "NumberTypeAnnotation":
                        case "StringTypeAnnotation":
                        case "SymbolTypeAnnotation":
                        case "ThisTypeAnnotation":
                        case "VoidTypeAnnotation":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isFlowDeclaration = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "DeclareClass":
                        case "DeclareFunction":
                        case "DeclareInterface":
                        case "DeclareModule":
                        case "DeclareModuleExports":
                        case "DeclareTypeAlias":
                        case "DeclareOpaqueType":
                        case "DeclareVariable":
                        case "DeclareExportDeclaration":
                        case "DeclareExportAllDeclaration":
                        case "InterfaceDeclaration":
                        case "OpaqueType":
                        case "TypeAlias":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isFlowPredicate = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "DeclaredPredicate":
                        case "InferredPredicate":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isFlowType = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "AnyTypeAnnotation":
                        case "ArrayTypeAnnotation":
                        case "BooleanTypeAnnotation":
                        case "BooleanLiteralTypeAnnotation":
                        case "NullLiteralTypeAnnotation":
                        case "ExistsTypeAnnotation":
                        case "FunctionTypeAnnotation":
                        case "GenericTypeAnnotation":
                        case "InterfaceTypeAnnotation":
                        case "IntersectionTypeAnnotation":
                        case "MixedTypeAnnotation":
                        case "EmptyTypeAnnotation":
                        case "NullableTypeAnnotation":
                        case "NumberLiteralTypeAnnotation":
                        case "NumberTypeAnnotation":
                        case "ObjectTypeAnnotation":
                        case "StringLiteralTypeAnnotation":
                        case "StringTypeAnnotation":
                        case "SymbolTypeAnnotation":
                        case "ThisTypeAnnotation":
                        case "TupleTypeAnnotation":
                        case "TypeofTypeAnnotation":
                        case "UnionTypeAnnotation":
                        case "VoidTypeAnnotation":
                        case "IndexedAccessType":
                        case "OptionalIndexedAccessType":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isFor = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "ForInStatement":
                        case "ForStatement":
                        case "ForOfStatement":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isForInStatement = function(e1, t) {
                    return !!e1 && "ForInStatement" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isForOfStatement = function(e1, t) {
                    return !!e1 && "ForOfStatement" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isForStatement = function(e1, t) {
                    return !!e1 && "ForStatement" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isForXStatement = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "ForInStatement":
                        case "ForOfStatement":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isFunction = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "FunctionDeclaration":
                        case "FunctionExpression":
                        case "ObjectMethod":
                        case "ArrowFunctionExpression":
                        case "ClassMethod":
                        case "ClassPrivateMethod":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isFunctionDeclaration = function(e1, t) {
                    return !!e1 && "FunctionDeclaration" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isFunctionExpression = function(e1, t) {
                    return !!e1 && "FunctionExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isFunctionParent = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "FunctionDeclaration":
                        case "FunctionExpression":
                        case "ObjectMethod":
                        case "ArrowFunctionExpression":
                        case "ClassMethod":
                        case "ClassPrivateMethod":
                        case "StaticBlock":
                        case "TSModuleBlock":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isFunctionTypeAnnotation = function(e1, t) {
                    return !!e1 && "FunctionTypeAnnotation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isFunctionTypeParam = function(e1, t) {
                    return !!e1 && "FunctionTypeParam" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isGenericTypeAnnotation = function(e1, t) {
                    return !!e1 && "GenericTypeAnnotation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isIdentifier = function(e1, t) {
                    return !!e1 && "Identifier" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isIfStatement = function(e1, t) {
                    return !!e1 && "IfStatement" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isImmutable = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "StringLiteral":
                        case "NumericLiteral":
                        case "NullLiteral":
                        case "BooleanLiteral":
                        case "BigIntLiteral":
                        case "JSXAttribute":
                        case "JSXClosingElement":
                        case "JSXElement":
                        case "JSXExpressionContainer":
                        case "JSXSpreadChild":
                        case "JSXOpeningElement":
                        case "JSXText":
                        case "JSXFragment":
                        case "JSXOpeningFragment":
                        case "JSXClosingFragment":
                        case "DecimalLiteral":
                            break;
                        case "Placeholder":
                            if ("StringLiteral" === e1.expectedNode) break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isImport = function(e1, t) {
                    return !!e1 && "Import" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isImportAttribute = function(e1, t) {
                    return !!e1 && "ImportAttribute" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isImportDeclaration = function(e1, t) {
                    return !!e1 && "ImportDeclaration" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isImportDefaultSpecifier = function(e1, t) {
                    return !!e1 && "ImportDefaultSpecifier" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isImportNamespaceSpecifier = function(e1, t) {
                    return !!e1 && "ImportNamespaceSpecifier" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isImportOrExportDeclaration = s, t.isImportSpecifier = function(e1, t) {
                    return !!e1 && "ImportSpecifier" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isIndexedAccessType = function(e1, t) {
                    return !!e1 && "IndexedAccessType" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isInferredPredicate = function(e1, t) {
                    return !!e1 && "InferredPredicate" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isInterfaceDeclaration = function(e1, t) {
                    return !!e1 && "InterfaceDeclaration" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isInterfaceExtends = function(e1, t) {
                    return !!e1 && "InterfaceExtends" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isInterfaceTypeAnnotation = function(e1, t) {
                    return !!e1 && "InterfaceTypeAnnotation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isInterpreterDirective = function(e1, t) {
                    return !!e1 && "InterpreterDirective" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isIntersectionTypeAnnotation = function(e1, t) {
                    return !!e1 && "IntersectionTypeAnnotation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isJSX = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "JSXAttribute":
                        case "JSXClosingElement":
                        case "JSXElement":
                        case "JSXEmptyExpression":
                        case "JSXExpressionContainer":
                        case "JSXSpreadChild":
                        case "JSXIdentifier":
                        case "JSXMemberExpression":
                        case "JSXNamespacedName":
                        case "JSXOpeningElement":
                        case "JSXSpreadAttribute":
                        case "JSXText":
                        case "JSXFragment":
                        case "JSXOpeningFragment":
                        case "JSXClosingFragment":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isJSXAttribute = function(e1, t) {
                    return !!e1 && "JSXAttribute" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isJSXClosingElement = function(e1, t) {
                    return !!e1 && "JSXClosingElement" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isJSXClosingFragment = function(e1, t) {
                    return !!e1 && "JSXClosingFragment" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isJSXElement = function(e1, t) {
                    return !!e1 && "JSXElement" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isJSXEmptyExpression = function(e1, t) {
                    return !!e1 && "JSXEmptyExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isJSXExpressionContainer = function(e1, t) {
                    return !!e1 && "JSXExpressionContainer" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isJSXFragment = function(e1, t) {
                    return !!e1 && "JSXFragment" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isJSXIdentifier = function(e1, t) {
                    return !!e1 && "JSXIdentifier" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isJSXMemberExpression = function(e1, t) {
                    return !!e1 && "JSXMemberExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isJSXNamespacedName = function(e1, t) {
                    return !!e1 && "JSXNamespacedName" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isJSXOpeningElement = function(e1, t) {
                    return !!e1 && "JSXOpeningElement" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isJSXOpeningFragment = function(e1, t) {
                    return !!e1 && "JSXOpeningFragment" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isJSXSpreadAttribute = function(e1, t) {
                    return !!e1 && "JSXSpreadAttribute" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isJSXSpreadChild = function(e1, t) {
                    return !!e1 && "JSXSpreadChild" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isJSXText = function(e1, t) {
                    return !!e1 && "JSXText" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isLVal = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "Identifier":
                        case "MemberExpression":
                        case "RestElement":
                        case "AssignmentPattern":
                        case "ArrayPattern":
                        case "ObjectPattern":
                        case "TSParameterProperty":
                        case "TSAsExpression":
                        case "TSSatisfiesExpression":
                        case "TSTypeAssertion":
                        case "TSNonNullExpression":
                            break;
                        case "Placeholder":
                            switch(e1.expectedNode){
                                case "Pattern":
                                case "Identifier":
                                    break;
                                default:
                                    return !1;
                            }
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isLabeledStatement = function(e1, t) {
                    return !!e1 && "LabeledStatement" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isLiteral = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "StringLiteral":
                        case "NumericLiteral":
                        case "NullLiteral":
                        case "BooleanLiteral":
                        case "RegExpLiteral":
                        case "TemplateLiteral":
                        case "BigIntLiteral":
                        case "DecimalLiteral":
                            break;
                        case "Placeholder":
                            if ("StringLiteral" === e1.expectedNode) break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isLogicalExpression = function(e1, t) {
                    return !!e1 && "LogicalExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isLoop = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "DoWhileStatement":
                        case "ForInStatement":
                        case "ForStatement":
                        case "WhileStatement":
                        case "ForOfStatement":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isMemberExpression = function(e1, t) {
                    return !!e1 && "MemberExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isMetaProperty = function(e1, t) {
                    return !!e1 && "MetaProperty" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isMethod = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "ObjectMethod":
                        case "ClassMethod":
                        case "ClassPrivateMethod":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isMiscellaneous = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "Noop":
                        case "Placeholder":
                        case "V8IntrinsicIdentifier":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isMixedTypeAnnotation = function(e1, t) {
                    return !!e1 && "MixedTypeAnnotation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isModuleDeclaration = function(e1, t) {
                    return (0, i.default)("isModuleDeclaration", "isImportOrExportDeclaration"), s(e1, t);
                }, t.isModuleExpression = function(e1, t) {
                    return !!e1 && "ModuleExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isModuleSpecifier = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "ExportSpecifier":
                        case "ImportDefaultSpecifier":
                        case "ImportNamespaceSpecifier":
                        case "ImportSpecifier":
                        case "ExportNamespaceSpecifier":
                        case "ExportDefaultSpecifier":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isNewExpression = function(e1, t) {
                    return !!e1 && "NewExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isNoop = function(e1, t) {
                    return !!e1 && "Noop" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isNullLiteral = function(e1, t) {
                    return !!e1 && "NullLiteral" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isNullLiteralTypeAnnotation = function(e1, t) {
                    return !!e1 && "NullLiteralTypeAnnotation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isNullableTypeAnnotation = function(e1, t) {
                    return !!e1 && "NullableTypeAnnotation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isNumberLiteral = function(e1, t) {
                    return (0, i.default)("isNumberLiteral", "isNumericLiteral"), !!e1 && "NumberLiteral" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isNumberLiteralTypeAnnotation = function(e1, t) {
                    return !!e1 && "NumberLiteralTypeAnnotation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isNumberTypeAnnotation = function(e1, t) {
                    return !!e1 && "NumberTypeAnnotation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isNumericLiteral = function(e1, t) {
                    return !!e1 && "NumericLiteral" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isObjectExpression = function(e1, t) {
                    return !!e1 && "ObjectExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isObjectMember = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "ObjectMethod":
                        case "ObjectProperty":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isObjectMethod = function(e1, t) {
                    return !!e1 && "ObjectMethod" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isObjectPattern = function(e1, t) {
                    return !!e1 && "ObjectPattern" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isObjectProperty = function(e1, t) {
                    return !!e1 && "ObjectProperty" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isObjectTypeAnnotation = function(e1, t) {
                    return !!e1 && "ObjectTypeAnnotation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isObjectTypeCallProperty = function(e1, t) {
                    return !!e1 && "ObjectTypeCallProperty" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isObjectTypeIndexer = function(e1, t) {
                    return !!e1 && "ObjectTypeIndexer" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isObjectTypeInternalSlot = function(e1, t) {
                    return !!e1 && "ObjectTypeInternalSlot" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isObjectTypeProperty = function(e1, t) {
                    return !!e1 && "ObjectTypeProperty" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isObjectTypeSpreadProperty = function(e1, t) {
                    return !!e1 && "ObjectTypeSpreadProperty" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isOpaqueType = function(e1, t) {
                    return !!e1 && "OpaqueType" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isOptionalCallExpression = function(e1, t) {
                    return !!e1 && "OptionalCallExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isOptionalIndexedAccessType = function(e1, t) {
                    return !!e1 && "OptionalIndexedAccessType" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isOptionalMemberExpression = function(e1, t) {
                    return !!e1 && "OptionalMemberExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isParenthesizedExpression = function(e1, t) {
                    return !!e1 && "ParenthesizedExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isPattern = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "AssignmentPattern":
                        case "ArrayPattern":
                        case "ObjectPattern":
                            break;
                        case "Placeholder":
                            if ("Pattern" === e1.expectedNode) break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isPatternLike = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "Identifier":
                        case "RestElement":
                        case "AssignmentPattern":
                        case "ArrayPattern":
                        case "ObjectPattern":
                        case "TSAsExpression":
                        case "TSSatisfiesExpression":
                        case "TSTypeAssertion":
                        case "TSNonNullExpression":
                            break;
                        case "Placeholder":
                            switch(e1.expectedNode){
                                case "Pattern":
                                case "Identifier":
                                    break;
                                default:
                                    return !1;
                            }
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isPipelineBareFunction = function(e1, t) {
                    return !!e1 && "PipelineBareFunction" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isPipelinePrimaryTopicReference = function(e1, t) {
                    return !!e1 && "PipelinePrimaryTopicReference" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isPipelineTopicExpression = function(e1, t) {
                    return !!e1 && "PipelineTopicExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isPlaceholder = function(e1, t) {
                    return !!e1 && "Placeholder" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isPrivate = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "ClassPrivateProperty":
                        case "ClassPrivateMethod":
                        case "PrivateName":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isPrivateName = function(e1, t) {
                    return !!e1 && "PrivateName" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isProgram = function(e1, t) {
                    return !!e1 && "Program" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isProperty = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "ObjectProperty":
                        case "ClassProperty":
                        case "ClassAccessorProperty":
                        case "ClassPrivateProperty":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isPureish = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "FunctionDeclaration":
                        case "FunctionExpression":
                        case "StringLiteral":
                        case "NumericLiteral":
                        case "NullLiteral":
                        case "BooleanLiteral":
                        case "RegExpLiteral":
                        case "ArrowFunctionExpression":
                        case "BigIntLiteral":
                        case "DecimalLiteral":
                            break;
                        case "Placeholder":
                            if ("StringLiteral" === e1.expectedNode) break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isQualifiedTypeIdentifier = function(e1, t) {
                    return !!e1 && "QualifiedTypeIdentifier" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isRecordExpression = function(e1, t) {
                    return !!e1 && "RecordExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isRegExpLiteral = function(e1, t) {
                    return !!e1 && "RegExpLiteral" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isRegexLiteral = function(e1, t) {
                    return (0, i.default)("isRegexLiteral", "isRegExpLiteral"), !!e1 && "RegexLiteral" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isRestElement = function(e1, t) {
                    return !!e1 && "RestElement" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isRestProperty = function(e1, t) {
                    return (0, i.default)("isRestProperty", "isRestElement"), !!e1 && "RestProperty" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isReturnStatement = function(e1, t) {
                    return !!e1 && "ReturnStatement" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isScopable = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "BlockStatement":
                        case "CatchClause":
                        case "DoWhileStatement":
                        case "ForInStatement":
                        case "ForStatement":
                        case "FunctionDeclaration":
                        case "FunctionExpression":
                        case "Program":
                        case "ObjectMethod":
                        case "SwitchStatement":
                        case "WhileStatement":
                        case "ArrowFunctionExpression":
                        case "ClassExpression":
                        case "ClassDeclaration":
                        case "ForOfStatement":
                        case "ClassMethod":
                        case "ClassPrivateMethod":
                        case "StaticBlock":
                        case "TSModuleBlock":
                            break;
                        case "Placeholder":
                            if ("BlockStatement" === e1.expectedNode) break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isSequenceExpression = function(e1, t) {
                    return !!e1 && "SequenceExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isSpreadElement = function(e1, t) {
                    return !!e1 && "SpreadElement" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isSpreadProperty = function(e1, t) {
                    return (0, i.default)("isSpreadProperty", "isSpreadElement"), !!e1 && "SpreadProperty" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isStandardized = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "ArrayExpression":
                        case "AssignmentExpression":
                        case "BinaryExpression":
                        case "InterpreterDirective":
                        case "Directive":
                        case "DirectiveLiteral":
                        case "BlockStatement":
                        case "BreakStatement":
                        case "CallExpression":
                        case "CatchClause":
                        case "ConditionalExpression":
                        case "ContinueStatement":
                        case "DebuggerStatement":
                        case "DoWhileStatement":
                        case "EmptyStatement":
                        case "ExpressionStatement":
                        case "File":
                        case "ForInStatement":
                        case "ForStatement":
                        case "FunctionDeclaration":
                        case "FunctionExpression":
                        case "Identifier":
                        case "IfStatement":
                        case "LabeledStatement":
                        case "StringLiteral":
                        case "NumericLiteral":
                        case "NullLiteral":
                        case "BooleanLiteral":
                        case "RegExpLiteral":
                        case "LogicalExpression":
                        case "MemberExpression":
                        case "NewExpression":
                        case "Program":
                        case "ObjectExpression":
                        case "ObjectMethod":
                        case "ObjectProperty":
                        case "RestElement":
                        case "ReturnStatement":
                        case "SequenceExpression":
                        case "ParenthesizedExpression":
                        case "SwitchCase":
                        case "SwitchStatement":
                        case "ThisExpression":
                        case "ThrowStatement":
                        case "TryStatement":
                        case "UnaryExpression":
                        case "UpdateExpression":
                        case "VariableDeclaration":
                        case "VariableDeclarator":
                        case "WhileStatement":
                        case "WithStatement":
                        case "AssignmentPattern":
                        case "ArrayPattern":
                        case "ArrowFunctionExpression":
                        case "ClassBody":
                        case "ClassExpression":
                        case "ClassDeclaration":
                        case "ExportAllDeclaration":
                        case "ExportDefaultDeclaration":
                        case "ExportNamedDeclaration":
                        case "ExportSpecifier":
                        case "ForOfStatement":
                        case "ImportDeclaration":
                        case "ImportDefaultSpecifier":
                        case "ImportNamespaceSpecifier":
                        case "ImportSpecifier":
                        case "MetaProperty":
                        case "ClassMethod":
                        case "ObjectPattern":
                        case "SpreadElement":
                        case "Super":
                        case "TaggedTemplateExpression":
                        case "TemplateElement":
                        case "TemplateLiteral":
                        case "YieldExpression":
                        case "AwaitExpression":
                        case "Import":
                        case "BigIntLiteral":
                        case "ExportNamespaceSpecifier":
                        case "OptionalMemberExpression":
                        case "OptionalCallExpression":
                        case "ClassProperty":
                        case "ClassAccessorProperty":
                        case "ClassPrivateProperty":
                        case "ClassPrivateMethod":
                        case "PrivateName":
                        case "StaticBlock":
                            break;
                        case "Placeholder":
                            switch(e1.expectedNode){
                                case "Identifier":
                                case "StringLiteral":
                                case "BlockStatement":
                                case "ClassBody":
                                    break;
                                default:
                                    return !1;
                            }
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isStatement = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "BlockStatement":
                        case "BreakStatement":
                        case "ContinueStatement":
                        case "DebuggerStatement":
                        case "DoWhileStatement":
                        case "EmptyStatement":
                        case "ExpressionStatement":
                        case "ForInStatement":
                        case "ForStatement":
                        case "FunctionDeclaration":
                        case "IfStatement":
                        case "LabeledStatement":
                        case "ReturnStatement":
                        case "SwitchStatement":
                        case "ThrowStatement":
                        case "TryStatement":
                        case "VariableDeclaration":
                        case "WhileStatement":
                        case "WithStatement":
                        case "ClassDeclaration":
                        case "ExportAllDeclaration":
                        case "ExportDefaultDeclaration":
                        case "ExportNamedDeclaration":
                        case "ForOfStatement":
                        case "ImportDeclaration":
                        case "DeclareClass":
                        case "DeclareFunction":
                        case "DeclareInterface":
                        case "DeclareModule":
                        case "DeclareModuleExports":
                        case "DeclareTypeAlias":
                        case "DeclareOpaqueType":
                        case "DeclareVariable":
                        case "DeclareExportDeclaration":
                        case "DeclareExportAllDeclaration":
                        case "InterfaceDeclaration":
                        case "OpaqueType":
                        case "TypeAlias":
                        case "EnumDeclaration":
                        case "TSDeclareFunction":
                        case "TSInterfaceDeclaration":
                        case "TSTypeAliasDeclaration":
                        case "TSEnumDeclaration":
                        case "TSModuleDeclaration":
                        case "TSImportEqualsDeclaration":
                        case "TSExportAssignment":
                        case "TSNamespaceExportDeclaration":
                            break;
                        case "Placeholder":
                            switch(e1.expectedNode){
                                case "Statement":
                                case "Declaration":
                                case "BlockStatement":
                                    break;
                                default:
                                    return !1;
                            }
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isStaticBlock = function(e1, t) {
                    return !!e1 && "StaticBlock" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isStringLiteral = function(e1, t) {
                    return !!e1 && "StringLiteral" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isStringLiteralTypeAnnotation = function(e1, t) {
                    return !!e1 && "StringLiteralTypeAnnotation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isStringTypeAnnotation = function(e1, t) {
                    return !!e1 && "StringTypeAnnotation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isSuper = function(e1, t) {
                    return !!e1 && "Super" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isSwitchCase = function(e1, t) {
                    return !!e1 && "SwitchCase" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isSwitchStatement = function(e1, t) {
                    return !!e1 && "SwitchStatement" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isSymbolTypeAnnotation = function(e1, t) {
                    return !!e1 && "SymbolTypeAnnotation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSAnyKeyword = function(e1, t) {
                    return !!e1 && "TSAnyKeyword" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSArrayType = function(e1, t) {
                    return !!e1 && "TSArrayType" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSAsExpression = function(e1, t) {
                    return !!e1 && "TSAsExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSBaseType = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "TSAnyKeyword":
                        case "TSBooleanKeyword":
                        case "TSBigIntKeyword":
                        case "TSIntrinsicKeyword":
                        case "TSNeverKeyword":
                        case "TSNullKeyword":
                        case "TSNumberKeyword":
                        case "TSObjectKeyword":
                        case "TSStringKeyword":
                        case "TSSymbolKeyword":
                        case "TSUndefinedKeyword":
                        case "TSUnknownKeyword":
                        case "TSVoidKeyword":
                        case "TSThisType":
                        case "TSLiteralType":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isTSBigIntKeyword = function(e1, t) {
                    return !!e1 && "TSBigIntKeyword" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSBooleanKeyword = function(e1, t) {
                    return !!e1 && "TSBooleanKeyword" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSCallSignatureDeclaration = function(e1, t) {
                    return !!e1 && "TSCallSignatureDeclaration" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSConditionalType = function(e1, t) {
                    return !!e1 && "TSConditionalType" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSConstructSignatureDeclaration = function(e1, t) {
                    return !!e1 && "TSConstructSignatureDeclaration" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSConstructorType = function(e1, t) {
                    return !!e1 && "TSConstructorType" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSDeclareFunction = function(e1, t) {
                    return !!e1 && "TSDeclareFunction" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSDeclareMethod = function(e1, t) {
                    return !!e1 && "TSDeclareMethod" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSEntityName = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "Identifier":
                        case "TSQualifiedName":
                            break;
                        case "Placeholder":
                            if ("Identifier" === e1.expectedNode) break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isTSEnumDeclaration = function(e1, t) {
                    return !!e1 && "TSEnumDeclaration" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSEnumMember = function(e1, t) {
                    return !!e1 && "TSEnumMember" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSExportAssignment = function(e1, t) {
                    return !!e1 && "TSExportAssignment" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSExpressionWithTypeArguments = function(e1, t) {
                    return !!e1 && "TSExpressionWithTypeArguments" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSExternalModuleReference = function(e1, t) {
                    return !!e1 && "TSExternalModuleReference" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSFunctionType = function(e1, t) {
                    return !!e1 && "TSFunctionType" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSImportEqualsDeclaration = function(e1, t) {
                    return !!e1 && "TSImportEqualsDeclaration" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSImportType = function(e1, t) {
                    return !!e1 && "TSImportType" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSIndexSignature = function(e1, t) {
                    return !!e1 && "TSIndexSignature" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSIndexedAccessType = function(e1, t) {
                    return !!e1 && "TSIndexedAccessType" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSInferType = function(e1, t) {
                    return !!e1 && "TSInferType" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSInstantiationExpression = function(e1, t) {
                    return !!e1 && "TSInstantiationExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSInterfaceBody = function(e1, t) {
                    return !!e1 && "TSInterfaceBody" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSInterfaceDeclaration = function(e1, t) {
                    return !!e1 && "TSInterfaceDeclaration" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSIntersectionType = function(e1, t) {
                    return !!e1 && "TSIntersectionType" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSIntrinsicKeyword = function(e1, t) {
                    return !!e1 && "TSIntrinsicKeyword" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSLiteralType = function(e1, t) {
                    return !!e1 && "TSLiteralType" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSMappedType = function(e1, t) {
                    return !!e1 && "TSMappedType" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSMethodSignature = function(e1, t) {
                    return !!e1 && "TSMethodSignature" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSModuleBlock = function(e1, t) {
                    return !!e1 && "TSModuleBlock" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSModuleDeclaration = function(e1, t) {
                    return !!e1 && "TSModuleDeclaration" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSNamedTupleMember = function(e1, t) {
                    return !!e1 && "TSNamedTupleMember" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSNamespaceExportDeclaration = function(e1, t) {
                    return !!e1 && "TSNamespaceExportDeclaration" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSNeverKeyword = function(e1, t) {
                    return !!e1 && "TSNeverKeyword" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSNonNullExpression = function(e1, t) {
                    return !!e1 && "TSNonNullExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSNullKeyword = function(e1, t) {
                    return !!e1 && "TSNullKeyword" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSNumberKeyword = function(e1, t) {
                    return !!e1 && "TSNumberKeyword" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSObjectKeyword = function(e1, t) {
                    return !!e1 && "TSObjectKeyword" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSOptionalType = function(e1, t) {
                    return !!e1 && "TSOptionalType" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSParameterProperty = function(e1, t) {
                    return !!e1 && "TSParameterProperty" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSParenthesizedType = function(e1, t) {
                    return !!e1 && "TSParenthesizedType" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSPropertySignature = function(e1, t) {
                    return !!e1 && "TSPropertySignature" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSQualifiedName = function(e1, t) {
                    return !!e1 && "TSQualifiedName" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSRestType = function(e1, t) {
                    return !!e1 && "TSRestType" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSSatisfiesExpression = function(e1, t) {
                    return !!e1 && "TSSatisfiesExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSStringKeyword = function(e1, t) {
                    return !!e1 && "TSStringKeyword" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSSymbolKeyword = function(e1, t) {
                    return !!e1 && "TSSymbolKeyword" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSThisType = function(e1, t) {
                    return !!e1 && "TSThisType" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSTupleType = function(e1, t) {
                    return !!e1 && "TSTupleType" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSType = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "TSAnyKeyword":
                        case "TSBooleanKeyword":
                        case "TSBigIntKeyword":
                        case "TSIntrinsicKeyword":
                        case "TSNeverKeyword":
                        case "TSNullKeyword":
                        case "TSNumberKeyword":
                        case "TSObjectKeyword":
                        case "TSStringKeyword":
                        case "TSSymbolKeyword":
                        case "TSUndefinedKeyword":
                        case "TSUnknownKeyword":
                        case "TSVoidKeyword":
                        case "TSThisType":
                        case "TSFunctionType":
                        case "TSConstructorType":
                        case "TSTypeReference":
                        case "TSTypePredicate":
                        case "TSTypeQuery":
                        case "TSTypeLiteral":
                        case "TSArrayType":
                        case "TSTupleType":
                        case "TSOptionalType":
                        case "TSRestType":
                        case "TSUnionType":
                        case "TSIntersectionType":
                        case "TSConditionalType":
                        case "TSInferType":
                        case "TSParenthesizedType":
                        case "TSTypeOperator":
                        case "TSIndexedAccessType":
                        case "TSMappedType":
                        case "TSLiteralType":
                        case "TSExpressionWithTypeArguments":
                        case "TSImportType":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isTSTypeAliasDeclaration = function(e1, t) {
                    return !!e1 && "TSTypeAliasDeclaration" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSTypeAnnotation = function(e1, t) {
                    return !!e1 && "TSTypeAnnotation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSTypeAssertion = function(e1, t) {
                    return !!e1 && "TSTypeAssertion" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSTypeElement = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "TSCallSignatureDeclaration":
                        case "TSConstructSignatureDeclaration":
                        case "TSPropertySignature":
                        case "TSMethodSignature":
                        case "TSIndexSignature":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isTSTypeLiteral = function(e1, t) {
                    return !!e1 && "TSTypeLiteral" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSTypeOperator = function(e1, t) {
                    return !!e1 && "TSTypeOperator" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSTypeParameter = function(e1, t) {
                    return !!e1 && "TSTypeParameter" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSTypeParameterDeclaration = function(e1, t) {
                    return !!e1 && "TSTypeParameterDeclaration" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSTypeParameterInstantiation = function(e1, t) {
                    return !!e1 && "TSTypeParameterInstantiation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSTypePredicate = function(e1, t) {
                    return !!e1 && "TSTypePredicate" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSTypeQuery = function(e1, t) {
                    return !!e1 && "TSTypeQuery" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSTypeReference = function(e1, t) {
                    return !!e1 && "TSTypeReference" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSUndefinedKeyword = function(e1, t) {
                    return !!e1 && "TSUndefinedKeyword" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSUnionType = function(e1, t) {
                    return !!e1 && "TSUnionType" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSUnknownKeyword = function(e1, t) {
                    return !!e1 && "TSUnknownKeyword" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTSVoidKeyword = function(e1, t) {
                    return !!e1 && "TSVoidKeyword" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTaggedTemplateExpression = function(e1, t) {
                    return !!e1 && "TaggedTemplateExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTemplateElement = function(e1, t) {
                    return !!e1 && "TemplateElement" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTemplateLiteral = function(e1, t) {
                    return !!e1 && "TemplateLiteral" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTerminatorless = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "BreakStatement":
                        case "ContinueStatement":
                        case "ReturnStatement":
                        case "ThrowStatement":
                        case "YieldExpression":
                        case "AwaitExpression":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isThisExpression = function(e1, t) {
                    return !!e1 && "ThisExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isThisTypeAnnotation = function(e1, t) {
                    return !!e1 && "ThisTypeAnnotation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isThrowStatement = function(e1, t) {
                    return !!e1 && "ThrowStatement" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTopicReference = function(e1, t) {
                    return !!e1 && "TopicReference" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTryStatement = function(e1, t) {
                    return !!e1 && "TryStatement" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTupleExpression = function(e1, t) {
                    return !!e1 && "TupleExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTupleTypeAnnotation = function(e1, t) {
                    return !!e1 && "TupleTypeAnnotation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTypeAlias = function(e1, t) {
                    return !!e1 && "TypeAlias" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTypeAnnotation = function(e1, t) {
                    return !!e1 && "TypeAnnotation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTypeCastExpression = function(e1, t) {
                    return !!e1 && "TypeCastExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTypeParameter = function(e1, t) {
                    return !!e1 && "TypeParameter" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTypeParameterDeclaration = function(e1, t) {
                    return !!e1 && "TypeParameterDeclaration" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTypeParameterInstantiation = function(e1, t) {
                    return !!e1 && "TypeParameterInstantiation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isTypeScript = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "TSParameterProperty":
                        case "TSDeclareFunction":
                        case "TSDeclareMethod":
                        case "TSQualifiedName":
                        case "TSCallSignatureDeclaration":
                        case "TSConstructSignatureDeclaration":
                        case "TSPropertySignature":
                        case "TSMethodSignature":
                        case "TSIndexSignature":
                        case "TSAnyKeyword":
                        case "TSBooleanKeyword":
                        case "TSBigIntKeyword":
                        case "TSIntrinsicKeyword":
                        case "TSNeverKeyword":
                        case "TSNullKeyword":
                        case "TSNumberKeyword":
                        case "TSObjectKeyword":
                        case "TSStringKeyword":
                        case "TSSymbolKeyword":
                        case "TSUndefinedKeyword":
                        case "TSUnknownKeyword":
                        case "TSVoidKeyword":
                        case "TSThisType":
                        case "TSFunctionType":
                        case "TSConstructorType":
                        case "TSTypeReference":
                        case "TSTypePredicate":
                        case "TSTypeQuery":
                        case "TSTypeLiteral":
                        case "TSArrayType":
                        case "TSTupleType":
                        case "TSOptionalType":
                        case "TSRestType":
                        case "TSNamedTupleMember":
                        case "TSUnionType":
                        case "TSIntersectionType":
                        case "TSConditionalType":
                        case "TSInferType":
                        case "TSParenthesizedType":
                        case "TSTypeOperator":
                        case "TSIndexedAccessType":
                        case "TSMappedType":
                        case "TSLiteralType":
                        case "TSExpressionWithTypeArguments":
                        case "TSInterfaceDeclaration":
                        case "TSInterfaceBody":
                        case "TSTypeAliasDeclaration":
                        case "TSInstantiationExpression":
                        case "TSAsExpression":
                        case "TSSatisfiesExpression":
                        case "TSTypeAssertion":
                        case "TSEnumDeclaration":
                        case "TSEnumMember":
                        case "TSModuleDeclaration":
                        case "TSModuleBlock":
                        case "TSImportType":
                        case "TSImportEqualsDeclaration":
                        case "TSExternalModuleReference":
                        case "TSNonNullExpression":
                        case "TSExportAssignment":
                        case "TSNamespaceExportDeclaration":
                        case "TSTypeAnnotation":
                        case "TSTypeParameterInstantiation":
                        case "TSTypeParameterDeclaration":
                        case "TSTypeParameter":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isTypeofTypeAnnotation = function(e1, t) {
                    return !!e1 && "TypeofTypeAnnotation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isUnaryExpression = function(e1, t) {
                    return !!e1 && "UnaryExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isUnaryLike = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "UnaryExpression":
                        case "SpreadElement":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isUnionTypeAnnotation = function(e1, t) {
                    return !!e1 && "UnionTypeAnnotation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isUpdateExpression = function(e1, t) {
                    return !!e1 && "UpdateExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isUserWhitespacable = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "ObjectMethod":
                        case "ObjectProperty":
                        case "ObjectTypeInternalSlot":
                        case "ObjectTypeCallProperty":
                        case "ObjectTypeIndexer":
                        case "ObjectTypeProperty":
                        case "ObjectTypeSpreadProperty":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isV8IntrinsicIdentifier = function(e1, t) {
                    return !!e1 && "V8IntrinsicIdentifier" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isVariableDeclaration = function(e1, t) {
                    return !!e1 && "VariableDeclaration" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isVariableDeclarator = function(e1, t) {
                    return !!e1 && "VariableDeclarator" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isVariance = function(e1, t) {
                    return !!e1 && "Variance" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isVoidTypeAnnotation = function(e1, t) {
                    return !!e1 && "VoidTypeAnnotation" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isWhile = function(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "DoWhileStatement":
                        case "WhileStatement":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }, t.isWhileStatement = function(e1, t) {
                    return !!e1 && "WhileStatement" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isWithStatement = function(e1, t) {
                    return !!e1 && "WithStatement" === e1.type && (null == t || (0, r.default)(e1, t));
                }, t.isYieldExpression = function(e1, t) {
                    return !!e1 && "YieldExpression" === e1.type && (null == t || (0, r.default)(e1, t));
                };
                var r = n(9960), i = n(4619);
                function s(e1, t) {
                    if (!e1) return !1;
                    switch(e1.type){
                        case "ExportAllDeclaration":
                        case "ExportDefaultDeclaration":
                        case "ExportNamedDeclaration":
                        case "ImportDeclaration":
                            break;
                        default:
                            return !1;
                    }
                    return null == t || (0, r.default)(e1, t);
                }
            },
            5171: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t, n) {
                    return !!t && ((0, i.default)(t.type, e1) ? void 0 === n || (0, r.default)(t, n) : !n && "Placeholder" === t.type && e1 in a.FLIPPED_ALIAS_KEYS && (0, s.default)(t.expectedNode, e1));
                };
                var r = n(9960), i = n(5179), s = n(8894), a = n(1678);
            },
            8443: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t, n) {
                    if (n && "Identifier" === e1.type && "ObjectProperty" === t.type && "ObjectExpression" === n.type) return !1;
                    const i = r.default.keys[t.type];
                    if (i) for(let n = 0; n < i.length; n++){
                        const r = t[i[n]];
                        if (Array.isArray(r)) {
                            if (r.indexOf(e1) >= 0) return !0;
                        } else if (r === e1) return !0;
                    }
                    return !1;
                };
                var r = n(984);
            },
            964: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1) {
                    return (0, r.isFunctionDeclaration)(e1) || (0, r.isClassDeclaration)(e1) || (0, i.default)(e1);
                };
                var r = n(9869), i = n(3066);
            },
            1689: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1) {
                    return !!(0, r.default)(e1.type, "Immutable") || !!(0, i.isIdentifier)(e1) && "undefined" === e1.name;
                };
                var r = n(5179), i = n(9869);
            },
            3066: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1) {
                    return (0, r.isVariableDeclaration)(e1) && ("var" !== e1.kind || e1[i.BLOCK_SCOPED_SYMBOL]);
                };
                var r = n(9869), i = n(3725);
            },
            4814: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1) {
                    return !(!e1 || !r.VISITOR_KEYS[e1.type]);
                };
                var r = n(1678);
            },
            7997: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function e1(t, n) {
                    if ("object" != typeof t || "object" != typeof n || null == t || null == n) return t === n;
                    if (t.type !== n.type) return !1;
                    const i = Object.keys(r.NODE_FIELDS[t.type] || t.type), s = r.VISITOR_KEYS[t.type];
                    for (const r of i){
                        const i = t[r], a = n[r];
                        if (typeof i != typeof a) return !1;
                        if (null != i || null != a) {
                            if (null == i || null == a) return !1;
                            if (Array.isArray(i)) {
                                if (!Array.isArray(a)) return !1;
                                if (i.length !== a.length) return !1;
                                for(let t = 0; t < i.length; t++)if (!e1(i[t], a[t])) return !1;
                            } else if ("object" != typeof i || null != s && s.includes(r)) {
                                if (!e1(i, a)) return !1;
                            } else for (const e1 of Object.keys(i))if (i[e1] !== a[e1]) return !1;
                        }
                    }
                    return !0;
                };
                var r = n(1678);
            },
            8894: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t) {
                    if (e1 === t) return !0;
                    const n = r.PLACEHOLDERS_ALIAS[e1];
                    if (n) {
                        for (const e1 of n)if (t === e1) return !0;
                    }
                    return !1;
                };
                var r = n(1678);
            },
            3683: (e1, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t, n) {
                    switch(t.type){
                        case "MemberExpression":
                        case "OptionalMemberExpression":
                            return t.property === e1 ? !!t.computed : t.object === e1;
                        case "JSXMemberExpression":
                            return t.object === e1;
                        case "VariableDeclarator":
                            return t.init === e1;
                        case "ArrowFunctionExpression":
                            return t.body === e1;
                        case "PrivateName":
                        case "LabeledStatement":
                        case "CatchClause":
                        case "RestElement":
                        case "BreakStatement":
                        case "ContinueStatement":
                        case "FunctionDeclaration":
                        case "FunctionExpression":
                        case "ExportNamespaceSpecifier":
                        case "ExportDefaultSpecifier":
                        case "ImportDefaultSpecifier":
                        case "ImportNamespaceSpecifier":
                        case "ImportSpecifier":
                        case "ImportAttribute":
                        case "JSXAttribute":
                        case "ObjectPattern":
                        case "ArrayPattern":
                        case "MetaProperty":
                            return !1;
                        case "ClassMethod":
                        case "ClassPrivateMethod":
                        case "ObjectMethod":
                            return t.key === e1 && !!t.computed;
                        case "ObjectProperty":
                            return t.key === e1 ? !!t.computed : !n || "ObjectPattern" !== n.type;
                        case "ClassProperty":
                        case "ClassAccessorProperty":
                        case "TSPropertySignature":
                            return t.key !== e1 || !!t.computed;
                        case "ClassPrivateProperty":
                        case "ObjectTypeProperty":
                            return t.key !== e1;
                        case "ClassDeclaration":
                        case "ClassExpression":
                            return t.superClass === e1;
                        case "AssignmentExpression":
                        case "AssignmentPattern":
                            return t.right === e1;
                        case "ExportSpecifier":
                            return (null == n || !n.source) && t.local === e1;
                        case "TSEnumMember":
                            return t.id !== e1;
                    }
                    return !0;
                };
            },
            2126: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t) {
                    return (!(0, r.isBlockStatement)(e1) || !(0, r.isFunction)(t) && !(0, r.isCatchClause)(t)) && (!(!(0, r.isPattern)(e1) || !(0, r.isFunction)(t) && !(0, r.isCatchClause)(t)) || (0, r.isScopable)(e1));
                };
                var r = n(9869);
            },
            8691: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1) {
                    return (0, r.isImportDefaultSpecifier)(e1) || (0, r.isIdentifier)(e1.imported || e1.exported, {
                        name: "default"
                    });
                };
                var r = n(9869);
            },
            5179: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t) {
                    if (e1 === t) return !0;
                    if (null == e1) return !1;
                    if (r.ALIAS_KEYS[t]) return !1;
                    const n = r.FLIPPED_ALIAS_KEYS[t];
                    if (n) {
                        if (n[0] === e1) return !0;
                        for (const t of n)if (e1 === t) return !0;
                    }
                    return !1;
                };
                var r = n(1678);
            },
            7879: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1) {
                    return (0, r.default)(e1) && !i.has(e1);
                };
                var r = n(5820);
                const i = new Set([
                    "abstract",
                    "boolean",
                    "byte",
                    "char",
                    "double",
                    "enum",
                    "final",
                    "float",
                    "goto",
                    "implements",
                    "int",
                    "interface",
                    "long",
                    "native",
                    "package",
                    "private",
                    "protected",
                    "public",
                    "short",
                    "static",
                    "synchronized",
                    "throws",
                    "transient",
                    "volatile"
                ]);
            },
            5820: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t = !0) {
                    return "string" == typeof e1 && (!t || !(0, r.isKeyword)(e1) && !(0, r.isStrictReservedWord)(e1, !0)) && (0, r.isIdentifierName)(e1);
                };
                var r = n(9649);
            },
            3358: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1) {
                    return (0, r.isVariableDeclaration)(e1, {
                        kind: "var"
                    }) && !e1[i.BLOCK_SCOPED_SYMBOL];
                };
                var r = n(9869), i = n(3725);
            },
            2693: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t, n) {
                    if (!(0, r.isMemberExpression)(e1)) return !1;
                    const i = Array.isArray(t) ? t : t.split("."), s = [];
                    let a;
                    for(a = e1; (0, r.isMemberExpression)(a); a = a.object)s.push(a.property);
                    if (s.push(a), s.length < i.length) return !1;
                    if (!n && s.length > i.length) return !1;
                    for(let e1 = 0, t = s.length - 1; e1 < i.length; e1++, t--){
                        const n = s[t];
                        let a;
                        if ((0, r.isIdentifier)(n)) a = n.name;
                        else if ((0, r.isStringLiteral)(n)) a = n.value;
                        else {
                            if (!(0, r.isThisExpression)(n)) return !1;
                            a = "this";
                        }
                        if (i[e1] !== a) return !1;
                    }
                    return !0;
                };
                var r = n(9869);
            },
            9733: (e1, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1) {
                    return !!e1 && /^[a-z]/.test(e1);
                };
            },
            4229: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var r = (0, n(2051).default)("React.Component");
                t.default = r;
            },
            7750: (e1, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e1, t, n) {
                    if (!e1) return;
                    const a = r.NODE_FIELDS[e1.type];
                    if (!a) return;
                    i(e1, t, n, a[t]), s(e1, t, n);
                }, t.validateChild = s, t.validateField = i;
                var r = n(1678);
                function i(e1, t, n, r) {
                    null != r && r.validate && (r.optional && null == n || r.validate(e1, t, n));
                }
                function s(e1, t, n) {
                    if (null == n) return;
                    const i = r.NODE_PARENT_VALIDATIONS[n.type];
                    i && i(e1, t, n);
                }
            },
            8487: (e1)=>{
                "use strict";
                e1.exports = JSON.parse('{"builtin":{"Array":false,"ArrayBuffer":false,"Atomics":false,"BigInt":false,"BigInt64Array":false,"BigUint64Array":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"globalThis":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es5":{"Array":false,"Boolean":false,"constructor":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"propertyIsEnumerable":false,"RangeError":false,"ReferenceError":false,"RegExp":false,"String":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false},"es2015":{"Array":false,"ArrayBuffer":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es2017":{"Array":false,"ArrayBuffer":false,"Atomics":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"browser":{"AbortController":false,"AbortSignal":false,"addEventListener":false,"alert":false,"AnalyserNode":false,"Animation":false,"AnimationEffectReadOnly":false,"AnimationEffectTiming":false,"AnimationEffectTimingReadOnly":false,"AnimationEvent":false,"AnimationPlaybackEvent":false,"AnimationTimeline":false,"applicationCache":false,"ApplicationCache":false,"ApplicationCacheErrorEvent":false,"atob":false,"Attr":false,"Audio":false,"AudioBuffer":false,"AudioBufferSourceNode":false,"AudioContext":false,"AudioDestinationNode":false,"AudioListener":false,"AudioNode":false,"AudioParam":false,"AudioProcessingEvent":false,"AudioScheduledSourceNode":false,"AudioWorkletGlobalScope ":false,"AudioWorkletNode":false,"AudioWorkletProcessor":false,"BarProp":false,"BaseAudioContext":false,"BatteryManager":false,"BeforeUnloadEvent":false,"BiquadFilterNode":false,"Blob":false,"BlobEvent":false,"blur":false,"BroadcastChannel":false,"btoa":false,"BudgetService":false,"ByteLengthQueuingStrategy":false,"Cache":false,"caches":false,"CacheStorage":false,"cancelAnimationFrame":false,"cancelIdleCallback":false,"CanvasCaptureMediaStreamTrack":false,"CanvasGradient":false,"CanvasPattern":false,"CanvasRenderingContext2D":false,"ChannelMergerNode":false,"ChannelSplitterNode":false,"CharacterData":false,"clearInterval":false,"clearTimeout":false,"clientInformation":false,"ClipboardEvent":false,"close":false,"closed":false,"CloseEvent":false,"Comment":false,"CompositionEvent":false,"confirm":false,"console":false,"ConstantSourceNode":false,"ConvolverNode":false,"CountQueuingStrategy":false,"createImageBitmap":false,"Credential":false,"CredentialsContainer":false,"crypto":false,"Crypto":false,"CryptoKey":false,"CSS":false,"CSSConditionRule":false,"CSSFontFaceRule":false,"CSSGroupingRule":false,"CSSImportRule":false,"CSSKeyframeRule":false,"CSSKeyframesRule":false,"CSSMediaRule":false,"CSSNamespaceRule":false,"CSSPageRule":false,"CSSRule":false,"CSSRuleList":false,"CSSStyleDeclaration":false,"CSSStyleRule":false,"CSSStyleSheet":false,"CSSSupportsRule":false,"CustomElementRegistry":false,"customElements":false,"CustomEvent":false,"DataTransfer":false,"DataTransferItem":false,"DataTransferItemList":false,"defaultstatus":false,"defaultStatus":false,"DelayNode":false,"DeviceMotionEvent":false,"DeviceOrientationEvent":false,"devicePixelRatio":false,"dispatchEvent":false,"document":false,"Document":false,"DocumentFragment":false,"DocumentType":false,"DOMError":false,"DOMException":false,"DOMImplementation":false,"DOMMatrix":false,"DOMMatrixReadOnly":false,"DOMParser":false,"DOMPoint":false,"DOMPointReadOnly":false,"DOMQuad":false,"DOMRect":false,"DOMRectReadOnly":false,"DOMStringList":false,"DOMStringMap":false,"DOMTokenList":false,"DragEvent":false,"DynamicsCompressorNode":false,"Element":false,"ErrorEvent":false,"event":false,"Event":false,"EventSource":false,"EventTarget":false,"external":false,"fetch":false,"File":false,"FileList":false,"FileReader":false,"find":false,"focus":false,"FocusEvent":false,"FontFace":false,"FontFaceSetLoadEvent":false,"FormData":false,"frameElement":false,"frames":false,"GainNode":false,"Gamepad":false,"GamepadButton":false,"GamepadEvent":false,"getComputedStyle":false,"getSelection":false,"HashChangeEvent":false,"Headers":false,"history":false,"History":false,"HTMLAllCollection":false,"HTMLAnchorElement":false,"HTMLAreaElement":false,"HTMLAudioElement":false,"HTMLBaseElement":false,"HTMLBodyElement":false,"HTMLBRElement":false,"HTMLButtonElement":false,"HTMLCanvasElement":false,"HTMLCollection":false,"HTMLContentElement":false,"HTMLDataElement":false,"HTMLDataListElement":false,"HTMLDetailsElement":false,"HTMLDialogElement":false,"HTMLDirectoryElement":false,"HTMLDivElement":false,"HTMLDListElement":false,"HTMLDocument":false,"HTMLElement":false,"HTMLEmbedElement":false,"HTMLFieldSetElement":false,"HTMLFontElement":false,"HTMLFormControlsCollection":false,"HTMLFormElement":false,"HTMLFrameElement":false,"HTMLFrameSetElement":false,"HTMLHeadElement":false,"HTMLHeadingElement":false,"HTMLHRElement":false,"HTMLHtmlElement":false,"HTMLIFrameElement":false,"HTMLImageElement":false,"HTMLInputElement":false,"HTMLLabelElement":false,"HTMLLegendElement":false,"HTMLLIElement":false,"HTMLLinkElement":false,"HTMLMapElement":false,"HTMLMarqueeElement":false,"HTMLMediaElement":false,"HTMLMenuElement":false,"HTMLMetaElement":false,"HTMLMeterElement":false,"HTMLModElement":false,"HTMLObjectElement":false,"HTMLOListElement":false,"HTMLOptGroupElement":false,"HTMLOptionElement":false,"HTMLOptionsCollection":false,"HTMLOutputElement":false,"HTMLParagraphElement":false,"HTMLParamElement":false,"HTMLPictureElement":false,"HTMLPreElement":false,"HTMLProgressElement":false,"HTMLQuoteElement":false,"HTMLScriptElement":false,"HTMLSelectElement":false,"HTMLShadowElement":false,"HTMLSlotElement":false,"HTMLSourceElement":false,"HTMLSpanElement":false,"HTMLStyleElement":false,"HTMLTableCaptionElement":false,"HTMLTableCellElement":false,"HTMLTableColElement":false,"HTMLTableElement":false,"HTMLTableRowElement":false,"HTMLTableSectionElement":false,"HTMLTemplateElement":false,"HTMLTextAreaElement":false,"HTMLTimeElement":false,"HTMLTitleElement":false,"HTMLTrackElement":false,"HTMLUListElement":false,"HTMLUnknownElement":false,"HTMLVideoElement":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"IdleDeadline":false,"IIRFilterNode":false,"Image":false,"ImageBitmap":false,"ImageBitmapRenderingContext":false,"ImageCapture":false,"ImageData":false,"indexedDB":false,"innerHeight":false,"innerWidth":false,"InputEvent":false,"IntersectionObserver":false,"IntersectionObserverEntry":false,"Intl":false,"isSecureContext":false,"KeyboardEvent":false,"KeyframeEffect":false,"KeyframeEffectReadOnly":false,"length":false,"localStorage":false,"location":true,"Location":false,"locationbar":false,"matchMedia":false,"MediaDeviceInfo":false,"MediaDevices":false,"MediaElementAudioSourceNode":false,"MediaEncryptedEvent":false,"MediaError":false,"MediaKeyMessageEvent":false,"MediaKeySession":false,"MediaKeyStatusMap":false,"MediaKeySystemAccess":false,"MediaList":false,"MediaQueryList":false,"MediaQueryListEvent":false,"MediaRecorder":false,"MediaSettingsRange":false,"MediaSource":false,"MediaStream":false,"MediaStreamAudioDestinationNode":false,"MediaStreamAudioSourceNode":false,"MediaStreamEvent":false,"MediaStreamTrack":false,"MediaStreamTrackEvent":false,"menubar":false,"MessageChannel":false,"MessageEvent":false,"MessagePort":false,"MIDIAccess":false,"MIDIConnectionEvent":false,"MIDIInput":false,"MIDIInputMap":false,"MIDIMessageEvent":false,"MIDIOutput":false,"MIDIOutputMap":false,"MIDIPort":false,"MimeType":false,"MimeTypeArray":false,"MouseEvent":false,"moveBy":false,"moveTo":false,"MutationEvent":false,"MutationObserver":false,"MutationRecord":false,"name":false,"NamedNodeMap":false,"NavigationPreloadManager":false,"navigator":false,"Navigator":false,"NetworkInformation":false,"Node":false,"NodeFilter":false,"NodeIterator":false,"NodeList":false,"Notification":false,"OfflineAudioCompletionEvent":false,"OfflineAudioContext":false,"offscreenBuffering":false,"OffscreenCanvas":true,"onabort":true,"onafterprint":true,"onanimationend":true,"onanimationiteration":true,"onanimationstart":true,"onappinstalled":true,"onauxclick":true,"onbeforeinstallprompt":true,"onbeforeprint":true,"onbeforeunload":true,"onblur":true,"oncancel":true,"oncanplay":true,"oncanplaythrough":true,"onchange":true,"onclick":true,"onclose":true,"oncontextmenu":true,"oncuechange":true,"ondblclick":true,"ondevicemotion":true,"ondeviceorientation":true,"ondeviceorientationabsolute":true,"ondrag":true,"ondragend":true,"ondragenter":true,"ondragleave":true,"ondragover":true,"ondragstart":true,"ondrop":true,"ondurationchange":true,"onemptied":true,"onended":true,"onerror":true,"onfocus":true,"ongotpointercapture":true,"onhashchange":true,"oninput":true,"oninvalid":true,"onkeydown":true,"onkeypress":true,"onkeyup":true,"onlanguagechange":true,"onload":true,"onloadeddata":true,"onloadedmetadata":true,"onloadstart":true,"onlostpointercapture":true,"onmessage":true,"onmessageerror":true,"onmousedown":true,"onmouseenter":true,"onmouseleave":true,"onmousemove":true,"onmouseout":true,"onmouseover":true,"onmouseup":true,"onmousewheel":true,"onoffline":true,"ononline":true,"onpagehide":true,"onpageshow":true,"onpause":true,"onplay":true,"onplaying":true,"onpointercancel":true,"onpointerdown":true,"onpointerenter":true,"onpointerleave":true,"onpointermove":true,"onpointerout":true,"onpointerover":true,"onpointerup":true,"onpopstate":true,"onprogress":true,"onratechange":true,"onrejectionhandled":true,"onreset":true,"onresize":true,"onscroll":true,"onsearch":true,"onseeked":true,"onseeking":true,"onselect":true,"onstalled":true,"onstorage":true,"onsubmit":true,"onsuspend":true,"ontimeupdate":true,"ontoggle":true,"ontransitionend":true,"onunhandledrejection":true,"onunload":true,"onvolumechange":true,"onwaiting":true,"onwheel":true,"open":false,"openDatabase":false,"opener":false,"Option":false,"origin":false,"OscillatorNode":false,"outerHeight":false,"outerWidth":false,"PageTransitionEvent":false,"pageXOffset":false,"pageYOffset":false,"PannerNode":false,"parent":false,"Path2D":false,"PaymentAddress":false,"PaymentRequest":false,"PaymentRequestUpdateEvent":false,"PaymentResponse":false,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceLongTaskTiming":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceNavigationTiming":false,"PerformanceObserver":false,"PerformanceObserverEntryList":false,"PerformancePaintTiming":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"PeriodicWave":false,"Permissions":false,"PermissionStatus":false,"personalbar":false,"PhotoCapabilities":false,"Plugin":false,"PluginArray":false,"PointerEvent":false,"PopStateEvent":false,"postMessage":false,"Presentation":false,"PresentationAvailability":false,"PresentationConnection":false,"PresentationConnectionAvailableEvent":false,"PresentationConnectionCloseEvent":false,"PresentationConnectionList":false,"PresentationReceiver":false,"PresentationRequest":false,"print":false,"ProcessingInstruction":false,"ProgressEvent":false,"PromiseRejectionEvent":false,"prompt":false,"PushManager":false,"PushSubscription":false,"PushSubscriptionOptions":false,"queueMicrotask":false,"RadioNodeList":false,"Range":false,"ReadableStream":false,"registerProcessor":false,"RemotePlayback":false,"removeEventListener":false,"Request":false,"requestAnimationFrame":false,"requestIdleCallback":false,"resizeBy":false,"ResizeObserver":false,"ResizeObserverEntry":false,"resizeTo":false,"Response":false,"RTCCertificate":false,"RTCDataChannel":false,"RTCDataChannelEvent":false,"RTCDtlsTransport":false,"RTCIceCandidate":false,"RTCIceGatherer":false,"RTCIceTransport":false,"RTCPeerConnection":false,"RTCPeerConnectionIceEvent":false,"RTCRtpContributingSource":false,"RTCRtpReceiver":false,"RTCRtpSender":false,"RTCSctpTransport":false,"RTCSessionDescription":false,"RTCStatsReport":false,"RTCTrackEvent":false,"screen":false,"Screen":false,"screenLeft":false,"ScreenOrientation":false,"screenTop":false,"screenX":false,"screenY":false,"ScriptProcessorNode":false,"scroll":false,"scrollbars":false,"scrollBy":false,"scrollTo":false,"scrollX":false,"scrollY":false,"SecurityPolicyViolationEvent":false,"Selection":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerRegistration":false,"sessionStorage":false,"setInterval":false,"setTimeout":false,"ShadowRoot":false,"SharedWorker":false,"SourceBuffer":false,"SourceBufferList":false,"speechSynthesis":false,"SpeechSynthesisEvent":false,"SpeechSynthesisUtterance":false,"StaticRange":false,"status":false,"statusbar":false,"StereoPannerNode":false,"stop":false,"Storage":false,"StorageEvent":false,"StorageManager":false,"styleMedia":false,"StyleSheet":false,"StyleSheetList":false,"SubtleCrypto":false,"SVGAElement":false,"SVGAngle":false,"SVGAnimatedAngle":false,"SVGAnimatedBoolean":false,"SVGAnimatedEnumeration":false,"SVGAnimatedInteger":false,"SVGAnimatedLength":false,"SVGAnimatedLengthList":false,"SVGAnimatedNumber":false,"SVGAnimatedNumberList":false,"SVGAnimatedPreserveAspectRatio":false,"SVGAnimatedRect":false,"SVGAnimatedString":false,"SVGAnimatedTransformList":false,"SVGAnimateElement":false,"SVGAnimateMotionElement":false,"SVGAnimateTransformElement":false,"SVGAnimationElement":false,"SVGCircleElement":false,"SVGClipPathElement":false,"SVGComponentTransferFunctionElement":false,"SVGDefsElement":false,"SVGDescElement":false,"SVGDiscardElement":false,"SVGElement":false,"SVGEllipseElement":false,"SVGFEBlendElement":false,"SVGFEColorMatrixElement":false,"SVGFEComponentTransferElement":false,"SVGFECompositeElement":false,"SVGFEConvolveMatrixElement":false,"SVGFEDiffuseLightingElement":false,"SVGFEDisplacementMapElement":false,"SVGFEDistantLightElement":false,"SVGFEDropShadowElement":false,"SVGFEFloodElement":false,"SVGFEFuncAElement":false,"SVGFEFuncBElement":false,"SVGFEFuncGElement":false,"SVGFEFuncRElement":false,"SVGFEGaussianBlurElement":false,"SVGFEImageElement":false,"SVGFEMergeElement":false,"SVGFEMergeNodeElement":false,"SVGFEMorphologyElement":false,"SVGFEOffsetElement":false,"SVGFEPointLightElement":false,"SVGFESpecularLightingElement":false,"SVGFESpotLightElement":false,"SVGFETileElement":false,"SVGFETurbulenceElement":false,"SVGFilterElement":false,"SVGForeignObjectElement":false,"SVGGElement":false,"SVGGeometryElement":false,"SVGGradientElement":false,"SVGGraphicsElement":false,"SVGImageElement":false,"SVGLength":false,"SVGLengthList":false,"SVGLinearGradientElement":false,"SVGLineElement":false,"SVGMarkerElement":false,"SVGMaskElement":false,"SVGMatrix":false,"SVGMetadataElement":false,"SVGMPathElement":false,"SVGNumber":false,"SVGNumberList":false,"SVGPathElement":false,"SVGPatternElement":false,"SVGPoint":false,"SVGPointList":false,"SVGPolygonElement":false,"SVGPolylineElement":false,"SVGPreserveAspectRatio":false,"SVGRadialGradientElement":false,"SVGRect":false,"SVGRectElement":false,"SVGScriptElement":false,"SVGSetElement":false,"SVGStopElement":false,"SVGStringList":false,"SVGStyleElement":false,"SVGSVGElement":false,"SVGSwitchElement":false,"SVGSymbolElement":false,"SVGTextContentElement":false,"SVGTextElement":false,"SVGTextPathElement":false,"SVGTextPositioningElement":false,"SVGTitleElement":false,"SVGTransform":false,"SVGTransformList":false,"SVGTSpanElement":false,"SVGUnitTypes":false,"SVGUseElement":false,"SVGViewElement":false,"TaskAttributionTiming":false,"Text":false,"TextDecoder":false,"TextEncoder":false,"TextEvent":false,"TextMetrics":false,"TextTrack":false,"TextTrackCue":false,"TextTrackCueList":false,"TextTrackList":false,"TimeRanges":false,"toolbar":false,"top":false,"Touch":false,"TouchEvent":false,"TouchList":false,"TrackEvent":false,"TransitionEvent":false,"TreeWalker":false,"UIEvent":false,"URL":false,"URLSearchParams":false,"ValidityState":false,"visualViewport":false,"VisualViewport":false,"VTTCue":false,"WaveShaperNode":false,"WebAssembly":false,"WebGL2RenderingContext":false,"WebGLActiveInfo":false,"WebGLBuffer":false,"WebGLContextEvent":false,"WebGLFramebuffer":false,"WebGLProgram":false,"WebGLQuery":false,"WebGLRenderbuffer":false,"WebGLRenderingContext":false,"WebGLSampler":false,"WebGLShader":false,"WebGLShaderPrecisionFormat":false,"WebGLSync":false,"WebGLTexture":false,"WebGLTransformFeedback":false,"WebGLUniformLocation":false,"WebGLVertexArrayObject":false,"WebSocket":false,"WheelEvent":false,"window":false,"Window":false,"Worker":false,"WritableStream":false,"XMLDocument":false,"XMLHttpRequest":false,"XMLHttpRequestEventTarget":false,"XMLHttpRequestUpload":false,"XMLSerializer":false,"XPathEvaluator":false,"XPathExpression":false,"XPathResult":false,"XSLTProcessor":false},"worker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"clearInterval":false,"clearTimeout":false,"close":true,"console":false,"fetch":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":true,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onlanguagechange":true,"onmessage":true,"onoffline":true,"ononline":true,"onrejectionhandled":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"removeEventListener":false,"Request":false,"Response":false,"self":true,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"node":{"__dirname":false,"__filename":false,"Buffer":false,"clearImmediate":false,"clearInterval":false,"clearTimeout":false,"console":false,"exports":true,"global":false,"Intl":false,"module":false,"process":false,"queueMicrotask":false,"require":false,"setImmediate":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false},"commonjs":{"exports":true,"global":false,"module":false,"require":false},"amd":{"define":false,"require":false},"mocha":{"after":false,"afterEach":false,"before":false,"beforeEach":false,"context":false,"describe":false,"it":false,"mocha":false,"run":false,"setup":false,"specify":false,"suite":false,"suiteSetup":false,"suiteTeardown":false,"teardown":false,"test":false,"xcontext":false,"xdescribe":false,"xit":false,"xspecify":false},"jasmine":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fail":false,"fdescribe":false,"fit":false,"it":false,"jasmine":false,"pending":false,"runs":false,"spyOn":false,"spyOnProperty":false,"waits":false,"waitsFor":false,"xdescribe":false,"xit":false},"jest":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fdescribe":false,"fit":false,"it":false,"jest":false,"pit":false,"require":false,"test":false,"xdescribe":false,"xit":false,"xtest":false},"qunit":{"asyncTest":false,"deepEqual":false,"equal":false,"expect":false,"module":false,"notDeepEqual":false,"notEqual":false,"notOk":false,"notPropEqual":false,"notStrictEqual":false,"ok":false,"propEqual":false,"QUnit":false,"raises":false,"start":false,"stop":false,"strictEqual":false,"test":false,"throws":false},"phantomjs":{"console":true,"exports":true,"phantom":true,"require":true,"WebPage":true},"couch":{"emit":false,"exports":false,"getRow":false,"log":false,"module":false,"provides":false,"require":false,"respond":false,"send":false,"start":false,"sum":false},"rhino":{"defineClass":false,"deserialize":false,"gc":false,"help":false,"importClass":false,"importPackage":false,"java":false,"load":false,"loadClass":false,"Packages":false,"print":false,"quit":false,"readFile":false,"readUrl":false,"runCommand":false,"seal":false,"serialize":false,"spawn":false,"sync":false,"toint32":false,"version":false},"nashorn":{"__DIR__":false,"__FILE__":false,"__LINE__":false,"com":false,"edu":false,"exit":false,"java":false,"Java":false,"javafx":false,"JavaImporter":false,"javax":false,"JSAdapter":false,"load":false,"loadWithNewGlobal":false,"org":false,"Packages":false,"print":false,"quit":false},"wsh":{"ActiveXObject":true,"Enumerator":true,"GetObject":true,"ScriptEngine":true,"ScriptEngineBuildVersion":true,"ScriptEngineMajorVersion":true,"ScriptEngineMinorVersion":true,"VBArray":true,"WScript":true,"WSH":true,"XDomainRequest":true},"jquery":{"$":false,"jQuery":false},"yui":{"YAHOO":false,"YAHOO_config":false,"YUI":false,"YUI_config":false},"shelljs":{"cat":false,"cd":false,"chmod":false,"config":false,"cp":false,"dirs":false,"echo":false,"env":false,"error":false,"exec":false,"exit":false,"find":false,"grep":false,"ln":false,"ls":false,"mkdir":false,"mv":false,"popd":false,"pushd":false,"pwd":false,"rm":false,"sed":false,"set":false,"target":false,"tempdir":false,"test":false,"touch":false,"which":false},"prototypejs":{"$":false,"$$":false,"$A":false,"$break":false,"$continue":false,"$F":false,"$H":false,"$R":false,"$w":false,"Abstract":false,"Ajax":false,"Autocompleter":false,"Builder":false,"Class":false,"Control":false,"Draggable":false,"Draggables":false,"Droppables":false,"Effect":false,"Element":false,"Enumerable":false,"Event":false,"Field":false,"Form":false,"Hash":false,"Insertion":false,"ObjectRange":false,"PeriodicalExecuter":false,"Position":false,"Prototype":false,"Scriptaculous":false,"Selector":false,"Sortable":false,"SortableObserver":false,"Sound":false,"Template":false,"Toggle":false,"Try":false},"meteor":{"_":false,"$":false,"Accounts":false,"AccountsClient":false,"AccountsCommon":false,"AccountsServer":false,"App":false,"Assets":false,"Blaze":false,"check":false,"Cordova":false,"DDP":false,"DDPRateLimiter":false,"DDPServer":false,"Deps":false,"EJSON":false,"Email":false,"HTTP":false,"Log":false,"Match":false,"Meteor":false,"Mongo":false,"MongoInternals":false,"Npm":false,"Package":false,"Plugin":false,"process":false,"Random":false,"ReactiveDict":false,"ReactiveVar":false,"Router":false,"ServiceConfiguration":false,"Session":false,"share":false,"Spacebars":false,"Template":false,"Tinytest":false,"Tracker":false,"UI":false,"Utils":false,"WebApp":false,"WebAppInternals":false},"mongo":{"_isWindows":false,"_rand":false,"BulkWriteResult":false,"cat":false,"cd":false,"connect":false,"db":false,"getHostName":false,"getMemInfo":false,"hostname":false,"ISODate":false,"listFiles":false,"load":false,"ls":false,"md5sumFile":false,"mkdir":false,"Mongo":false,"NumberInt":false,"NumberLong":false,"ObjectId":false,"PlanCache":false,"print":false,"printjson":false,"pwd":false,"quit":false,"removeFile":false,"rs":false,"sh":false,"UUID":false,"version":false,"WriteResult":false},"applescript":{"$":false,"Application":false,"Automation":false,"console":false,"delay":false,"Library":false,"ObjC":false,"ObjectSpecifier":false,"Path":false,"Progress":false,"Ref":false},"serviceworker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"CacheStorage":false,"clearInterval":false,"clearTimeout":false,"Client":false,"clients":false,"Clients":false,"close":true,"console":false,"ExtendableEvent":false,"ExtendableMessageEvent":false,"fetch":false,"FetchEvent":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":false,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onfetch":true,"oninstall":true,"onlanguagechange":true,"onmessage":true,"onmessageerror":true,"onnotificationclick":true,"onnotificationclose":true,"onoffline":true,"ononline":true,"onpush":true,"onpushsubscriptionchange":true,"onrejectionhandled":true,"onsync":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"registration":false,"removeEventListener":false,"Request":false,"Response":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerGlobalScope":false,"ServiceWorkerMessageEvent":false,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"skipWaiting":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"WindowClient":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"atomtest":{"advanceClock":false,"fakeClearInterval":false,"fakeClearTimeout":false,"fakeSetInterval":false,"fakeSetTimeout":false,"resetTimeouts":false,"waitsForPromise":false},"embertest":{"andThen":false,"click":false,"currentPath":false,"currentRouteName":false,"currentURL":false,"fillIn":false,"find":false,"findAll":false,"findWithAssert":false,"keyEvent":false,"pauseTest":false,"resumeTest":false,"triggerEvent":false,"visit":false,"wait":false},"protractor":{"$":false,"$$":false,"browser":false,"by":false,"By":false,"DartObject":false,"element":false,"protractor":false},"shared-node-browser":{"clearInterval":false,"clearTimeout":false,"console":false,"setInterval":false,"setTimeout":false,"URL":false,"URLSearchParams":false},"webextensions":{"browser":false,"chrome":false,"opr":false},"greasemonkey":{"cloneInto":false,"createObjectIn":false,"exportFunction":false,"GM":false,"GM_addStyle":false,"GM_deleteValue":false,"GM_getResourceText":false,"GM_getResourceURL":false,"GM_getValue":false,"GM_info":false,"GM_listValues":false,"GM_log":false,"GM_openInTab":false,"GM_registerMenuCommand":false,"GM_setClipboard":false,"GM_setValue":false,"GM_xmlhttpRequest":false,"unsafeWindow":false},"devtools":{"$":false,"$_":false,"$$":false,"$0":false,"$1":false,"$2":false,"$3":false,"$4":false,"$x":false,"chrome":false,"clear":false,"copy":false,"debug":false,"dir":false,"dirxml":false,"getEventListeners":false,"inspect":false,"keys":false,"monitor":false,"monitorEvents":false,"profile":false,"profileEnd":false,"queryObjects":false,"table":false,"undebug":false,"unmonitor":false,"unmonitorEvents":false,"values":false}}');
            }
        }, t = {};
        function n(r) {
            var i = t[r];
            if (void 0 !== i) return i.exports;
            var s = t[r] = {
                id: r,
                loaded: !1,
                exports: {}
            };
            return e1[r].call(s.exports, s, s.exports, n), s.loaded = !0, s.exports;
        }
        n.n = (e1)=>{
            var t = e1 && e1.__esModule ? ()=>e1.default : ()=>e1;
            return n.d(t, {
                a: t
            }), t;
        }, n.d = (e1, t)=>{
            for(var r in t)n.o(t, r) && !n.o(e1, r) && Object.defineProperty(e1, r, {
                enumerable: !0,
                get: t[r]
            });
        }, n.g = function() {
            if ("object" == typeof globalThis) return globalThis;
            try {
                return this || new Function("return this")();
            } catch (e1) {
                if ("object" == typeof window) return window;
            }
        }(), n.o = (e1, t)=>Object.prototype.hasOwnProperty.call(e1, t), n.r = (e1)=>{
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e1, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(e1, "__esModule", {
                value: !0
            });
        }, n.nmd = (e1)=>(e1.paths = [], e1.children || (e1.children = []), e1);
        var r = {};
        return (()=>{
            "use strict";
            n.r(r), n.d(r, {
                ABSTRACTION_LEVELS: ()=>ae,
                DEFINED_MODIFIERS: ()=>Te,
                MODIFIED_TYPES: ()=>c,
                MODIFIER_PRESETS: ()=>ge,
                TOKEN_TYPES: ()=>i,
                convertCodeToFlowTree: ()=>Or,
                convertCodeToSvg: ()=>wr,
                convertFlowTreeToSvg: ()=>Ir,
                createFlowTreeBuilder: ()=>xr,
                createFlowTreeModifier: ()=>Dr,
                createPresentationGenerator: ()=>Cr,
                createSVGRender: ()=>Ar,
                createShapesTreeEditor: ()=>vr
            });
            var e1, t = n(5686), i = {
                FUNCTION: "Function",
                FUNCTION_EXPRESSION: "FunctionExpression",
                FUNCTION_DECLARATION: "FunctionDeclaration",
                VARIABLE_DECLARATOR: "VariableDeclarator",
                ASSIGNMENT_EXPRESSION: "AssignmentExpression",
                MEMBER_EXPRESSION: "MemberExpression",
                VARIABLE_DECLARATION: "VariableDeclaration",
                UPDATE_EXPRESSION: "UpdateExpression",
                CALL_EXPRESSION: "CallExpression",
                NEW_EXPRESSION: "NewExpression",
                LOOP: "Loop",
                FOR_IN_STATEMENT: "ForInStatement",
                FOR_STATEMENT: "ForStatement",
                WHILE_STATEMENT: "WhileStatement",
                DO_WHILE_STATEMENT: "DoWhileStatement",
                CONTINUE: "ContinueStatement",
                CONDITIONAL: "Conditional",
                SWITCH_CASE: "SwitchCase",
                SWITCH_STATEMENT: "SwitchStatement",
                PROGRAM: "Program",
                RETURN: "ReturnStatement",
                BREAK: "BreakStatement",
                TRY_STATEMENT: "TryStatement",
                CATCH_CLAUSE: "CatchClause",
                WITH_STATEMENT: "WithStatement",
                THROW_STATEMENT: "ThrowStatement",
                DEBUGGER_STATEMENT: "DebuggerStatement",
                IDENTIFIER: "Identifier",
                ARRAY_EXPRESSION: "ArrayExpression",
                OBJECT_EXPRESSION: "ObjectExpression",
                OBJECT_PROPERTY: "ObjectProperty",
                OBJECT_METHOD: "ObjectMethod",
                BINARY_EXPRESSION: "BinaryExpression",
                EXPRESSION_STATEMENT: "ExpressionStatement",
                UNARY_EXPRESSION: "UnaryExpression",
                CONDITIONAL_EXPRESSION: "ConditionalExpression",
                STRING_LITERAL: "StringLiteral",
                NUMERIC_LITERAL: "NumericLiteral",
                THIS_EXPRESSION: "ThisExpression",
                LOGICAL_EXPRESSION: "LogicalExpression",
                ARROW_FUNCTION_EXPRESSION: "ArrowFunctionExpression",
                IMPORT_DECLARATION: "ImportDeclaration",
                IMPORT_DEFAULT_SPECIFIER: "ImportDefaultSpecifier",
                IMPORT_SPECIFIER: "ImportSpecifier",
                EXPORT_NAMED_DECLARATION: "ExportNamedDeclaration",
                EXPORT_DEFAULT_DECLARATION: "ExportDefaultDeclaration",
                CLASS_DECLARATION: "ClassDeclaration",
                CLASS_METHOD: "ClassMethod",
                FOR_OF_STATEMENT: "ForOfStatement",
                SPREAD_ELEMENT: "SpreadElement",
                SPREAD_PROPERTY: "SpreadProperty",
                REST_PROPERTY: "RestProperty",
                OBJECT_PATTERN: "ObjectPattern",
                ARRAY_PATTERN: "ArrayPattern",
                ASSIGNMENT_PATTERN: "AssignmentPattern"
            }, s = {
                BODY: "body",
                PROGRAM: "program",
                CONSEQUENT: "consequent",
                ALTERNATE: "alternate",
                TEST: "test"
            }, a = "RIGHT", o = "LEFT", l = "DOWN", c = {
                DESTRUCTED: "DESTRUCTED",
                CUSTOM: "CUSTOM"
            }, u = n(7848), p = function(e1) {
                return (0, u.default)(e1.node).code;
            }, h = function(e1) {
                var t = e1.parent;
                if (!t || t.type !== i.VARIABLE_DECLARATOR && t.type !== i.ASSIGNMENT_EXPRESSION && t.type !== i.OBJECT_PROPERTY) return "";
                if (t.left) return (0, u.default)(t.left).code + " = ";
                var n = t.id;
                return n ? n.name + " = " : "";
            }, d = function(e1) {
                var t = e1.node, n = e1.parent && e1.parent.kind || "";
                if (t.init && (b(t.init) || t.init.type === i.CONDITIONAL_EXPRESSION)) return "".concat(n, " ").concat(t.id.name, " = ");
                var r;
                return r = t.id.type === i.OBJECT_PATTERN ? "{...}" : t.id.type === i.ARRAY_PATTERN ? "[...]" : t.id.name, t.init && [
                    i.CALL_EXPRESSION,
                    i.NEW_EXPRESSION
                ].includes(t.init.type) ? "".concat(n, " ").concat(r, " = ") + y({
                    node: t.init
                }) : t.init && t.init.type === i.OBJECT_EXPRESSION ? "".concat(n, " ").concat(r, " = ").concat(T()) : t.id && t.id.type === i.OBJECT_PATTERN ? "".concat(n, " {...} = ").concat(t.init.name) : t.id && t.id.type === i.ARRAY_PATTERN ? "".concat(n, " [...] = ").concat(t.init.name) : n + " " + (0, u.default)(t).code;
            }, f = function(e1) {
                return e1.name ? e1.name : (0, u.default)(e1).code;
            }, y = function(e1) {
                var t = e1.node, n = "";
                t.arguments && t.arguments.length && (n = t.arguments.map(m).join(", "));
                var r = t.callee;
                return r.type === i.MEMBER_EXPRESSION && r.object.type === i.CALL_EXPRESSION ? {
                    name: ".".concat(r.property.name, "(").concat(n, ")"),
                    chain: !0
                } : n ? "".concat((0, u.default)(t.callee).code, "(").concat(n, ")") : (0, u.default)(t).code;
            }, m = function(e1) {
                return b(e1) ? "*()" : e1.type === i.OBJECT_EXPRESSION ? T() : e1.name ? e1.name : e1.value ? e1.type === i.STRING_LITERAL ? "'".concat(e1.value, "'") : e1.value : (0, u.default)(e1).code;
            }, T = function(e1) {
                return e1 ? {
                    name: "{*}",
                    pathParentType: e1.parent.type
                } : "{*}";
            }, g = function(e1) {
                return [
                    i.FUNCTION_EXPRESSION,
                    i.FUNCTION,
                    i.ARROW_FUNCTION_EXPRESSION,
                    i.FUNCTION_DECLARATION
                ].includes(e1);
            }, b = function(e1) {
                var t = [
                    i.ARROW_FUNCTION_EXPRESSION,
                    i.FUNCTION_EXPRESSION
                ];
                return e1 && -1 !== t.indexOf(e1.type);
            }, E = function(e1) {
                var t = e1.declaration, n = e1.specifiers;
                return t ? " " + S(t) : n ? "" : (0, u.default)(n).code;
            }, S = function(e1) {
                return -1 !== [
                    i.FUNCTION_DECLARATION,
                    i.ARROW_FUNCTION_EXPRESSION
                ].indexOf(e1.type) ? e1.id ? e1.id.name : "function" : e1.type === i.VARIABLE_DECLARATION ? e1.declarations[0].id.name : e1.type === i.IDENTIFIER ? e1.name : e1.type === i.ASSIGNMENT_EXPRESSION ? e1.left.name : void 0;
            };
            function P(e1) {
                return P = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e1) {
                    return typeof e1;
                } : function(e1) {
                    return e1 && "function" == typeof Symbol && e1.constructor === Symbol && e1 !== Symbol.prototype ? "symbol" : typeof e1;
                }, P(e1);
            }
            function x(e1, t, n) {
                return (t = function(e1) {
                    var t = function(e1, t) {
                        if ("object" !== P(e1) || null === e1) return e1;
                        var n = e1[Symbol.toPrimitive];
                        if (void 0 !== n) {
                            var r = n.call(e1, "string");
                            if ("object" !== P(r)) return r;
                            throw new TypeError("@@toPrimitive must return a primitive value.");
                        }
                        return String(e1);
                    }(e1);
                    return "symbol" === P(t) ? t : String(t);
                }(t)) in e1 ? Object.defineProperty(e1, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e1[t] = n, e1;
            }
            var D = function(e1) {
                var t = e1.getStatementParent(), n = e1.parent || {};
                return ![
                    s.CONSEQUENT,
                    s.ALTERNATE
                ].includes(e1.key) && ([
                    "params"
                ].includes(e1.listKey) || t.isReturnStatement() && "body" !== e1.key || (t.isLoop() || t.isConditional() || n.type === i.CONDITIONAL_EXPRESSION) && [
                    "test",
                    "left",
                    "right"
                ].includes(e1.parentKey) || [
                    i.RETURN,
                    i.CALL_EXPRESSION,
                    i.BINARY_EXPRESSION,
                    i.UPDATE_EXPRESSION,
                    i.ASSIGNMENT_EXPRESSION,
                    i.LOGICAL_EXPRESSION,
                    i.VARIABLE_DECLARATOR,
                    i.MEMBER_EXPRESSION,
                    i.NEW_EXPRESSION,
                    i.FUNCTION_DECLARATION,
                    i.FUNCTION_EXPRESSION,
                    i.ARROW_FUNCTION_EXPRESSION,
                    i.FUNCTION,
                    i.OBJECT_PROPERTY,
                    i.ASSIGNMENT_PATTERN,
                    i.REST_PROPERTY,
                    i.SPREAD_ELEMENT,
                    i.ARRAY_EXPRESSION,
                    i.UNARY_EXPRESSION,
                    i.IMPORT_DEFAULT_SPECIFIER,
                    i.IMPORT_SPECIFIER,
                    i.IMPORT_DECLARATION,
                    i.EXPORT_DEFAULT_DECLARATION,
                    i.EXPORT_NAMED_DECLARATION,
                    i.CLASS_DECLARATION,
                    i.CLASS_METHOD,
                    i.SWITCH_STATEMENT,
                    i.SWITCH_CASE
                ].includes(n.type) && (!n.body || n.body.type !== e1.node.type));
            }, A = (x(e1 = {}, i.FUNCTION, {
                type: i.FUNCTION,
                getName: function(e1) {
                    var t, n = e1.node, r = (t = n.params, "(".concat(t.map(function(e1) {
                        return e1.name ? e1.name : (0, u.default)(e1).code;
                    }).join(", "), ")"));
                    return {
                        name: n.id ? h(e1) + "function " + n.id.name + r : n.type === i.ARROW_FUNCTION_EXPRESSION ? h(e1) + r + " =>" : n.type === i.CLASS_METHOD || n.type === i.OBJECT_METHOD ? "constructor" === n.kind ? "constructor" + r : n.key.name + r : h(e1) + "function" + r,
                        pathParentType: e1.parent.type
                    };
                },
                body: !0
            }), x(e1, i.RETURN, {
                type: i.RETURN,
                getName: function(e1) {
                    var t = e1.node;
                    return t.argument && ([
                        i.CONDITIONAL_EXPRESSION,
                        i.OBJECT_EXPRESSION
                    ].includes(t.argument.type) || g(t.argument.type)) ? "return" : e1.node.argument ? "return ".concat((0, u.default)(e1.node.argument).code) : "return";
                },
                body: !0
            }), x(e1, i.VARIABLE_DECLARATOR, {
                type: i.VARIABLE_DECLARATOR,
                body: !0,
                getName: d,
                ignore: function(e1) {
                    var t = e1.getStatementParent();
                    return !e1.node.init || b(e1.node.init) || t.isLoop();
                }
            }), x(e1, i.ASSIGNMENT_EXPRESSION, {
                type: i.ASSIGNMENT_EXPRESSION,
                body: !0,
                getName: function(e1) {
                    var t = e1.node;
                    return b(t.right) || t.right.type === i.CONDITIONAL_EXPRESSION ? "".concat(f(t.left), " ").concat(t.operator, " ") : t.right.type === i.OBJECT_EXPRESSION ? "".concat(f(t.left), " ").concat(t.operator, " ").concat(T()) : [
                        i.CALL_EXPRESSION,
                        i.NEW_EXPRESSION
                    ].includes(t.right.type) ? "".concat(f(t.left), " ").concat(t.operator, " ").concat(y({
                        node: t.right
                    })) : (0, u.default)(t).code;
                },
                ignore: function(e1) {
                    var t = e1.getStatementParent();
                    return t.isVariableDeclaration() || e1.parent.type === i.LOGICAL_EXPRESSION || t.isConditional() && e1.key === s.TEST || b(e1.node.right);
                }
            }), x(e1, i.CALL_EXPRESSION, {
                type: i.CALL_EXPRESSION,
                body: !1,
                reversed: !0,
                getName: y,
                ignore: function(e1) {
                    var t = e1.getStatementParent(), n = e1.parent || {};
                    return n.type !== i.ARROW_FUNCTION_EXPRESSION && (t.isVariableDeclaration() || [
                        i.RETURN,
                        i.CALL_EXPRESSION,
                        i.NEW_EXPRESSION,
                        i.UNARY_EXPRESSION,
                        i.BINARY_EXPRESSION
                    ].includes(n.type) || t.isConditional() && n.test && n.test.type === i.CALL_EXPRESSION || e1.parent.type === i.ASSIGNMENT_EXPRESSION);
                }
            }), x(e1, i.UPDATE_EXPRESSION, {
                type: i.UPDATE_EXPRESSION,
                getName: p,
                ignore: function(e1) {
                    return e1.getStatementParent().isVariableDeclaration();
                }
            }), x(e1, i.NEW_EXPRESSION, {
                type: i.NEW_EXPRESSION,
                getName: p,
                ignore: function(e1) {
                    return e1.getStatementParent().isVariableDeclaration() || e1.parent.type === i.ASSIGNMENT_EXPRESSION || e1.parent.type === i.THROW_STATEMENT;
                }
            }), x(e1, i.LOOP, {
                type: i.LOOP,
                getName: function(e1) {
                    var t = e1.node;
                    if (t.test) return (0, u.default)(t.test).code;
                    if (t.left && t.right) {
                        var n = t.type === i.FOR_OF_STATEMENT ? "of" : "in", r = t.left.type === i.VARIABLE_DECLARATION ? t.left.declarations.map(function(e1) {
                            return d({
                                node: e1
                            });
                        }).join(", ") : (0, u.default)(t.left).code;
                        return "".concat(r, " ").concat(n, " ").concat((0, u.default)(t.right).code);
                    }
                },
                body: !0
            }), x(e1, i.CONTINUE, {
                type: i.CONTINUE,
                getName: function(e1) {
                    return e1.node.label ? "continue ".concat((0, u.default)(e1.node.label).code) : "continue";
                },
                body: !0
            }), x(e1, i.CONDITIONAL, {
                type: i.CONDITIONAL,
                getName: function(e1) {
                    return "(".concat((0, u.default)(e1.node.test).code, ")");
                },
                body: !0
            }), x(e1, i.SWITCH_STATEMENT, {
                type: i.SWITCH_STATEMENT,
                getName: function(e1) {
                    return "switch (".concat((0, u.default)(e1.node.discriminant).code, ")");
                },
                body: !0
            }), x(e1, i.SWITCH_CASE, {
                type: i.SWITCH_CASE,
                getName: function(e1) {
                    return e1.node.test ? "case ".concat((0, u.default)(e1.node.test).code, ":") : "default:";
                },
                body: !0
            }), x(e1, i.BREAK, {
                type: i.BREAK,
                getName: function(e1) {
                    return e1.node.label ? "break ".concat((0, u.default)(e1.node.label).code, ":") : "break";
                },
                body: !0
            }), x(e1, i.TRY_STATEMENT, {
                type: i.TRY_STATEMENT,
                getName: function(e1) {
                    return "try";
                },
                body: !0
            }), x(e1, i.CATCH_CLAUSE, {
                type: i.CATCH_CLAUSE,
                getName: function(e1) {
                    return e1.node.param ? "catch (".concat((0, u.default)(e1.node.param).code, ")") : "*catchConverter*";
                },
                body: !0
            }), x(e1, i.WITH_STATEMENT, {
                type: i.WITH_STATEMENT,
                getName: function(e1) {
                    return "with (".concat((0, u.default)(e1.node.object).code, ")");
                },
                body: !0
            }), x(e1, i.PROGRAM, {
                type: i.PROGRAM,
                getName: function(e1) {
                    return "".concat(e1.node.type, ": source ").concat(e1.node.sourceType);
                },
                body: !0
            }), x(e1, i.THROW_STATEMENT, {
                type: i.THROW_STATEMENT,
                getName: function(e1) {
                    return "throw ".concat((0, u.default)(e1.node.argument).code);
                },
                body: !0
            }), x(e1, i.DEBUGGER_STATEMENT, {
                type: i.DEBUGGER_STATEMENT,
                getName: function(e1) {
                    return "debugger";
                },
                body: !0
            }), x(e1, i.BINARY_EXPRESSION, {
                type: i.BINARY_EXPRESSION,
                getName: p,
                ignore: D
            }), x(e1, i.IDENTIFIER, {
                type: i.IDENTIFIER,
                getName: function(e1) {
                    return e1.parent.type === i.SPREAD_PROPERTY ? "..." + p(e1) : p(e1);
                },
                ignore: D
            }), x(e1, i.STRING_LITERAL, {
                type: i.STRING_LITERAL,
                getName: p,
                ignore: D
            }), x(e1, i.NUMERIC_LITERAL, {
                type: i.NUMERIC_LITERAL,
                getName: p,
                ignore: D
            }), x(e1, i.OBJECT_EXPRESSION, {
                type: i.OBJECT_EXPRESSION,
                getName: T,
                ignore: function(e1) {
                    var t = e1.node;
                    return !(!t.properties || t.properties.length) || [
                        i.OBJECT_PROPERTY,
                        i.ASSIGNMENT_EXPRESSION,
                        i.VARIABLE_DECLARATOR
                    ].includes(e1.parent.type);
                },
                body: !0
            }), x(e1, i.OBJECT_PROPERTY, {
                type: i.OBJECT_PROPERTY,
                getName: function(e1) {
                    var t = e1.node;
                    return t.value && g(t.value.type) ? t.key.name + ": " : t.value && t.value.type === i.OBJECT_EXPRESSION ? t.key.name + ": " + T() : (0, u.default)(t).code;
                },
                ignore: function(e1) {
                    var t = e1.parentPath;
                    return [
                        "params",
                        "left"
                    ].includes(t.parentKey);
                },
                body: !0
            }), x(e1, i.IMPORT_DECLARATION, {
                type: i.IMPORT_DECLARATION,
                getName: function(e1) {
                    var t = e1.node;
                    return "import from" + (0, u.default)(t.source).code;
                },
                body: !0
            }), x(e1, i.IMPORT_DEFAULT_SPECIFIER, {
                type: i.IMPORT_DEFAULT_SPECIFIER,
                getName: p
            }), x(e1, i.IMPORT_SPECIFIER, {
                type: i.IMPORT_SPECIFIER,
                getName: p
            }), x(e1, i.EXPORT_DEFAULT_DECLARATION, {
                type: i.EXPORT_DEFAULT_DECLARATION,
                getName: function(e1) {
                    var t = e1.node;
                    return "export default ".concat(E(t));
                },
                body: !0
            }), x(e1, i.EXPORT_NAMED_DECLARATION, {
                type: i.EXPORT_NAMED_DECLARATION,
                getName: function(e1) {
                    var t = e1.node;
                    return "export".concat(E(t));
                },
                body: !0
            }), x(e1, i.CLASS_DECLARATION, {
                type: i.CLASS_DECLARATION,
                getName: function(e1) {
                    var t = e1.node;
                    return "class ".concat((0, u.default)(t.id).code, " ").concat(t.superClass ? " extends ".concat((0, u.default)(t.superClass).code) : "");
                },
                body: !0
            }), x(e1, i.OBJECT_PATTERN, {
                type: i.OBJECT_PATTERN,
                getName: function() {
                    return "{...}";
                },
                ignore: function(e1) {
                    return "params" === e1.listKey || [
                        i.VARIABLE_DECLARATOR,
                        i.ASSIGNMENT_PATTERN
                    ].includes(e1.parent.type);
                },
                body: !0
            }), x(e1, i.ARRAY_PATTERN, {
                type: i.ARRAY_PATTERN,
                getName: function() {
                    return "[...]";
                },
                ignore: function(e1) {
                    return "params" === e1.listKey || [
                        i.VARIABLE_DECLARATOR,
                        i.ASSIGNMENT_PATTERN
                    ].includes(e1.parent.type);
                },
                body: !0
            }), e1), v = Object.keys(A).map(function(e1) {
                return A[e1];
            }), C = n(7191), w = n(9996), O = n.n(w);
            function I(e1, t) {
                (null == t || t > e1.length) && (t = e1.length);
                for(var n = 0, r = new Array(t); n < t; n++)r[n] = e1[n];
                return r;
            }
            var N = function(e1, t) {
                return Object.assign.apply(null, [
                    {
                        state: e1
                    }
                ].concat(function(e1) {
                    if (Array.isArray(e1)) return I(e1);
                }(n = t.map(function(t) {
                    return t(e1);
                })) || function(e1) {
                    if ("undefined" != typeof Symbol && null != e1[Symbol.iterator] || null != e1["@@iterator"]) return Array.from(e1);
                }(n) || function(e1, t) {
                    if (e1) {
                        if ("string" == typeof e1) return I(e1, t);
                        var n = Object.prototype.toString.call(e1).slice(8, -1);
                        return "Object" === n && e1.constructor && (n = e1.constructor.name), "Map" === n || "Set" === n ? Array.from(e1) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? I(e1, t) : void 0;
                    }
                }(n) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }()));
                "TURBOPACK unreachable";
                var n;
            }, F = function(e1, t) {
                return O()(e1, t);
            }, k = function(e1) {
                return {
                    list: e1 ? [
                        e1
                    ] : [],
                    getCurrent: function() {
                        if (this.list.length) return this.list[this.list.length - 1];
                    },
                    stepIn: function(e1) {
                        this.list.push(e1);
                    },
                    stepOut: function() {
                        this.list.pop();
                    }
                };
            }, L = function(e1) {
                console.error(e1);
            };
            const _ = {
                sourceType: "module",
                plugins: [
                    "objectRestSpread",
                    "jsx",
                    "typescript",
                    "classProperties",
                    "asyncGenerators",
                    "dynamicImport",
                    "exportDefaultFrom",
                    "exportNamespaceFrom",
                    "optionalChaining",
                    "nullishCoalescingOperator"
                ]
            };
            function M(e1) {
                return M = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e1) {
                    return typeof e1;
                } : function(e1) {
                    return e1 && "function" == typeof Symbol && e1.constructor === Symbol && e1 !== Symbol.prototype ? "symbol" : typeof e1;
                }, M(e1);
            }
            function B(e1, t) {
                var n = Object.keys(e1);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e1);
                    t && (r = r.filter(function(t) {
                        return Object.getOwnPropertyDescriptor(e1, t).enumerable;
                    })), n.push.apply(n, r);
                }
                return n;
            }
            function j(e1) {
                for(var t = 1; t < arguments.length; t++){
                    var n = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? B(Object(n), !0).forEach(function(t) {
                        var r, i, s;
                        r = e1, i = t, s = n[t], (i = function(e1) {
                            var t = function(e1, t) {
                                if ("object" !== M(e1) || null === e1) return e1;
                                var n = e1[Symbol.toPrimitive];
                                if (void 0 !== n) {
                                    var r = n.call(e1, "string");
                                    if ("object" !== M(r)) return r;
                                    throw new TypeError("@@toPrimitive must return a primitive value.");
                                }
                                return String(e1);
                            }(e1);
                            return "symbol" === M(t) ? t : String(t);
                        }(i)) in r ? Object.defineProperty(r, i, {
                            value: s,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : r[i] = s;
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e1, Object.getOwnPropertyDescriptors(n)) : B(Object(n)).forEach(function(t) {
                        Object.defineProperty(e1, t, Object.getOwnPropertyDescriptor(n, t));
                    });
                }
                return e1;
            }
            var R = function(e1) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = [];
                try {
                    n = C.parse(e1, F(_, t));
                } catch (e1) {
                    throw L("Error at parseCodeToAST: " + e1.message, e1.loc, e1.stack), e1;
                }
                return n;
            }, U = function(e1, t) {
                return function(n, r) {
                    if (!e1.ignore || !e1.ignore(n)) {
                        var i = j({}, q(e1, n));
                        r && r(i) || W(t, i);
                    }
                };
            }, V = function(e1, t) {
                return function(n, r) {
                    if (!e1.ignore || !e1.ignore(n)) {
                        var i = K(e1, t, n, r);
                        t.stepIn(i);
                    }
                };
            }, K = function(e1, t, n, r) {
                var i = j(j({}, q(e1, n)), {}, {
                    body: []
                });
                return r && r(i) || W(t, i), i;
            }, W = function(e1, t) {
                var n = e1.getCurrent();
                t.parent = n, (n.body || n).push(t);
            }, X = function(e1) {
                var t = e1.find(function(e1) {
                    return e1.parentKey === s.PROGRAM || e1.isStatementOrBlock();
                }) || {};
                return t.key;
            }, Y = function(e1, t) {
                return function(n) {
                    e1.ignore && e1.ignore(n) || t.stepOut();
                };
            }, q = function(e1, t) {
                var n = e1.getName(t), r = j(j({}, "string" == typeof n ? {
                    name: n
                } : n), {}, {
                    type: e1.type,
                    key: X(t),
                    isBodyEntry: t.key === s.BODY
                });
                return r.name || (r.name = ""), e1.type !== t.node.type && (r.subType = t.node.type), r;
            };
            function H(e1) {
                return H = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e1) {
                    return typeof e1;
                } : function(e1) {
                    return e1 && "function" == typeof Symbol && e1.constructor === Symbol && e1 !== Symbol.prototype ? "symbol" : typeof e1;
                }, H(e1);
            }
            function J(e1, t) {
                var n = Object.keys(e1);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e1);
                    t && (r = r.filter(function(t) {
                        return Object.getOwnPropertyDescriptor(e1, t).enumerable;
                    })), n.push.apply(n, r);
                }
                return n;
            }
            function $(e1) {
                for(var t = 1; t < arguments.length; t++){
                    var n = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? J(Object(n), !0).forEach(function(t) {
                        var r, i, s;
                        r = e1, i = t, s = n[t], (i = function(e1) {
                            var t = function(e1, t) {
                                if ("object" !== H(e1) || null === e1) return e1;
                                var n = e1[Symbol.toPrimitive];
                                if (void 0 !== n) {
                                    var r = n.call(e1, "string");
                                    if ("object" !== H(r)) return r;
                                    throw new TypeError("@@toPrimitive must return a primitive value.");
                                }
                                return String(e1);
                            }(e1);
                            return "symbol" === H(t) ? t : String(t);
                        }(i)) in r ? Object.defineProperty(r, i, {
                            value: s,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : r[i] = s;
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e1, Object.getOwnPropertyDescriptors(n)) : J(Object(n)).forEach(function(t) {
                        Object.defineProperty(e1, t, Object.getOwnPropertyDescriptor(n, t));
                    });
                }
                return e1;
            }
            var G = function() {
                var e1 = A[i.FUNCTION];
                return $($({}, e1), {}, {
                    getName: function(t) {
                        var n = e1.getName(t);
                        return t.parent.type === i.OBJECT_PROPERTY && t.parent.key && (n = $($({}, n), {}, {
                            name: t.parent.key.name + ": " + n.name
                        })), n;
                    },
                    ignore: function(t) {
                        return e1.ignore && e1.ignore(t) || t.parent.type === i.CALL_EXPRESSION;
                    }
                });
            };
            function z(e1) {
                return z = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e1) {
                    return typeof e1;
                } : function(e1) {
                    return e1 && "function" == typeof Symbol && e1.constructor === Symbol && e1 !== Symbol.prototype ? "symbol" : typeof e1;
                }, z(e1);
            }
            function Q(e1, t) {
                var n = Object.keys(e1);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e1);
                    t && (r = r.filter(function(t) {
                        return Object.getOwnPropertyDescriptor(e1, t).enumerable;
                    })), n.push.apply(n, r);
                }
                return n;
            }
            function Z(e1) {
                for(var t = 1; t < arguments.length; t++){
                    var n = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? Q(Object(n), !0).forEach(function(t) {
                        var r, i, s;
                        r = e1, i = t, s = n[t], (i = function(e1) {
                            var t = function(e1, t) {
                                if ("object" !== z(e1) || null === e1) return e1;
                                var n = e1[Symbol.toPrimitive];
                                if (void 0 !== n) {
                                    var r = n.call(e1, "string");
                                    if ("object" !== z(r)) return r;
                                    throw new TypeError("@@toPrimitive must return a primitive value.");
                                }
                                return String(e1);
                            }(e1);
                            return "symbol" === z(t) ? t : String(t);
                        }(i)) in r ? Object.defineProperty(r, i, {
                            value: s,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : r[i] = s;
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e1, Object.getOwnPropertyDescriptors(n)) : Q(Object(n)).forEach(function(t) {
                        Object.defineProperty(e1, t, Object.getOwnPropertyDescriptor(n, t));
                    });
                }
                return e1;
            }
            var ee = function(e1) {
                return e1 && e1.type === i.CALL_EXPRESSION;
            };
            function te(e1) {
                return te = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e1) {
                    return typeof e1;
                } : function(e1) {
                    return e1 && "function" == typeof Symbol && e1.constructor === Symbol && e1 !== Symbol.prototype ? "symbol" : typeof e1;
                }, te(e1);
            }
            function ne(e1) {
                return function(e1) {
                    if (Array.isArray(e1)) return re(e1);
                }(e1) || function(e1) {
                    if ("undefined" != typeof Symbol && null != e1[Symbol.iterator] || null != e1["@@iterator"]) return Array.from(e1);
                }(e1) || function(e1, t) {
                    if (e1) {
                        if ("string" == typeof e1) return re(e1, t);
                        var n = Object.prototype.toString.call(e1).slice(8, -1);
                        return "Object" === n && e1.constructor && (n = e1.constructor.name), "Map" === n || "Set" === n ? Array.from(e1) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? re(e1, t) : void 0;
                    }
                }(e1) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }();
            }
            function re(e1, t) {
                (null == t || t > e1.length) && (t = e1.length);
                for(var n = 0, r = new Array(t); n < t; n++)r[n] = e1[n];
                return r;
            }
            var ie, se, ae = {
                FUNCTION: {
                    defined: [],
                    custom: [
                        G()
                    ]
                },
                FUNCTION_DEPENDENCIES: {
                    defined: [
                        i.CALL_EXPRESSION
                    ],
                    custom: [
                        G(),
                        (se = A[i.ASSIGNMENT_EXPRESSION], Z(Z({}, se), {}, {
                            getName: function(e1) {
                                var t = e1.node;
                                return y({
                                    node: t.right
                                });
                            },
                            ignore: function(e1) {
                                return se.ignore(e1) || !ee(e1.node.right);
                            }
                        })),
                        (ie = A[i.VARIABLE_DECLARATOR], Z(Z({}, ie), {}, {
                            getName: function(e1) {
                                var t = e1.node;
                                return y({
                                    node: t.init
                                });
                            },
                            ignore: function(e1) {
                                return ie.ignore(e1) || !ee(e1.node.init);
                            }
                        }))
                    ]
                },
                CLASS: [
                    i.CLASS_DECLARATION
                ],
                IMPORT: [
                    i.IMPORT_DECLARATION,
                    i.IMPORT_SPECIFIER,
                    i.IMPORT_DEFAULT_SPECIFIER
                ],
                EXPORT: [
                    i.EXPORT_NAMED_DECLARATION,
                    i.EXPORT_DEFAULT_DECLARATION
                ]
            };
            function oe(e1) {
                return function(e1) {
                    if (Array.isArray(e1)) return le(e1);
                }(e1) || function(e1) {
                    if ("undefined" != typeof Symbol && null != e1[Symbol.iterator] || null != e1["@@iterator"]) return Array.from(e1);
                }(e1) || function(e1, t) {
                    if (e1) {
                        if ("string" == typeof e1) return le(e1, t);
                        var n = Object.prototype.toString.call(e1).slice(8, -1);
                        return "Object" === n && e1.constructor && (n = e1.constructor.name), "Map" === n || "Set" === n ? Array.from(e1) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? le(e1, t) : void 0;
                    }
                }(e1) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }();
            }
            function le(e1, t) {
                (null == t || t > e1.length) && (t = e1.length);
                for(var n = 0, r = new Array(t); n < t; n++)r[n] = e1[n];
                return r;
            }
            var ce = function e1(t, n, r, i) {
                var s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {}, a = s.getBody || function(e1) {
                    return e1.body;
                };
                n(t), a(t).forEach(function(t) {
                    r(t), a(t) && e1(t, n, r, i, s);
                }), i(t);
            }, ue = function(e1, t) {
                for(var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function(e1) {
                    return e1.body;
                }, r = [].concat(e1); r.length;){
                    var i = r.shift();
                    t(i);
                    var s = n(i);
                    s && (r = [].concat(oe(r), oe(s)));
                }
            }, pe = function(e1, t) {
                return "function" == typeof e1 ? e1(t) : e1;
            }, he = {
                name: function(e1, t) {
                    e1.name = pe(t, e1);
                },
                prefixName: function(e1, t) {
                    e1.prefixName = pe(t, e1);
                },
                type: function(e1, t) {
                    e1.type = pe(t, e1);
                },
                body: function(e1, t) {
                    e1.body = pe(t, e1);
                },
                parent: function(e1, t) {
                    e1.parent = pe(t, e1);
                }
            };
            function de(e1) {
                return function(e1) {
                    if (Array.isArray(e1)) return fe(e1);
                }(e1) || function(e1) {
                    if ("undefined" != typeof Symbol && null != e1[Symbol.iterator] || null != e1["@@iterator"]) return Array.from(e1);
                }(e1) || function(e1, t) {
                    if (e1) {
                        if ("string" == typeof e1) return fe(e1, t);
                        var n = Object.prototype.toString.call(e1).slice(8, -1);
                        return "Object" === n && e1.constructor && (n = e1.constructor.name), "Map" === n || "Set" === n ? Array.from(e1) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? fe(e1, t) : void 0;
                    }
                }(e1) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }();
            }
            function fe(e1, t) {
                (null == t || t > e1.length) && (t = e1.length);
                for(var n = 0, r = new Array(t); n < t; n++)r[n] = e1[n];
                return r;
            }
            var ye = function(e1, t) {
                var n = e1.name.split(".".concat(t, "("))[0];
                return n.includes("=") ? n.split("=") : [
                    n
                ];
            }, me = function(e1, t) {
                return e1.name.includes(".".concat(t, "("));
            }, Te = {
                forEach: {
                    test: function(e1) {
                        return me(e1, "forEach");
                    },
                    updates: {
                        name: function(e1) {
                            return "each in  ".concat(ye(e1, "forEach")[0]);
                        },
                        type: i.LOOP,
                        body: function(e1) {
                            return de(e1.body[0].body);
                        }
                    }
                },
                filter: {
                    test: function(e1) {
                        return me(e1, "filter");
                    },
                    updates: {
                        name: function(e1) {
                            return "in ".concat(ye(e1, "filter")[1], " to ").concat(ye(e1, "filter")[0]);
                        },
                        prefixName: "filter",
                        type: i.LOOP
                    }
                },
                map: {
                    test: function(e1) {
                        return me(e1, "map");
                    },
                    updates: {
                        name: function(e1) {
                            return "from ".concat(ye(e1, "map")[1], " to ").concat(ye(e1, "map")[0]);
                        },
                        prefixName: "map",
                        type: i.LOOP
                    }
                }
            }, ge = {
                es5ArrayIterators: [
                    Te.forEach,
                    Te.filter,
                    Te.map
                ]
            };
            function be(e1) {
                return be = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e1) {
                    return typeof e1;
                } : function(e1) {
                    return e1 && "function" == typeof Symbol && e1.constructor === Symbol && e1 !== Symbol.prototype ? "symbol" : typeof e1;
                }, be(e1);
            }
            function Ee(e1) {
                return function(e1) {
                    if (Array.isArray(e1)) return Se(e1);
                }(e1) || function(e1) {
                    if ("undefined" != typeof Symbol && null != e1[Symbol.iterator] || null != e1["@@iterator"]) return Array.from(e1);
                }(e1) || function(e1, t) {
                    if (e1) {
                        if ("string" == typeof e1) return Se(e1, t);
                        var n = Object.prototype.toString.call(e1).slice(8, -1);
                        return "Object" === n && e1.constructor && (n = e1.constructor.name), "Map" === n || "Set" === n ? Array.from(e1) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Se(e1, t) : void 0;
                    }
                }(e1) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }();
            }
            function Se(e1, t) {
                (null == t || t > e1.length) && (t = e1.length);
                for(var n = 0, r = new Array(t); n < t; n++)r[n] = e1[n];
                return r;
            }
            function Pe(e1, t) {
                var n = Object.keys(e1);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e1);
                    t && (r = r.filter(function(t) {
                        return Object.getOwnPropertyDescriptor(e1, t).enumerable;
                    })), n.push.apply(n, r);
                }
                return n;
            }
            function xe(e1) {
                for(var t = 1; t < arguments.length; t++){
                    var n = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? Pe(Object(n), !0).forEach(function(t) {
                        var r, i, s;
                        r = e1, i = t, s = n[t], (i = function(e1) {
                            var t = function(e1, t) {
                                if ("object" !== be(e1) || null === e1) return e1;
                                var n = e1[Symbol.toPrimitive];
                                if (void 0 !== n) {
                                    var r = n.call(e1, "string");
                                    if ("object" !== be(r)) return r;
                                    throw new TypeError("@@toPrimitive must return a primitive value.");
                                }
                                return String(e1);
                            }(e1);
                            return "symbol" === be(t) ? t : String(t);
                        }(i)) in r ? Object.defineProperty(r, i, {
                            value: s,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : r[i] = s;
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e1, Object.getOwnPropertyDescriptors(n)) : Pe(Object(n)).forEach(function(t) {
                        Object.defineProperty(e1, t, Object.getOwnPropertyDescriptor(n, t));
                    });
                }
                return e1;
            }
            var De = function() {
                var e1, t = (e1 = [], {
                    addModifier: function(t) {
                        [].concat(t).forEach(function(t) {
                            return e1.push(t);
                        });
                    },
                    create: function(e1, t) {
                        this.addModifier({
                            test: e1,
                            updates: t
                        });
                    },
                    runModifier: function(e1, t) {
                        !function(e1, t) {
                            var n = function(e1, t) {
                                var n = [];
                                return ue(e1, function(e1) {
                                    t(e1) && n.push(e1);
                                }), n;
                            }(e1, t.test);
                            if (n.length) {
                                var r = Object.keys(t.updates || {});
                                r.filter(function(e1) {
                                    return "subTreeUpdate" !== e1;
                                }).forEach(function(e1) {
                                    n.forEach(function(n) {
                                        he[e1](n, t.updates[e1]);
                                    });
                                }), r.includes("subTreeUpdate") && t.updates.subTreeUpdate(n, e1);
                            }
                        }(e1, t);
                    },
                    applyTo: function(t) {
                        var n = this;
                        e1.forEach(function(e1) {
                            return n.runModifier(t, e1);
                        });
                    }
                });
                return {
                    setModifier: function(e1) {
                        t.addModifier(e1);
                    },
                    registerNewModifier: function(e1, n) {
                        t.create(e1, n);
                    },
                    destructNodeTree: function(e1, t) {
                        this.setModifier(function(e1, t) {
                            return {
                                test: e1,
                                updates: {
                                    name: t,
                                    body: [],
                                    type: c.DESTRUCTED
                                }
                            };
                        }(e1, t));
                    },
                    applyToFlowTree: function(e1) {
                        return t.applyTo(e1), e1;
                    }
                };
            };
            const Ae = function() {
                var e1 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n = e1.astParser, r = void 0 === n ? {} : n, s = e1.astVisitor, a = void 0 === s ? {} : s, o = xe({}, r), l = xe({
                    definitionsMap: Ee(v),
                    globalIgnore: null
                }, a), c = De();
                return c.setModifier({
                    test: function(e1) {
                        return e1.pathParentType === i.CALL_EXPRESSION;
                    },
                    updates: {
                        subTreeUpdate: function(e1) {
                            e1.forEach(function(e1) {
                                for(var t = e1.parent.body, n = t.indexOf(e1) + 1; n < t.length; n++){
                                    var r = t[n];
                                    if (r && r.type === i.CALL_EXPRESSION) return e1.parent.body = t.filter(function(t) {
                                        return t !== e1;
                                    }), void (r.body = [].concat(de(r.body || []), [
                                        e1
                                    ]));
                                }
                            });
                        }
                    }
                }), c.setModifier({
                    test: function(e1) {
                        return e1.isBodyEntry && e1.parent && e1.parent.subType === i.ARROW_FUNCTION_EXPRESSION;
                    },
                    updates: {
                        name: function(e1) {
                            return "return " + e1.name;
                        },
                        type: i.RETURN
                    }
                }), {
                    setAbstractionLevel: function(e1) {
                        l.definitionsMap = function(e1) {
                            var t = [
                                i.PROGRAM
                            ], n = [];
                            return [].concat(e1).forEach(function(e1) {
                                return "string" == typeof e1 ? t.push(e1) : Array.isArray(e1) ? t = t.concat(ne(e1)) : void ("object" === te(e1) && (t = t.concat(ne(e1.defined || [])), n = n.concat(ne(e1.custom || []))));
                            }), v.filter(function(e1) {
                                return -1 !== t.indexOf(e1.type);
                            }).concat(n);
                        }(e1);
                    },
                    resetAbstractionLevelToNormal: function() {
                        l.definitionsMap = Ee(v);
                    },
                    setIgnoreFilter: function(e1) {
                        l.globalIgnore = e1;
                    },
                    build: function(e1) {
                        var t = this.buildAst(e1);
                        return this.buildFlowTreeFromAst(t);
                    },
                    buildAst: function(e1) {
                        return R(e1, o);
                    },
                    buildFlowTreeFromAst: function(e1) {
                        var n = [];
                        try {
                            n = function(e1, n) {
                                var r, s, a, o, l, c, u = [];
                                (0, t.default)(e1, (s = u, a = (r = n).definitionsMap, o = r.globalIgnore, l = k(s), c = function(e1) {
                                    return function(t) {
                                        return e1(t, o);
                                    };
                                }, a.reduce(function(e1, t) {
                                    return t.body ? e1[t.type] = {
                                        enter: c(V(t, l)),
                                        exit: c(Y(t, l))
                                    } : e1[t.type] = t.reversed ? {
                                        exit: c(U(t, l))
                                    } : c(U(t, l)), e1;
                                }, {})));
                                var p = u.length && u[0] || {};
                                return p.type === i.PROGRAM ? p : {
                                    name: "Root",
                                    type: i.PROGRAM,
                                    body: u
                                };
                            }(e1, l), c.applyToFlowTree(n);
                        } catch (e1) {
                            throw L("Error at buildFlowTreeFromAst" + e1.message, e1.stack), e1;
                        }
                        return n;
                    }
                };
            };
            function ve(e1) {
                return ve = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e1) {
                    return typeof e1;
                } : function(e1) {
                    return e1 && "function" == typeof Symbol && e1.constructor === Symbol && e1 !== Symbol.prototype ? "symbol" : typeof e1;
                }, ve(e1);
            }
            function Ce(e1, t) {
                var n = Object.keys(e1);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e1);
                    t && (r = r.filter(function(t) {
                        return Object.getOwnPropertyDescriptor(e1, t).enumerable;
                    })), n.push.apply(n, r);
                }
                return n;
            }
            function we(e1) {
                for(var t = 1; t < arguments.length; t++){
                    var n = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? Ce(Object(n), !0).forEach(function(t) {
                        var r, i, s;
                        r = e1, i = t, s = n[t], (i = function(e1) {
                            var t = function(e1, t) {
                                if ("object" !== ve(e1) || null === e1) return e1;
                                var n = e1[Symbol.toPrimitive];
                                if (void 0 !== n) {
                                    var r = n.call(e1, "string");
                                    if ("object" !== ve(r)) return r;
                                    throw new TypeError("@@toPrimitive must return a primitive value.");
                                }
                                return String(e1);
                            }(e1);
                            return "symbol" === ve(t) ? t : String(t);
                        }(i)) in r ? Object.defineProperty(r, i, {
                            value: s,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : r[i] = s;
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e1, Object.getOwnPropertyDescriptors(n)) : Ce(Object(n)).forEach(function(t) {
                        Object.defineProperty(e1, t, Object.getOwnPropertyDescriptor(n, t));
                    });
                }
                return e1;
            }
            var Oe = {
                strokeColor: "#444",
                defaultFillColor: "#fff",
                textColor: "#222",
                arrowFillColor: "#333",
                rectangleFillColor: "#90caf9",
                rectangleDotFillColor: "#ede7f6",
                functionFillColor: "#a5d6a7",
                rootCircleFillColor: "#fff59d",
                loopFillColor: "#b39ddb",
                conditionFillColor: "#ce93d8",
                destructedNodeFillColor: "#ffcc80",
                classFillColor: "#80cbc4",
                debuggerFillColor: "#EF5350",
                exportFillColor: "#81d4fa",
                throwFillColor: "#ef9a9a",
                tryFillColor: "#FFE082",
                objectFillColor: "#9fa8da",
                callFillColor: "#C5E1A5",
                debugModeFillColor: "#666"
            }, Ie = function(e1) {
                var t = we({
                    strokeColor: e1.strokeColor,
                    strokeWidth: 1,
                    fillColor: e1.defaultFillColor,
                    textColor: e1.textColor,
                    fontFamily: "monospace",
                    fontSize: 13,
                    lineHeight: 5,
                    symbolHeight: 10,
                    symbolWidth: 7.8,
                    horizontalPadding: 15,
                    verticalPadding: 10,
                    childOffset: 37,
                    margin: 10,
                    roundBorder: 2,
                    complexTypeExtraSpace: 15,
                    debugFontSize: 8,
                    debugTextColor: e1.debugModeFillColor
                }, e1);
                return {
                    BaseShape: t,
                    ConnectionArrow: {
                        arrow: {
                            size: {
                                x: 8,
                                y: 6
                            },
                            fillColor: e1.arrowFillColor
                        },
                        line: {
                            strokeColor: e1.strokeColor,
                            strokeWidth: 1,
                            curveTurnRadius: 4
                        },
                        lineTurnOffset: 20
                    },
                    Shape: we({}, t),
                    Rectangle: we(we({}, t), {}, {
                        fillColor: e1.rectangleFillColor,
                        dot: we(we({}, t), {}, {
                            offset: 4,
                            radius: 2,
                            fillColor: e1.rectangleDotFillColor
                        }),
                        roundBorder: 3
                    }),
                    VerticalEdgedRectangle: we(we({}, t), {}, {
                        fillColor: e1.functionFillColor,
                        edgeOffset: 10
                    }),
                    RootCircle: we(we({}, t), {}, {
                        radius: 15,
                        padding: 3,
                        fillColor: e1.rootCircleFillColor
                    }),
                    LoopRhombus: we(we({}, t), {}, {
                        fillColor: e1.loopFillColor,
                        thinPartOffset: 15,
                        rhombusSize: 50,
                        roundBorder: 3,
                        doubleLayerOffsetA: 4,
                        doubleLayerOffsetB: 8,
                        childOffset: 20,
                        positionTopShift: 20
                    }),
                    ConditionRhombus: we(we({}, t), {}, {
                        fillColor: e1.conditionFillColor,
                        thinPartOffset: 15,
                        roundBorder: 3,
                        childOffset: 20,
                        alternateBranchOffset: 40,
                        markOffset: {
                            x: 15,
                            y: 5
                        },
                        margin: 20
                    }),
                    RootStartPoint: {
                        center: {
                            x: 25,
                            y: 25
                        },
                        childOffset: {
                            x: 25,
                            y: 65
                        }
                    },
                    ReturnStatement: we(we({}, t), {}, {
                        roundBorder: 3,
                        fillColor: e1.rectangleFillColor,
                        arrow: we(we({}, t), {}, {
                            handlerLength: 5,
                            sizeX: 16,
                            sizeY: 22,
                            fillColor: e1.functionFillColor
                        })
                    }),
                    DestructedNode: we(we({}, t), {}, {
                        fillColor: e1.destructedNodeFillColor,
                        roundBorder: 2,
                        suffix: we(we({}, t), {}, {
                            roundBorder: 2,
                            fillColor: e1.destructedNodeFillColor,
                            width: 8,
                            space: 4
                        })
                    }),
                    ClassDeclaration: we(we({}, t), {}, {
                        fillColor: e1.classFillColor,
                        edgeOffset: 10
                    }),
                    DebuggerStatement: we(we({}, t), {}, {
                        fillColor: e1.debuggerFillColor,
                        roundBorder: 2
                    }),
                    ExportDeclaration: we(we({}, t), {}, {
                        roundBorder: 3,
                        fillColor: e1.exportFillColor,
                        arrow: we(we({}, t), {}, {
                            handlerLength: 5,
                            sizeX: 20,
                            sizeY: 28,
                            fillColor: e1.defaultFillColor
                        })
                    }),
                    ImportDeclaration: we(we({}, t), {}, {
                        fillColor: e1.defaultFillColor,
                        edgeOffset: 5
                    }),
                    ImportSpecifier: we(we({}, t), {}, {
                        fillColor: e1.exportFillColor
                    }),
                    ThrowStatement: we(we({}, t), {}, {
                        fillColor: e1.throwFillColor
                    }),
                    TryStatement: we(we({}, t), {}, {
                        fillColor: e1.tryFillColor
                    }),
                    CatchClause: we(we({}, t), {}, {
                        fillColor: e1.throwFillColor,
                        arrow: we(we({}, t), {}, {
                            handlerLength: 2,
                            sizeX: 16,
                            sizeY: 28,
                            fillColor: e1.throwFillColor
                        })
                    }),
                    SwitchStatement: we(we({}, t), {}, {
                        fillColor: e1.conditionFillColor,
                        thinPartOffset: 15,
                        roundBorder: 3,
                        childOffset: 20,
                        alternateBranchOffset: 40,
                        markOffset: {
                            x: 15,
                            y: 5
                        },
                        margin: 20
                    }),
                    BreakStatement: we(we({}, t), {}, {
                        fillColor: e1.rectangleFillColor,
                        arrow: we(we({}, t), {}, {
                            handlerLength: 5,
                            sizeX: 16,
                            sizeY: 28,
                            fillColor: e1.conditionFillColor
                        })
                    }),
                    SwitchCase: we(we({}, t), {}, {
                        fillColor: e1.conditionFillColor
                    }),
                    ContinueStatement: we(we({}, t), {}, {
                        fillColor: e1.rectangleFillColor,
                        arrow: we(we({}, t), {}, {
                            handlerLength: 5,
                            sizeX: 16,
                            sizeY: 28,
                            fillColor: e1.loopFillColor
                        })
                    }),
                    ObjectProperty: we(we({}, t), {}, {
                        fillColor: e1.rectangleFillColor
                    }),
                    CallExpression: we(we({}, t), {}, {
                        dot: we(we({}, t), {}, {
                            offset: 6,
                            radius: 4,
                            fillColor: e1.rectangleDotFillColor
                        }),
                        fillColor: e1.callFillColor
                    })
                };
            };
            const Ne = Ie(Oe);
            function Fe(e1) {
                return Fe = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e1) {
                    return typeof e1;
                } : function(e1) {
                    return e1 && "function" == typeof Symbol && e1.constructor === Symbol && e1 !== Symbol.prototype ? "symbol" : typeof e1;
                }, Fe(e1);
            }
            function ke(e1, t) {
                var n = Object.keys(e1);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e1);
                    t && (r = r.filter(function(t) {
                        return Object.getOwnPropertyDescriptor(e1, t).enumerable;
                    })), n.push.apply(n, r);
                }
                return n;
            }
            function Le(e1) {
                for(var t = 1; t < arguments.length; t++){
                    var n = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? ke(Object(n), !0).forEach(function(t) {
                        var r, i, s;
                        r = e1, i = t, s = n[t], (i = function(e1) {
                            var t = function(e1, t) {
                                if ("object" !== Fe(e1) || null === e1) return e1;
                                var n = e1[Symbol.toPrimitive];
                                if (void 0 !== n) {
                                    var r = n.call(e1, "string");
                                    if ("object" !== Fe(r)) return r;
                                    throw new TypeError("@@toPrimitive must return a primitive value.");
                                }
                                return String(e1);
                            }(e1);
                            return "symbol" === Fe(t) ? t : String(t);
                        }(i)) in r ? Object.defineProperty(r, i, {
                            value: s,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : r[i] = s;
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e1, Object.getOwnPropertyDescriptors(n)) : ke(Object(n)).forEach(function(t) {
                        Object.defineProperty(e1, t, Object.getOwnPropertyDescriptor(n, t));
                    });
                }
                return e1;
            }
            var _e, Me = Le(Le({}, (_e = we({}, Oe), Object.keys(_e).forEach(function(e1) {
                _e[e1] = "#A6A6A6";
            }), _e)), {}, {
                strokeColor: "#333",
                defaultFillColor: "#A6A6A6",
                textColor: "#333",
                arrowFillColor: "#333"
            });
            const Be = Ie(Me), je = Ie({
                strokeColor: "#ccc",
                defaultFillColor: "#fff",
                textColor: "#ccc",
                arrowFillColor: "#ccc",
                rectangleFillColor: "#ede7f6",
                rectangleDotFillColor: "#ede7f6",
                functionFillColor: "#f1f8e9",
                rootCircleFillColor: "#fffde7",
                loopFillColor: "#e3f2fd",
                conditionFillColor: "#f3e5f5",
                destructedNodeFillColor: "#fff8e1",
                classFillColor: "#e0f2f1",
                debuggerFillColor: "#ffebee",
                exportFillColor: "#e1f5fe",
                throwFillColor: "#fce4ec",
                tryFillColor: "#fff8e1",
                objectFillColor: "#f9fbe7",
                callFillColor: "#f9fbe7",
                debugModeFillColor: "#666"
            }), Re = Ie({
                strokeColor: "#555",
                defaultFillColor: "#fff",
                textColor: "#333",
                arrowFillColor: "#444",
                rectangleFillColor: "#bbdefb",
                rectangleDotFillColor: "#ede7f6",
                functionFillColor: "#c8e6c9",
                rootCircleFillColor: "#fff9c4",
                loopFillColor: "#d1c4e9",
                conditionFillColor: "#e1bee7",
                destructedNodeFillColor: "#ffecb3",
                classFillColor: "#b2dfdb",
                debuggerFillColor: "#ffcdd2",
                exportFillColor: "#b3e5fc",
                throwFillColor: "#ffccbc",
                tryFillColor: "#FFE082",
                objectFillColor: "#d1c4e9",
                callFillColor: "#dcedc8",
                debugModeFillColor: "#666"
            });
            var Ue, Ve = [
                "common"
            ];
            function Ke(e1) {
                return Ke = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e1) {
                    return typeof e1;
                } : function(e1) {
                    return e1 && "function" == typeof Symbol && e1.constructor === Symbol && e1 !== Symbol.prototype ? "symbol" : typeof e1;
                }, Ke(e1);
            }
            function We(e1, t) {
                var n = Object.keys(e1);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e1);
                    t && (r = r.filter(function(t) {
                        return Object.getOwnPropertyDescriptor(e1, t).enumerable;
                    })), n.push.apply(n, r);
                }
                return n;
            }
            function Xe(e1) {
                for(var t = 1; t < arguments.length; t++){
                    var n = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? We(Object(n), !0).forEach(function(t) {
                        Ye(e1, t, n[t]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e1, Object.getOwnPropertyDescriptors(n)) : We(Object(n)).forEach(function(t) {
                        Object.defineProperty(e1, t, Object.getOwnPropertyDescriptor(n, t));
                    });
                }
                return e1;
            }
            function Ye(e1, t, n) {
                return (t = function(e1) {
                    var t = function(e1, t) {
                        if ("object" !== Ke(e1) || null === e1) return e1;
                        var n = e1[Symbol.toPrimitive];
                        if (void 0 !== n) {
                            var r = n.call(e1, "string");
                            if ("object" !== Ke(r)) return r;
                            throw new TypeError("@@toPrimitive must return a primitive value.");
                        }
                        return String(e1);
                    }(e1);
                    return "symbol" === Ke(t) ? t : String(t);
                }(t)) in e1 ? Object.defineProperty(e1, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e1[t] = n, e1;
            }
            var qe = "DEFAULT", He = "BLACK_AND_WHITE", Je = "BLURRED", $e = "LIGHT", Ge = (Ye(Ue = {}, qe, Ne), Ye(Ue, He, Be), Ye(Ue, Je, je), Ye(Ue, $e, Re), Ue), ze = function(e1) {
                return !Ge[e1] === e1 === qe ? Ge.DEFAULT : et(Ne, Ge[e1]);
            }, Qe = function() {
                return ze(qe);
            }, Ze = function() {
                return ze(Je);
            }, et = function(e1, t) {
                var n = t.common, r = function(e1, t) {
                    if (null == e1) return {};
                    var n, r, i = function(e1, t) {
                        if (null == e1) return {};
                        var n, r, i = {}, s = Object.keys(e1);
                        for(r = 0; r < s.length; r++)n = s[r], t.indexOf(n) >= 0 || (i[n] = e1[n]);
                        return i;
                    }(e1, t);
                    if (Object.getOwnPropertySymbols) {
                        var s = Object.getOwnPropertySymbols(e1);
                        for(r = 0; r < s.length; r++)n = s[r], t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e1, n) && (i[n] = e1[n]);
                    }
                    return i;
                }(t, Ve), i = F(e1, r);
                return n ? Object.keys(i).reduce(function(e1, t) {
                    return Xe(Xe({}, e1), {}, Ye({}, t, Xe(Xe({}, i[t]), n)));
                }, {}) : i;
            }, tt = function(e1, t, n, r, i, s) {
                var a = k(), o = t;
                ce(e1, function(e1) {
                    a.stepIn(o), n(e1, a.getCurrent());
                }, function(e1) {
                    o = r(e1, a.getCurrent());
                }, function(e1) {
                    a.getCurrent() && i(e1, a.getCurrent()), a.stepOut();
                }, s);
            }, nt = function(e1) {
                if (!e1 || !e1.length) throw new Error("List is not specified.");
                var t = e1[0], n = t.min.x, r = t.max.x, i = t.min.y, s = t.max.y;
                return e1.forEach(function(e1) {
                    var t = e1.min, a = e1.max;
                    t.x < n && (n = t.x), t.y < i && (i = t.y), a.x > r && (r = a.x), a.y > s && (s = a.y);
                }), {
                    min: {
                        x: n,
                        y: i
                    },
                    max: {
                        x: r,
                        y: s
                    }
                };
            }, rt = function(e1, t) {
                return [].concat(e1).map(function(e1) {
                    return {
                        x: e1.x + t.x,
                        y: e1.y + t.y
                    };
                });
            }, it = [
                {
                    from: "fillColor",
                    to: "fill"
                },
                {
                    from: "strokeColor",
                    to: "stroke"
                },
                {
                    from: "strokeWidth",
                    to: "stroke-width"
                },
                {
                    from: "fillOpacity",
                    to: "fill-opacity"
                },
                {
                    from: "strokeOpacity",
                    to: "stroke-opacity"
                }
            ], st = function(e1) {
                return it.map(function(t) {
                    return e1[t.from] ? "".concat(t.to, ":").concat(e1[t.from]) : null;
                }).filter(function(e1) {
                    return e1;
                }).join("; ");
            }, at = function(e1, t, n, r, i) {
                return '<polygon points="'.concat(e1, ",").concat(t + r / 2, " ").concat(e1 + n / 2, ",").concat(t, " ").concat(e1 + n, ",").concat(t + r / 2, " ").concat(e1 + n / 2, ",").concat(t + r, '"\n            style="').concat(st(i), '" />');
            }, ot = function(e1, t, n, r, i) {
                return '<rect x="'.concat(e1, '" y="').concat(t, '"\n            width="').concat(n, '" height="').concat(r, '"\n            rx="').concat(i.roundBorder, '" ry="').concat(i.roundBorder, '"\n            style="').concat(st(i), '" />');
            }, lt = function(e1, t, n, r, i) {
                return '<rect x="'.concat(e1, '" y="').concat(t, '"\n            width="').concat(n, '" height="').concat(r, '"\n            style="').concat(st(i), '" />');
            }, ct = function(e1, t, n, r, i) {
                return '<line x1="'.concat(e1, '" y1="').concat(t, '" x2="').concat(n, '" y2="').concat(r, '"\n                style="').concat(st(i), '" />');
            }, ut = function(e1, t, n, r) {
                return '<circle cx="'.concat(e1, '" cy="').concat(t, '" r="').concat(n, '"\n        style="').concat(st(r), '" />');
            }, pt = function(e1, t, n, r) {
                return '<text x="'.concat(e1, '" y="').concat(t, '"\n        font-family="').concat(n.fontFamily, '" font-size="').concat(n.fontSize, '" fill="').concat(n.textColor, '">').concat(r, "</text>");
            }, ht = function(e1, t) {
                var n = e1.map(function(e1, t) {
                    return t ? "L".concat(e1.x, ", ").concat(e1.y) : "M".concat(e1.x, ", ").concat(e1.y);
                }).join(" ");
                return '<path d="'.concat(n, ' Z" \n        ').concat(function(e1) {
                    return it.map(function(t) {
                        return e1[t.from] ? "".concat(t.to, '="').concat(e1[t.from], '"') : null;
                    }).filter(function(e1) {
                        return e1;
                    }).join(" ");
                }(t), " />");
            }, dt = function(e1, t, n) {
                return e1.x === t.x ? "L".concat(e1.x, " ").concat(ft(e1.y, t.y, n)) : e1.y === t.y ? "L".concat(ft(e1.x, t.x, n), " ").concat(e1.y, " ") : void 0;
            }, ft = function(e1, t, n) {
                return e1 > t ? e1 - n : e1 + n;
            }, yt = function(e1, t, n) {
                return e1 > t ? t + n : t - n;
            }, mt = n(737), Tt = n.n(mt);
            const gt = function({ onlyFirst: e1 = !1 } = {}) {
                const t = [
                    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
                    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
                ].join("|");
                return new RegExp(t, e1 ? void 0 : "g");
            }();
            var bt = n(4021);
            var Et = function(e1) {
                for(var t = [
                    e1
                ], n = "node-id:|".concat(e1.name, "|"); t.length;){
                    var r = t.shift();
                    r && (n += r.name ? r.name[0] : "-", r.parent && t.push(r.parent));
                }
                return n.replace(/\s/g, "").toUpperCase();
            }, St = function e1(t) {
                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : function(e1) {
                    return e1.body;
                }, r = [];
                return [].concat(t).forEach(function(t) {
                    var i = n(t);
                    i && i.length ? r = r.concat(t, e1(i, n)) : r.push(t);
                }), r;
            };
            function Pt(e1) {
                return Pt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e1) {
                    return typeof e1;
                } : function(e1) {
                    return e1 && "function" == typeof Symbol && e1.constructor === Symbol && e1 !== Symbol.prototype ? "symbol" : typeof e1;
                }, Pt(e1);
            }
            function xt(e1, t) {
                var n = Object.keys(e1);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e1);
                    t && (r = r.filter(function(t) {
                        return Object.getOwnPropertyDescriptor(e1, t).enumerable;
                    })), n.push.apply(n, r);
                }
                return n;
            }
            function Dt(e1) {
                for(var t = 1; t < arguments.length; t++){
                    var n = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? xt(Object(n), !0).forEach(function(t) {
                        var r, i, s;
                        r = e1, i = t, s = n[t], (i = function(e1) {
                            var t = function(e1, t) {
                                if ("object" !== Pt(e1) || null === e1) return e1;
                                var n = e1[Symbol.toPrimitive];
                                if (void 0 !== n) {
                                    var r = n.call(e1, "string");
                                    if ("object" !== Pt(r)) return r;
                                    throw new TypeError("@@toPrimitive must return a primitive value.");
                                }
                                return String(e1);
                            }(e1);
                            return "symbol" === Pt(t) ? t : String(t);
                        }(i)) in r ? Object.defineProperty(r, i, {
                            value: s,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : r[i] = s;
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e1, Object.getOwnPropertyDescriptors(n)) : xt(Object(n)).forEach(function(t) {
                        Object.defineProperty(e1, t, Object.getOwnPropertyDescriptor(n, t));
                    });
                }
                return e1;
            }
            var At = function(e1, t) {
                function n(n, r, i) {
                    return e1(vt(n, r, i, t));
                }
                return n.getThemeFieldName = function() {
                    return t;
                }, n;
            }, vt = function(e1, t, n, r) {
                var i, s, a = t.x, o = t.y, l = (i = e1.name, s = n.maxNameLength || 50, i.length <= s ? [
                    i
                ] : [
                    i.slice(0, s) + "..."
                ]), c = l.length, u = l.reduce(function(e1, t) {
                    var n = function(e1, t) {
                        if ("string" != typeof e1 || 0 === e1.length) return 0;
                        if ((t = {
                            ambiguousIsNarrow: !0,
                            countAnsiEscapeCodes: !1,
                            ...t
                        }).countAnsiEscapeCodes || (e1 = function(e1) {
                            if ("string" != typeof e1) throw new TypeError(`Expected a \`string\`, got \`${typeof e1}\``);
                            return e1.replace(gt, "");
                        }(e1)), 0 === e1.length) return 0;
                        const n = t.ambiguousIsNarrow ? 1 : 2;
                        let r = 0;
                        for (const { segment: t } of (new Intl.Segmenter).segment(e1)){
                            const e1 = t.codePointAt(0);
                            if (!(e1 <= 31 || e1 >= 127 && e1 <= 159 || e1 >= 768 && e1 <= 879)) if (/[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC3\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC08\uDC26](?:\u200D\u2B1B)?|[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g.test(t)) r += 2;
                            else switch(bt.eastAsianWidth(t)){
                                case "F":
                                case "W":
                                    r += 2;
                                    break;
                                case "A":
                                    r += n;
                                    break;
                                default:
                                    r += 1;
                            }
                        }
                        return r;
                    }(t);
                    return n >= e1 ? n : e1;
                }, 0);
                return {
                    id: "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(e1) {
                        var t = 16 * Math.random() | 0;
                        return ("x" === e1 ? t : 3 & t | 8).toString(16);
                    }),
                    nodePathId: Et(e1),
                    type: r,
                    body: [],
                    theme: n,
                    originalTheme: n,
                    node: e1,
                    name: e1.name,
                    prefixName: e1.prefixName,
                    nameParts: l,
                    totalNamePartsNumber: c,
                    maxNamePartLength: u,
                    initialPosition: {
                        x: a,
                        y: o
                    }
                };
            }, Ct = function(e1) {
                return {
                    fromPoint: Mt(e1),
                    toPoint: Bt(e1),
                    backPoint: jt(e1),
                    childOffsetPoint: Rt(e1),
                    boundaries: Ut(e1)
                };
            }, wt = function(e1) {
                return Dt(Dt({}, e1), {}, {
                    position: _t(e1),
                    dimensions: Lt(e1)
                });
            }, Ot = function(e1) {
                return {
                    getBody: function() {
                        return e1.body;
                    },
                    getBoundaries: function() {
                        return e1.boundaries;
                    },
                    getBackPoint: function() {
                        return e1.backPoint;
                    },
                    getAssignedConnectionArrow: function() {
                        return e1.connectionArrow;
                    },
                    getChildOffsetPoint: function() {
                        return e1.childOffsetPoint;
                    },
                    getDimensions: function() {
                        return e1.dimensions;
                    },
                    getId: function() {
                        return e1.id;
                    },
                    getFromPoint: function() {
                        return e1.fromPoint;
                    },
                    getMargin: function() {
                        return e1.theme.margin;
                    },
                    getName: function() {
                        return e1.name;
                    },
                    getNode: function() {
                        return e1.node;
                    },
                    getNodeType: function() {
                        return e1.node.type;
                    },
                    getNodePathId: function() {
                        return e1.nodePathId;
                    },
                    getNodeKey: function() {
                        return e1.node.key;
                    },
                    getParent: function() {
                        return e1.parent;
                    },
                    getPosition: function() {
                        return e1.position;
                    },
                    getToPoint: function() {
                        return e1.toPoint;
                    },
                    getShapeType: function() {
                        return e1.type;
                    }
                };
            }, It = function(e1) {
                return Object.assign({}, function(e1) {
                    return {
                        printName: function(t) {
                            var n = e1.position, r = e1.theme, i = e1.nameParts, s = t || n, a = s.x, o = s.y, l = i.map(function(e1, t) {
                                return '<tspan x="'.concat(a + r.horizontalPadding, '" y="').concat(o + 2 * r.verticalPadding * (t + 1), '">').concat(Tt()(e1), "</tspan>");
                            }).join("");
                            return "".concat(i[0].length <= e1.name.length + 3 ? "<title>".concat(Tt()(e1.name), "</title>") : "", '\n            <text x="').concat(a + r.horizontalPadding, '" y="').concat(o + 2 * r.verticalPadding, '"\n                font-family="').concat(r.fontFamily, '" font-size="').concat(r.fontSize, '" fill="').concat(r.textColor, '">\n                ').concat(l, "\n            </text>");
                        },
                        printDebugInfo: function() {
                            if (!(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).debug) return "";
                            var t = e1.position, n = e1.dimensions, r = e1.theme, i = e1.nodePathId;
                            return '<text x="'.concat(t.x + 3 * r.horizontalPadding, '" y="').concat(t.y + n.h + r.verticalPadding, '"\n                font-family="').concat(r.fontFamily, '" font-size="').concat(r.debugFontSize, '" fill="').concat(r.debugTextColor, '">\n                ').concat(i, "\n            </text>");
                        }
                    };
                }(e1), function(e1) {
                    return {
                        getChildBoundaries: function(t) {
                            var n = e1.body, r = e1.boundaries;
                            if (!n.length) return r;
                            var i = St({
                                getBody: function() {
                                    return t ? n.filter(t) : n;
                                },
                                getBoundaries: function() {
                                    return r;
                                }
                            }, function(e1) {
                                return e1.getBody();
                            });
                            return nt(i.map(function(e1) {
                                return e1.getBoundaries();
                            }));
                        }
                    };
                }(e1), function(e1) {
                    return {
                        addChild: function(t) {
                            e1.body.push(t);
                        },
                        setParent: function(t) {
                            e1.parent = t;
                        },
                        connectChild: function(e1) {
                            this.addChild(e1), e1.setParent(this);
                        },
                        updateTheme: function(t) {
                            e1.theme = F(e1.theme, t);
                        },
                        assignConnectionArrow: function(t) {
                            e1.connectionArrow = t;
                        }
                    };
                }(e1));
            }, Nt = function(e1) {
                return e1.maxNamePartLength * e1.theme.symbolWidth;
            }, Ft = function(e1) {
                return 2 * e1.theme.horizontalPadding + Nt(e1);
            }, kt = function(e1) {
                return 2 * e1.theme.verticalPadding + (n = (t = e1).totalNamePartsNumber, r = t.theme, n * r.symbolHeight + (n - 1) * r.lineHeight);
                "TURBOPACK unreachable";
                var t, n, r;
            }, Lt = function(e1) {
                return {
                    w: Ft(e1),
                    h: kt(e1)
                };
            }, _t = function(e1) {
                return Dt({}, e1.initialPosition);
            }, Mt = function(e1) {
                var t = e1.position, n = e1.dimensions, r = e1.theme;
                return {
                    x: t.x + r.childOffset / 2,
                    y: t.y + n.h
                };
            }, Bt = function(e1) {
                var t = e1.position, n = e1.dimensions;
                return {
                    x: t.x,
                    y: t.y + n.h / 2
                };
            }, jt = function(e1) {
                var t = e1.position, n = e1.dimensions;
                return {
                    x: t.x + n.w,
                    y: t.y + n.h / 2
                };
            }, Rt = function(e1) {
                var t = e1.theme, n = e1.dimensions;
                return {
                    x: t.childOffset,
                    y: n.h + t.childOffset / 2
                };
            }, Ut = function(e1) {
                var t = e1.position, n = e1.dimensions;
                return {
                    min: {
                        x: t.x,
                        y: t.y
                    },
                    max: {
                        x: t.x + n.w,
                        y: t.y + n.h
                    }
                };
            };
            function Vt(e1) {
                return Vt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e1) {
                    return typeof e1;
                } : function(e1) {
                    return e1 && "function" == typeof Symbol && e1.constructor === Symbol && e1 !== Symbol.prototype ? "symbol" : typeof e1;
                }, Vt(e1);
            }
            function Kt(e1, t) {
                var n = Object.keys(e1);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e1);
                    t && (r = r.filter(function(t) {
                        return Object.getOwnPropertyDescriptor(e1, t).enumerable;
                    })), n.push.apply(n, r);
                }
                return n;
            }
            function Wt(e1) {
                for(var t = 1; t < arguments.length; t++){
                    var n = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? Kt(Object(n), !0).forEach(function(t) {
                        var r, i, s;
                        r = e1, i = t, s = n[t], (i = function(e1) {
                            var t = function(e1, t) {
                                if ("object" !== Vt(e1) || null === e1) return e1;
                                var n = e1[Symbol.toPrimitive];
                                if (void 0 !== n) {
                                    var r = n.call(e1, "string");
                                    if ("object" !== Vt(r)) return r;
                                    throw new TypeError("@@toPrimitive must return a primitive value.");
                                }
                                return String(e1);
                            }(e1);
                            return "symbol" === Vt(t) ? t : String(t);
                        }(i)) in r ? Object.defineProperty(r, i, {
                            value: s,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : r[i] = s;
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e1, Object.getOwnPropertyDescriptors(n)) : Kt(Object(n)).forEach(function(t) {
                        Object.defineProperty(e1, t, Object.getOwnPropertyDescriptor(n, t));
                    });
                }
                return e1;
            }
            var Xt = function(e1) {
                return {
                    print: function(t) {
                        var n = e1.theme, r = e1.position, i = r.x, s = r.y, a = e1.dimensions, o = a.w, l = a.h, c = {
                            x: i + n.edgeOffset,
                            y: s
                        };
                        return "\n            <g>\n                ".concat(lt(i, s, o, l, n), "\n                    \n                ").concat(ct(i + n.edgeOffset, s, i + n.edgeOffset, s + l, n), "\n                ").concat(ct(i + o - n.edgeOffset, s, i + o - n.edgeOffset, s + l, n), "\n             \n                ").concat(this.printName(c), "\n                ").concat(this.printDebugInfo(t), "\n            </g>");
                    }
                };
            }, Yt = function(e1) {
                return 2 * (e1.theme.horizontalPadding + e1.theme.edgeOffset) + Nt(e1);
            }, qt = function(e1) {
                return {
                    w: Yt(e1),
                    h: kt(e1)
                };
            }, Ht = function(e1) {
                var t = function(e1) {
                    return Wt(Wt({}, e1), {}, {
                        position: _t(e1),
                        dimensions: qt(e1)
                    });
                }(e1);
                return t = Wt(Wt({}, t), Ct(t)), N(t, [
                    Ot,
                    It,
                    Xt
                ]);
            };
            const Jt = At(Ht, "VerticalEdgedRectangle");
            var $t = function(e1) {
                return {
                    print: function() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n = e1.theme, r = n.dot, i = e1.position, s = i.x, a = i.y, o = e1.dimensions, l = o.w, c = o.h, u = e1.node;
                        return "\n                <g>\n                   ".concat(ot(s, a, l, c, n), "\n                   ").concat(this.printName(), "\n                   ").concat(u.chain ? ut(s + r.offset, a + c - r.offset, r.radius, r) : "", "\n                   ").concat(this.printDebugInfo(t), "\n                </g>");
                    }
                };
            }, Gt = function(e1) {
                var t = function(e1) {
                    var t = wt(e1);
                    return Dt(Dt({}, t), Ct(t));
                }(e1);
                return N(t, [
                    Ot,
                    It,
                    $t
                ]);
            };
            const zt = At(Gt, "Rectangle");
            var Qt = function(e1) {
                return {
                    w: Zt(e1),
                    h: en(e1)
                };
            }, Zt = function(e1) {
                return en(e1) + Ft(e1);
            }, en = function(e1) {
                return 2 * e1.theme.thinPartOffset + kt(e1);
            }, tn = function(e1) {
                var t = e1.position, n = e1.dimensions;
                return {
                    x: t.x + n.h / 2,
                    y: t.y + n.h
                };
            }, nn = function(e1) {
                var t = e1.dimensions, n = e1.theme;
                return {
                    x: t.h / 2 + n.childOffset,
                    y: t.h + n.childOffset / 2
                };
            };
            function rn(e1) {
                return rn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e1) {
                    return typeof e1;
                } : function(e1) {
                    return e1 && "function" == typeof Symbol && e1.constructor === Symbol && e1 !== Symbol.prototype ? "symbol" : typeof e1;
                }, rn(e1);
            }
            function sn(e1, t) {
                var n = Object.keys(e1);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e1);
                    t && (r = r.filter(function(t) {
                        return Object.getOwnPropertyDescriptor(e1, t).enumerable;
                    })), n.push.apply(n, r);
                }
                return n;
            }
            function an(e1) {
                for(var t = 1; t < arguments.length; t++){
                    var n = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? sn(Object(n), !0).forEach(function(t) {
                        var r, i, s;
                        r = e1, i = t, s = n[t], (i = function(e1) {
                            var t = function(e1, t) {
                                if ("object" !== rn(e1) || null === e1) return e1;
                                var n = e1[Symbol.toPrimitive];
                                if (void 0 !== n) {
                                    var r = n.call(e1, "string");
                                    if ("object" !== rn(r)) return r;
                                    throw new TypeError("@@toPrimitive must return a primitive value.");
                                }
                                return String(e1);
                            }(e1);
                            return "symbol" === rn(t) ? t : String(t);
                        }(i)) in r ? Object.defineProperty(r, i, {
                            value: s,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : r[i] = s;
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e1, Object.getOwnPropertyDescriptors(n)) : sn(Object(n)).forEach(function(t) {
                        Object.defineProperty(e1, t, Object.getOwnPropertyDescriptor(n, t));
                    });
                }
                return e1;
            }
            var on = function(e1) {
                var t = e1.position, n = e1.dimensions;
                return {
                    x: t.x + n.w,
                    y: t.y + n.h / 2
                };
            }, ln = function(e1) {
                return {
                    getAlternateFromPoint: function() {
                        return e1.alternateFromPoint;
                    }
                };
            }, cn = function(e1) {
                return {
                    getConsequentBranchChildBoundary: function() {
                        return this.getChildBoundaries(function(e1) {
                            return e1.state.node.key === s.CONSEQUENT;
                        });
                    },
                    getAlternativeBranchChildOffsetPoint: function() {
                        var t = e1.theme, n = {};
                        n.y = e1.position.y + e1.childOffsetPoint.y, n.x = this.getConsequentBranchChildBoundary().max.x, n.x += t.alternateBranchOffset;
                        var r = e1.position.x + e1.dimensions.w + t.childOffset;
                        return n.x <= r && (n.x = r), n;
                    },
                    checkIfChildExist: function(t) {
                        return e1.body.filter(function(e1) {
                            return e1.getNodeKey() === t;
                        }).length;
                    },
                    printConditionMarks: function() {
                        var t = e1.theme, n = e1.position, r = n.x, a = n.y, o = e1.dimensions.h, l = e1.dimensions.w, c = e1.node.subType === i.CONDITIONAL_EXPRESSION ? "?" : "if";
                        return "".concat(pt(r + o / 2 - c.length * t.symbolWidth / 2, a + o / 2 + t.symbolHeight / 2, t, c), " ").concat(pt(r + o / 2 + t.symbolWidth, a + o + t.symbolWidth / 4, t, "+"), " ").concat(this.checkIfChildExist(s.ALTERNATE) ? pt(r + l + t.symbolWidth / 2, a + o / 2 - t.symbolWidth / 4, t, "-") : "");
                    },
                    print: function(t) {
                        var n = e1.theme, r = e1.position, i = r.x, s = r.y, a = e1.dimensions, o = a.w, l = a.h, c = l, u = l - 2 * n.thinPartOffset, p = {
                            x: i + c,
                            y: s + u / 2
                        };
                        return "<g>\n            ".concat(ot(i + l / 2, s + l / 4, o - c / 2, u, n), "                \n            ").concat(at(i, s, c, c, n), "\n            ").concat(this.printName(p), "\n            ").concat(this.printDebugInfo(t), "\n            ").concat(this.printConditionMarks(), "\n        </g>");
                    }
                };
            }, un = function(e1) {
                var t = function(e1) {
                    return an(an({}, e1), {}, {
                        position: _t(e1),
                        dimensions: Qt(e1)
                    });
                }(e1);
                return t = an(an({}, t), function(e1) {
                    return {
                        fromPoint: tn(e1),
                        childOffsetPoint: nn(e1),
                        toPoint: (t = e1, n = t.position, r = t.dimensions, {
                            x: n.x,
                            y: n.y + r.h / 2
                        }),
                        backPoint: jt(e1),
                        boundaries: Ut(e1),
                        alternateFromPoint: on(e1)
                    };
                    "TURBOPACK unreachable";
                    var t, n, r;
                }(t)), N(t, [
                    Ot,
                    ln,
                    It,
                    cn
                ]);
            };
            const pn = At(un, "ConditionRhombus");
            var hn;
            function dn(e1) {
                return dn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e1) {
                    return typeof e1;
                } : function(e1) {
                    return e1 && "function" == typeof Symbol && e1.constructor === Symbol && e1 !== Symbol.prototype ? "symbol" : typeof e1;
                }, dn(e1);
            }
            function fn(e1, t) {
                var n = Object.keys(e1);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e1);
                    t && (r = r.filter(function(t) {
                        return Object.getOwnPropertyDescriptor(e1, t).enumerable;
                    })), n.push.apply(n, r);
                }
                return n;
            }
            function yn(e1) {
                for(var t = 1; t < arguments.length; t++){
                    var n = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? fn(Object(n), !0).forEach(function(t) {
                        mn(e1, t, n[t]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e1, Object.getOwnPropertyDescriptors(n)) : fn(Object(n)).forEach(function(t) {
                        Object.defineProperty(e1, t, Object.getOwnPropertyDescriptor(n, t));
                    });
                }
                return e1;
            }
            function mn(e1, t, n) {
                return (t = function(e1) {
                    var t = function(e1, t) {
                        if ("object" !== dn(e1) || null === e1) return e1;
                        var n = e1[Symbol.toPrimitive];
                        if (void 0 !== n) {
                            var r = n.call(e1, "string");
                            if ("object" !== dn(r)) return r;
                            throw new TypeError("@@toPrimitive must return a primitive value.");
                        }
                        return String(e1);
                    }(e1);
                    return "symbol" === dn(t) ? t : String(t);
                }(t)) in e1 ? Object.defineProperty(e1, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e1[t] = n, e1;
            }
            var Tn = (mn(hn = {}, i.FOR_OF_STATEMENT, "for"), mn(hn, i.FOR_IN_STATEMENT, "for"), mn(hn, i.FOR_STATEMENT, "for"), mn(hn, i.WHILE_STATEMENT, "while"), mn(hn, i.DO_WHILE_STATEMENT, "while"), hn), gn = function(e1) {
                return {
                    getMidPoint: function() {
                        return e1.midPoint;
                    },
                    getLoopedConnectionArrow: function() {
                        return e1.loopedConnectionArrow;
                    }
                };
            }, bn = function(e1) {
                return {
                    assignLoopedConnectionArrow: function(t) {
                        e1.loopedConnectionArrow = t;
                    },
                    printConditionMarks: function() {
                        var t = e1.theme, n = e1.position, r = n.x, i = n.y, s = e1.dimensions.h, a = e1.prefixName || Tn[e1.node.subType] || "for";
                        return pt(r + s / 2 - a.length * t.symbolWidth / 2, i + s / 2 + t.symbolHeight / 2, t, a);
                    },
                    print: function(t) {
                        var n = e1.theme, r = e1.position, i = r.x, s = r.y, a = e1.dimensions, o = a.w, l = a.h, c = l, u = l - 2 * n.thinPartOffset, p = {
                            x: i + c,
                            y: s + u / 2
                        };
                        return "<g>\n\n            ".concat(ot(i + l / 2, s + l / 4, o - c / 2, u, n), "\n            ").concat(at(i, s, c, c, n), "\n                \n            ").concat(this.printName(p), "\n            ").concat(this.printDebugInfo(t), "\n            ").concat(this.printConditionMarks(), "\n        </g>");
                    }
                };
            };
            const En = At(function(e1) {
                var t = function(e1) {
                    return yn(yn({}, e1), {}, {
                        position: (t = e1, n = t.initialPosition, r = t.theme, {
                            x: n.x,
                            y: n.y + r.positionTopShift
                        }),
                        dimensions: Qt(e1)
                    });
                    "TURBOPACK unreachable";
                    var t, n, r;
                }(e1);
                return t = yn(yn({}, t), function(e1) {
                    return {
                        fromPoint: tn(e1),
                        childOffsetPoint: nn(e1),
                        toPoint: Bt(e1),
                        backPoint: jt(e1),
                        boundaries: Ut(e1),
                        midPoint: (t = e1, n = t.position, r = t.dimensions, {
                            x: n.x + r.h / 2,
                            y: n.y
                        })
                    };
                    "TURBOPACK unreachable";
                    var t, n, r;
                }(t)), N(t, [
                    Ot,
                    gn,
                    It,
                    bn
                ]);
            }, "LoopRhombus");
            function Sn(e1) {
                return Sn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e1) {
                    return typeof e1;
                } : function(e1) {
                    return e1 && "function" == typeof Symbol && e1.constructor === Symbol && e1 !== Symbol.prototype ? "symbol" : typeof e1;
                }, Sn(e1);
            }
            function Pn(e1, t) {
                var n = Object.keys(e1);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e1);
                    t && (r = r.filter(function(t) {
                        return Object.getOwnPropertyDescriptor(e1, t).enumerable;
                    })), n.push.apply(n, r);
                }
                return n;
            }
            function xn(e1) {
                for(var t = 1; t < arguments.length; t++){
                    var n = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? Pn(Object(n), !0).forEach(function(t) {
                        var r, i, s;
                        r = e1, i = t, s = n[t], (i = function(e1) {
                            var t = function(e1, t) {
                                if ("object" !== Sn(e1) || null === e1) return e1;
                                var n = e1[Symbol.toPrimitive];
                                if (void 0 !== n) {
                                    var r = n.call(e1, "string");
                                    if ("object" !== Sn(r)) return r;
                                    throw new TypeError("@@toPrimitive must return a primitive value.");
                                }
                                return String(e1);
                            }(e1);
                            return "symbol" === Sn(t) ? t : String(t);
                        }(i)) in r ? Object.defineProperty(r, i, {
                            value: s,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : r[i] = s;
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e1, Object.getOwnPropertyDescriptors(n)) : Pn(Object(n)).forEach(function(t) {
                        Object.defineProperty(e1, t, Object.getOwnPropertyDescriptor(n, t));
                    });
                }
                return e1;
            }
            var Dn = function(e1) {
                return {
                    print: function() {
                        var t = e1.theme, n = e1.position, r = n.x, i = n.y, s = e1.dimensions, a = s.w, o = s.h, l = t.radius, c = {
                            x: r + l,
                            y: i - l
                        };
                        return "\n            <g>\n               ".concat(lt(r, i - l + l / 4, a + l, o - 2 * t.padding, t), "\n               ").concat(ut(r, i, l, t), "\n               ").concat(this.printName(c), "\n            </g>");
                    },
                    setChildOffsetPoint: function(t) {
                        e1.childOffsetPoint = t;
                    }
                };
            };
            const An = At(function(e1) {
                var t = wt(e1);
                return t = xn(xn({}, t), function(e1) {
                    return {
                        fromPoint: (t = e1, n = t.position, r = t.theme.radius, {
                            x: n.x,
                            y: n.y + r
                        }),
                        boundaries: Ut(e1)
                    };
                    "TURBOPACK unreachable";
                    var t, n, r;
                }(t)), N(t, [
                    Ot,
                    It,
                    Dn
                ]);
            }, "RootCircle");
            function vn(e1) {
                return vn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e1) {
                    return typeof e1;
                } : function(e1) {
                    return e1 && "function" == typeof Symbol && e1.constructor === Symbol && e1 !== Symbol.prototype ? "symbol" : typeof e1;
                }, vn(e1);
            }
            function Cn(e1, t) {
                var n = Object.keys(e1);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e1);
                    t && (r = r.filter(function(t) {
                        return Object.getOwnPropertyDescriptor(e1, t).enumerable;
                    })), n.push.apply(n, r);
                }
                return n;
            }
            function wn(e1) {
                for(var t = 1; t < arguments.length; t++){
                    var n = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? Cn(Object(n), !0).forEach(function(t) {
                        var r, i, s;
                        r = e1, i = t, s = n[t], (i = function(e1) {
                            var t = function(e1, t) {
                                if ("object" !== vn(e1) || null === e1) return e1;
                                var n = e1[Symbol.toPrimitive];
                                if (void 0 !== n) {
                                    var r = n.call(e1, "string");
                                    if ("object" !== vn(r)) return r;
                                    throw new TypeError("@@toPrimitive must return a primitive value.");
                                }
                                return String(e1);
                            }(e1);
                            return "symbol" === vn(t) ? t : String(t);
                        }(i)) in r ? Object.defineProperty(r, i, {
                            value: s,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : r[i] = s;
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e1, Object.getOwnPropertyDescriptors(n)) : Cn(Object(n)).forEach(function(t) {
                        Object.defineProperty(e1, t, Object.getOwnPropertyDescriptor(n, t));
                    });
                }
                return e1;
            }
            var On = function(e1) {
                return {
                    print: function(t) {
                        var n = e1.theme, r = n.arrow, i = e1.position, s = i.x, a = i.y, o = e1.dimensions.h, l = e1.dimensions.w - r.handlerLength - r.sizeX, c = {
                            x: s,
                            y: a
                        }, u = {
                            x: r.sizeX,
                            y: r.sizeY
                        }, p = ht(rt([
                            {
                                x: 0,
                                y: 0
                            },
                            {
                                x: u.x,
                                y: u.y / 2
                            },
                            {
                                x: 0,
                                y: u.y
                            }
                        ], {
                            x: s + l + r.handlerLength,
                            y: a + o / 2 - u.y / 2
                        }), r);
                        return "\n            <g>\n                ".concat(ot(s, a, l, o, n), "\n                \n                ").concat(ct(s + l, a + o / 2 - r.handlerLength, s + l + r.handlerLength, a + o / 2 - r.handlerLength, r), "\n                \n                ").concat(ct(s + l, a + o / 2 + r.handlerLength, s + l + r.handlerLength, a + o / 2 + r.handlerLength, r), "\n\n                ").concat(p, "\n                             \n                ").concat(this.printName(c), "\n                ").concat(this.printDebugInfo(t), "\n            </g>");
                    }
                };
            }, In = function(e1) {
                var t = e1.theme, n = t.arrow;
                return 2 * t.horizontalPadding + n.handlerLength + n.sizeX + Nt(e1);
            }, Nn = function(e1) {
                return {
                    w: In(e1),
                    h: kt(e1)
                };
            }, Fn = function(e1) {
                var t = function(e1) {
                    return wn(wn({}, e1), {}, {
                        position: _t(e1),
                        dimensions: Nn(e1)
                    });
                }(e1);
                return t = wn(wn({}, t), Ct(t)), N(t, [
                    Ot,
                    It,
                    On
                ]);
            };
            const kn = At(Fn, "ReturnStatement");
            function Ln(e1) {
                return Ln = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e1) {
                    return typeof e1;
                } : function(e1) {
                    return e1 && "function" == typeof Symbol && e1.constructor === Symbol && e1 !== Symbol.prototype ? "symbol" : typeof e1;
                }, Ln(e1);
            }
            function _n(e1, t) {
                var n = Object.keys(e1);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e1);
                    t && (r = r.filter(function(t) {
                        return Object.getOwnPropertyDescriptor(e1, t).enumerable;
                    })), n.push.apply(n, r);
                }
                return n;
            }
            function Mn(e1) {
                for(var t = 1; t < arguments.length; t++){
                    var n = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? _n(Object(n), !0).forEach(function(t) {
                        var r, i, s;
                        r = e1, i = t, s = n[t], (i = function(e1) {
                            var t = function(e1, t) {
                                if ("object" !== Ln(e1) || null === e1) return e1;
                                var n = e1[Symbol.toPrimitive];
                                if (void 0 !== n) {
                                    var r = n.call(e1, "string");
                                    if ("object" !== Ln(r)) return r;
                                    throw new TypeError("@@toPrimitive must return a primitive value.");
                                }
                                return String(e1);
                            }(e1);
                            return "symbol" === Ln(t) ? t : String(t);
                        }(i)) in r ? Object.defineProperty(r, i, {
                            value: s,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : r[i] = s;
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e1, Object.getOwnPropertyDescriptors(n)) : _n(Object(n)).forEach(function(t) {
                        Object.defineProperty(e1, t, Object.getOwnPropertyDescriptor(n, t));
                    });
                }
                return e1;
            }
            var Bn = function(e1) {
                return {
                    print: function(t) {
                        var n = e1.theme, r = n.suffix, i = e1.position, s = i.x, a = i.y, o = e1.dimensions.h, l = e1.dimensions.w - 2 * (r.width + r.space), c = {
                            x: s,
                            y: a
                        }, u = ot(s + l + r.space, a, r.width, o, r), p = ot(s + l + 2 * r.space + r.width, a, r.width, o, r);
                        return "\n            <g>\n                ".concat(ot(s, a, l, o, n), "\n                \n                ").concat(u, "\n                ").concat(p, "\n                             \n                ").concat(this.printName(c), "\n                ").concat(this.printDebugInfo(t), "\n            </g>");
                    }
                };
            }, jn = function(e1) {
                var t = e1.theme, n = t.suffix;
                return 2 * t.horizontalPadding + 2 * (n.width + +n.space) + Nt(e1);
            }, Rn = function(e1) {
                return {
                    w: jn(e1),
                    h: kt(e1)
                };
            };
            const Un = At(function(e1) {
                var t = function(e1) {
                    return Mn(Mn({}, e1), {}, {
                        position: _t(e1),
                        dimensions: Rn(e1)
                    });
                }(e1);
                return t = Mn(Mn({}, t), Ct(t)), N(t, [
                    Ot,
                    It,
                    Bn
                ]);
            }, "DestructedNode"), Vn = At(Ht, "ClassDeclaration"), Kn = At(Gt, "DebuggerStatement"), Wn = At(Fn, "ExportDeclaration"), Xn = At(Ht, "ImportDeclaration"), Yn = At(Gt, "ImportSpecifier"), qn = At(Gt, "ThrowStatement"), Hn = At(Gt, "TryStatement"), Jn = At(Fn, "CatchClause"), $n = At(un, "SwitchStatement"), Gn = At(Fn, "BreakStatement"), zn = At(Gt, "SwitchCase"), Qn = At(Fn, "ContinueStatement"), Zn = At(Gt, "CallExpression"), er = At(Gt, "ObjectProperty");
            var tr = function(e1) {
                switch(e1.type){
                    case i.FUNCTION:
                        return Jt;
                    case i.LOOP:
                        return En;
                    case i.CONDITIONAL:
                        return pn;
                    case i.RETURN:
                        return kn;
                    case c.DESTRUCTED:
                        return Un;
                    case i.CLASS_DECLARATION:
                        return Vn;
                    case i.DEBUGGER_STATEMENT:
                        return Kn;
                    case i.EXPORT_DEFAULT_DECLARATION:
                    case i.EXPORT_NAMED_DECLARATION:
                        return Wn;
                    case i.IMPORT_DECLARATION:
                        return Xn;
                    case i.IMPORT_DEFAULT_SPECIFIER:
                    case i.IMPORT_SPECIFIER:
                        return Yn;
                    case i.THROW_STATEMENT:
                        return qn;
                    case i.PROGRAM:
                        return An;
                    case i.TRY_STATEMENT:
                        return Hn;
                    case i.CATCH_CLAUSE:
                        return Jn;
                    case i.SWITCH_STATEMENT:
                        return $n;
                    case i.BREAK:
                        return Gn;
                    case i.SWITCH_CASE:
                        return zn;
                    case i.CONTINUE:
                        return Qn;
                    case i.OBJECT_PROPERTY:
                        return er;
                    case i.CALL_EXPRESSION:
                        return Zn;
                    default:
                        return zt;
                }
            }, nr = function() {
                return "ConnectionArrow";
            }, rr = function(e1) {
                return {
                    getFieldName: nr
                };
            }, ir = function(e1) {
                return {
                    updateTheme: function(t) {
                        e1.theme = F(e1.theme, t);
                    }
                };
            }, sr = function(e1) {
                return {
                    printLine: function(t) {
                        return function(e1, t) {
                            var n = e1.map(function(n, r) {
                                if (!r) return "M".concat(n.x, ", ").concat(n.y);
                                var i = e1[r - 1];
                                return r <= 1 ? dt(n, i, t.curveTurnRadius) : "Q".concat(i.x, " ").concat(i.y, "\n                ").concat(function(e1, t, n) {
                                    return e1.x === t.x ? "".concat(t.x, " ").concat(yt(e1.y, t.y, n)) : e1.y === t.y ? "".concat(yt(e1.x, t.x, n), " ").concat(t.y) : void 0;
                                }(n, i, t.curveTurnRadius), "\n                ").concat(dt(n, i, 2 * t.curveTurnRadius));
                            }).join(" ");
                            return '<path d="'.concat(n, '"\n        style="fill:none; ').concat(st(t), '" />');
                        }(t, e1.theme.line);
                    },
                    printArrow: function(t, n) {
                        return ht(rt(n, t), e1.theme.arrow);
                    },
                    printArrowByType: function(t, n) {
                        var r, i = n.x, s = n.y, c = e1.theme.arrow.size;
                        switch(t){
                            case a:
                                return r = {
                                    x: i - c.x,
                                    y: s - c.y / 2
                                }, this.printArrow(r, [
                                    {
                                        x: 0,
                                        y: 0
                                    },
                                    {
                                        x: c.x,
                                        y: c.y / 2
                                    },
                                    {
                                        x: 0,
                                        y: c.y
                                    }
                                ]);
                            case o:
                                return r = {
                                    x: i,
                                    y: s - c.y / 2
                                }, this.printArrow(r, [
                                    {
                                        x: 0,
                                        y: c.y / 2
                                    },
                                    {
                                        x: c.x,
                                        y: 0
                                    },
                                    {
                                        x: c.x,
                                        y: c.y
                                    }
                                ]);
                            case l:
                                return r = {
                                    x: i - c.y / 2,
                                    y: s - c.x
                                }, this.printArrow(r, [
                                    {
                                        x: 0,
                                        y: 0
                                    },
                                    {
                                        x: c.y / 2,
                                        y: c.x
                                    },
                                    {
                                        x: c.y,
                                        y: 0
                                    }
                                ]);
                            default:
                                return "";
                        }
                    },
                    print: function() {
                        var t = e1.config, n = t.linePoints, r = t.arrowPoint, i = t.arrowType, s = t.noArrow;
                        return s && (n[n.length - 1].x += e1.theme.arrow.size.x), "\n            <g>\n               ".concat(this.printLine(n), "\n               ").concat(!s && this.printArrowByType(i, r), "\n            </g>");
                    }
                };
            };
            function ar(e1) {
                return ar = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e1) {
                    return typeof e1;
                } : function(e1) {
                    return e1 && "function" == typeof Symbol && e1.constructor === Symbol && e1 !== Symbol.prototype ? "symbol" : typeof e1;
                }, ar(e1);
            }
            function or(e1, t) {
                var n = Object.keys(e1);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e1);
                    t && (r = r.filter(function(t) {
                        return Object.getOwnPropertyDescriptor(e1, t).enumerable;
                    })), n.push.apply(n, r);
                }
                return n;
            }
            function lr(e1) {
                for(var t = 1; t < arguments.length; t++){
                    var n = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? or(Object(n), !0).forEach(function(t) {
                        var r, i, s;
                        r = e1, i = t, s = n[t], (i = function(e1) {
                            var t = function(e1, t) {
                                if ("object" !== ar(e1) || null === e1) return e1;
                                var n = e1[Symbol.toPrimitive];
                                if (void 0 !== n) {
                                    var r = n.call(e1, "string");
                                    if ("object" !== ar(r)) return r;
                                    throw new TypeError("@@toPrimitive must return a primitive value.");
                                }
                                return String(e1);
                            }(e1);
                            return "symbol" === ar(t) ? t : String(t);
                        }(i)) in r ? Object.defineProperty(r, i, {
                            value: s,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : r[i] = s;
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e1, Object.getOwnPropertyDescriptors(n)) : or(Object(n)).forEach(function(t) {
                        Object.defineProperty(e1, t, Object.getOwnPropertyDescriptor(n, t));
                    });
                }
                return e1;
            }
            function cr(e1) {
                return cr = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e1) {
                    return typeof e1;
                } : function(e1) {
                    return e1 && "function" == typeof Symbol && e1.constructor === Symbol && e1 !== Symbol.prototype ? "symbol" : typeof e1;
                }, cr(e1);
            }
            function ur(e1, t) {
                var n = Object.keys(e1);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e1);
                    t && (r = r.filter(function(t) {
                        return Object.getOwnPropertyDescriptor(e1, t).enumerable;
                    })), n.push.apply(n, r);
                }
                return n;
            }
            var pr = function(e1, t) {
                var n, r = function(e1, t) {
                    var n = tr(e1), r = t[n.getThemeFieldName()], i = lr({}, t.RootStartPoint), s = i.center, a = i.childOffset, o = n(e1, s, r);
                    return o.setChildOffsetPoint(a), o;
                }(e1, t), a = function(e1) {
                    for(var t = 1; t < arguments.length; t++){
                        var n = null != arguments[t] ? arguments[t] : {};
                        t % 2 ? ur(Object(n), !0).forEach(function(t) {
                            var r, i, s;
                            r = e1, i = t, s = n[t], (i = function(e1) {
                                var t = function(e1, t) {
                                    if ("object" !== cr(e1) || null === e1) return e1;
                                    var n = e1[Symbol.toPrimitive];
                                    if (void 0 !== n) {
                                        var r = n.call(e1, "string");
                                        if ("object" !== cr(r)) return r;
                                        throw new TypeError("@@toPrimitive must return a primitive value.");
                                    }
                                    return String(e1);
                                }(e1);
                                return "symbol" === cr(t) ? t : String(t);
                            }(i)) in r ? Object.defineProperty(r, i, {
                                value: s,
                                enumerable: !0,
                                configurable: !0,
                                writable: !0
                            }) : r[i] = s;
                        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e1, Object.getOwnPropertyDescriptors(n)) : ur(Object(n)).forEach(function(t) {
                            Object.defineProperty(e1, t, Object.getOwnPropertyDescriptor(n, t));
                        });
                    }
                    return e1;
                }({}, r.getChildOffsetPoint()), o = [];
                return tt(e1, r, function(e1, t) {
                    a.x += t.getChildOffsetPoint().x;
                }, function(e1, r) {
                    if (a.y += hr(t, e1, n), r.getNodeType() === i.CONDITIONAL && e1.key === s.ALTERNATE && !r.checkIfChildExist(s.ALTERNATE)) {
                        var l = r.getAlternativeBranchChildOffsetPoint();
                        a.x = l.x + r.getMargin(), a.y = l.y;
                    }
                    var c = function(e1, t, n) {
                        var r = tr(e1), i = n[r.getThemeFieldName()];
                        return r(e1, t, i);
                    }(e1, {
                        x: a.x,
                        y: a.y
                    }, t);
                    return a.x = c.getPosition().x, a.y = c.getPosition().y, o.push(c), r.connectChild(c), a.y += c.getChildOffsetPoint().y, n = e1, c;
                }, function(e1, t) {
                    e1.type === i.CONDITIONAL && (a.y = t.getChildBoundaries().max.y + t.getMargin()), a.x = t.getPosition().x;
                }), {
                    list: o,
                    root: r
                };
            }, hr = function(e1, t) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = [
                    i.FUNCTION,
                    i.FUNCTION_DECLARATION,
                    i.FUNCTION_EXPRESSION,
                    i.ARROW_FUNCTION_EXPRESSION,
                    i.CLASS_DECLARATION,
                    i.IMPORT_DECLARATION,
                    i.EXPORT_NAMED_DECLARATION,
                    i.EXPORT_DEFAULT_DECLARATION
                ];
                return r.includes(t.type) && !r.includes(n.type) && t.pathParentType !== i.CALL_EXPRESSION ? e1.BaseShape.complexTypeExtraSpace : 0;
            }, dr = function(e1, t) {
                var n = [], r = function(e1) {
                    var r = function(e1, t) {
                        var n = t.ConnectionArrow, r = function(e1, t) {
                            var n = e1.startPoint, r = e1.endPoint, i = e1.boundaryPoint, s = e1.arrowType, c = {
                                linePoints: [],
                                arrowPoint: {
                                    x: r.x,
                                    y: r.y
                                }
                            };
                            switch(s){
                                case a:
                                    c.linePoints = [
                                        {
                                            x: n.x,
                                            y: n.y
                                        }
                                    ], c.linePoints = i ? c.linePoints.concat([
                                        {
                                            x: i.x,
                                            y: n.y
                                        },
                                        {
                                            x: i.x,
                                            y: r.y
                                        },
                                        {
                                            x: r.x,
                                            y: r.y
                                        }
                                    ]) : c.linePoints.concat([
                                        {
                                            x: n.x,
                                            y: r.y
                                        },
                                        {
                                            x: r.x,
                                            y: r.y
                                        }
                                    ]);
                                    break;
                                case o:
                                    c.linePoints = [
                                        {
                                            x: n.x,
                                            y: n.y
                                        },
                                        {
                                            x: i.x + t.lineTurnOffset,
                                            y: n.y
                                        },
                                        {
                                            x: i.x + t.lineTurnOffset,
                                            y: r.y
                                        },
                                        {
                                            x: r.x - t.lineTurnOffset,
                                            y: r.y
                                        }
                                    ];
                                    break;
                                case l:
                                    c.linePoints = [
                                        {
                                            x: n.x,
                                            y: n.y
                                        },
                                        {
                                            x: i.x + t.lineTurnOffset,
                                            y: n.y
                                        },
                                        {
                                            x: i.x + t.lineTurnOffset,
                                            y: r.y - t.lineTurnOffset
                                        },
                                        {
                                            x: r.x,
                                            y: r.y - t.lineTurnOffset
                                        },
                                        {
                                            x: r.x,
                                            y: r.y
                                        }
                                    ];
                            }
                            return c;
                        }(e1, n);
                        return function(e1, t) {
                            return N({
                                config: e1,
                                theme: t,
                                originalTheme: t
                            }, [
                                ir,
                                sr,
                                rr
                            ]);
                        }(lr(lr({}, e1), r), n);
                    }(e1, t);
                    return n.push(r), r;
                }, s = null;
                return tt(e1, e1, function(e1) {}, function(e1, t) {
                    s = e1;
                    var n = yr(e1, t), i = r(n);
                    return e1.assignConnectionArrow(i), e1;
                }, function(e1) {
                    if (e1.getNodeType() === i.LOOP) {
                        var t = e1.getChildBoundaries().max;
                        e1.assignLoopedConnectionArrow(r({
                            startPoint: s.getBackPoint(),
                            endPoint: e1.getMidPoint(),
                            boundaryPoint: {
                                x: t.x
                            },
                            arrowType: l
                        }));
                    }
                }, {
                    getBody: function(e1) {
                        return e1.getBody();
                    }
                }), n;
            }, fr = function(e1, t) {
                return !![
                    i.IMPORT_SPECIFIER,
                    i.IMPORT_DEFAULT_SPECIFIER,
                    i.OBJECT_PROPERTY
                ].includes(e1.getNodeType()) || !(![
                    i.FUNCTION_DECLARATION,
                    i.FUNCTION_EXPRESSION,
                    i.FUNCTION,
                    i.ARROW_FUNCTION_EXPRESSION
                ].includes(e1.getNodeType()) || ![
                    i.CALL_EXPRESSION,
                    i.VARIABLE_DECLARATOR,
                    i.ASSIGNMENT_EXPRESSION,
                    i.NEW_EXPRESSION
                ].includes(t.getNodeType())) || void 0;
            }, yr = function(e1, t) {
                var n = {
                    endPoint: e1.getToPoint(),
                    arrowType: a,
                    noArrow: fr(e1, t)
                };
                if (e1.getNodeKey() === s.ALTERNATE && t.getAlternativeBranchChildOffsetPoint) {
                    var r = t.getAlternativeBranchChildOffsetPoint();
                    n.startPoint = t.getAlternateFromPoint(), n.boundaryPoint = {
                        x: r.x
                    };
                } else n.startPoint = t.getFromPoint();
                return n;
            };
            const mr = function() {
                var e1 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = et(Qe(), e1);
                return {
                    buildShapesTree: function(e1) {
                        var n = [];
                        try {
                            n = function(e1, t) {
                                var n, r = (n = {
                                    shapes: [],
                                    arrowConnections: []
                                }, {
                                    getShapes: function() {
                                        return n.shapes;
                                    },
                                    addShapes: function(e1) {
                                        return n.shapes = n.shapes.concat(e1), this;
                                    },
                                    addArrowConnections: function(e1) {
                                        return n.arrowConnections = n.arrowConnections.concat(e1), this;
                                    },
                                    printChildren: function(e1) {
                                        var t = "";
                                        return [].concat(n.shapes, n.arrowConnections).forEach(function(n) {
                                            t += n.print(e1);
                                        }), t;
                                    },
                                    calculateDimensions: function() {
                                        var e1 = nt(n.shapes.map(function(e1) {
                                            return e1.getBoundaries();
                                        }));
                                        return {
                                            w: Math.ceil(e1.max.x) + 25,
                                            h: Math.ceil(e1.max.y) + 25
                                        };
                                    },
                                    print: function(e1) {
                                        var t = this.calculateDimensions(), n = t.w, r = t.h;
                                        return '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n                <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" \n                width="'.concat(n, '" height="').concat(r, '" shape-rendering="optimizeSpeed">\n                ').concat(this.printChildren(e1), "\n            </svg>");
                                    }
                                }), i = pr(e1, t), s = dr(i.root, t);
                                return r.addShapes(i.list).addShapes(i.root), r.addArrowConnections(s), r;
                            }(e1, t);
                        } catch (e1) {
                            throw L("Error at buildShapesTree" + e1.message, e1.stack), e1;
                        }
                        return n;
                    },
                    applyTheme: function(e1) {
                        t = et(t, e1);
                    },
                    applyDefaultTheme: function() {
                        this.applyTheme(Qe());
                    },
                    applyBlackAndWhiteTheme: function() {
                        this.applyTheme(ze(He));
                    },
                    applyBlurredTheme: function() {
                        this.applyTheme(Ze());
                    },
                    applyLightTheme: function() {
                        this.applyTheme(ze($e));
                    },
                    applyColorBasedTheme: function(e1) {
                        this.applyTheme(function(e1) {
                            return Ie(e1);
                        }(e1));
                    }
                };
            };
            var Tr = function(e1) {
                var t = Ae();
                return t.setAbstractionLevel(e1), function(e1) {
                    return t.buildFlowTreeFromAst(e1);
                };
            }, gr = Tr(ae.EXPORT), br = Tr([
                ae.EXPORT,
                ae.IMPORT
            ]), Er = Tr([
                ae.EXPORT,
                ae.IMPORT,
                ae.CLASS,
                ae.FUNCTION
            ]), Sr = Tr([
                ae.EXPORT,
                ae.IMPORT,
                ae.CLASS,
                ae.FUNCTION,
                ae.FUNCTION_DEPENDENCIES
            ]), Pr = function(e1) {
                return Ae().buildFlowTreeFromAst(e1);
            }, xr = Ae, Dr = De, Ar = mr, vr = function(e1) {
                var t = function(e1, t, n) {
                    t && e1.updateTheme(t), n && (e1.getAssignedConnectionArrow().updateTheme(n), e1.getLoopedConnectionArrow && e1.getLoopedConnectionArrow().updateTheme(n));
                };
                return {
                    findShape: function(t) {
                        var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return e1.getShapes().filter(function(e1, r) {
                            return r >= n && t(e1);
                        });
                    },
                    applyShapeStyles: function(e1, n, r) {
                        this.findShape(e1).forEach(function(e1) {
                            t(e1, n, r);
                        });
                    },
                    blur: function(e1) {
                        var n = Ze();
                        this.findShape(e1).forEach(function(e1) {
                            var r = e1.getAssignedConnectionArrow();
                            t(e1, n[e1.getShapeType()], r ? n[r.getFieldName()] : null);
                        });
                    },
                    focus: function(e1) {
                        this.blur(function(t) {
                            return !e1(t);
                        });
                    },
                    blurShapeBranch: function(e1) {
                        var n = Ze();
                        this.findShape(e1).forEach(function(e1) {
                            return ue(e1, function(e1) {
                                var r = e1.getAssignedConnectionArrow();
                                t(e1, n[e1.getShapeType()], r ? n[r.getFieldName()] : null);
                            }, function(e1) {
                                return e1.state.body;
                            });
                        });
                    },
                    focusShapeBranch: function(n) {
                        var r = this, i = Ze();
                        [].concat(n).forEach(function(n, s) {
                            r.findShape(n).forEach(function(n) {
                                var a = St(n, function(e1) {
                                    return e1.state.body;
                                }), o = e1.getShapes().indexOf(n);
                                r.findShape(function(e1) {
                                    return !a.includes(e1);
                                }, s > 0 ? o : 0).forEach(function(e1) {
                                    var n = e1.getAssignedConnectionArrow();
                                    t(e1, i[e1.getShapeType()], n ? i[n.getFieldName()] : null);
                                });
                            });
                        });
                    },
                    print: function(t) {
                        return e1 && e1.print(t);
                    }
                };
            }, Cr = function(e1) {
                return {
                    buildSlides: function() {
                        var t = mr(), n = R(e1);
                        return [
                            gr(n),
                            br(n),
                            Er(n),
                            Sr(n),
                            Pr(n)
                        ].filter(function(e1) {
                            return e1.body.length;
                        }).map(t.buildShapesTree).map(function(e1) {
                            return e1.print();
                        });
                    }
                };
            }, wr = function(e1, t) {
                return Ir(Or(e1), t);
            }, Or = function(e1) {
                return xr().build(e1);
            }, Ir = function(e1, t) {
                return Ar().buildShapesTree(e1).print(t);
            };
        })(), r;
    })()); //# sourceMappingURL=js2flowchart.js.map
}}),

};

//# sourceMappingURL=node_modules_js2flowchart_dist_js2flowchart_7433fe.js.map